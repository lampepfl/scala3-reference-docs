<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/lampepfl/dotty" data-githubContributorsFilename="docs/_docs/reference/metaprogramming/macros.md" data-pathToRoot="../"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Macros</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="/css/dottydoc.css"></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.4.0</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../index.html">Docs</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni n1 "><span class="nh de"><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni n1 "><span class="nh de"><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>Metaprogramming</span></a></span><div class="ni n1 "><span class="nh de"><a href="inline.html"><span>Inline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n1 expanded"><span class="nh h100 selected de"><a href="#"><span>Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="staging.html"><span>Run-Time Multi-Stage Programming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="reflection.html"><span>Reflection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits and Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../experimental/index.html"><span>Experimental</span></a></span><div class="ni n1 "><span class="nh de"><a href="../experimental/canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/cc.html"><span>Capture Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/tupled-function.html"><span>Tupled Function</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2024, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2024, LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Metaprogramming</a>/<a href="macros.html">Macros</a></div><div id="content" class="body-medium"><div><div id="content-wrapper">
 <div class="site-container">
  <div id="site-header"></div>
  <main>
   <header>
    <a class="text-button with-link body-small" href="https://github.com/lampepfl/dotty/edit/language-reference-stable/docs/_docs/reference/metaprogramming/macros.md">Edit this page on GitHub</a>
    <h1 class="h600">Macros</h1>
   </header>
   <blockquote>
    <p>When developing macros enable <code>-Xcheck-macros</code> scalac option flag to have extra runtime checks.</p>
   </blockquote>
   <section id="multi-staging-1">
    <h2 class="h500"><a href="#multi-staging-1" class="anchor"></a>Multi-Staging</h2>
   </section>
   <section id="quoted-expressions-1">
    <h4 class="h300"><a href="#quoted-expressions-1" class="anchor"></a>Quoted expressions</h4>
    <p>Multi-stage programming in Scala 3 uses quotes <code>'{..}</code> to delay, i.e., stage, execution of code and splices <code>${..}</code> to evaluate and insert code into quotes. Quoted expressions are typed as <code>Expr[T]</code> with a covariant type parameter <code>T</code>. It is easy to write statically safe code generators with these two concepts. The following example shows a naive implementation of the $x^n$ mathematical operation.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.quoted.*
</span><span line-number="2" class=""><span class="tooltip-container"></span>def unrolledPowerCode(x: Expr[Double], n: Int)(using Quotes): Expr[Double] =
</span><span line-number="3" class=""><span class="tooltip-container"></span>  if n == 0 then '{ 1.0 }
</span><span line-number="4" class=""><span class="tooltip-container"></span>  else if n == 1 then x
</span><span line-number="5" class=""><span class="tooltip-container"></span>  else '{ $x * ${ unrolledPowerCode(x, n-1) } }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val x = ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${ unrolledPowerCode('{x}, 3) } // evaluates to: x * x * x
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Quotes and splices are duals of each other. For an arbitrary expression <code>x</code> of type <code>T</code> we have <code>${'{x}} = x</code> and for an arbitrary expression <code>e</code> of type <code>Expr[T]</code> we have <code>'{${e}} = e</code>.</p>
   </section>
   <section id="abstract-types-1">
    <h4 class="h300"><a href="#abstract-types-1" class="anchor"></a>Abstract types</h4>
    <p>Quotes can handle generic and abstract types using the type class <code>Type[T]</code>. A quote that refers to a generic or abstract type <code>T</code> requires a given <code>Type[T]</code> to be provided in the implicit scope. The following examples show how <code>T</code> is annotated with a context bound (<code>: Type</code>) to provide an implicit <code>Type[T]</code>, or the equivalent <code>using Type[T]</code> parameter.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.quoted.*
</span><span line-number="2" class=""><span class="tooltip-container"></span>def singletonListExpr[T: Type](x: Expr[T])(using Quotes): Expr[List[T]] =
</span><span line-number="3" class=""><span class="tooltip-container"></span>  '{ List[T]($x) } // generic T used within a quote
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>def emptyListExpr[T](using Type[T], Quotes): Expr[List[T]] =
</span><span line-number="6" class=""><span class="tooltip-container"></span>  '{ List.empty[T] } // generic T used within a quote
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>If no other instance is found, the default <code>Type.of[T]</code> is used. The following example implicitly uses <code>Type.of[String]</code> and <code>Type.of[Option[U]]</code>.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val list1: Expr[List[String]] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  singletonListExpr('{"hello"}) // requires a given `Type[Sting]`
</span><span line-number="3" class=""><span class="tooltip-container"></span>val list0: Expr[List[Option[T]]] =
</span><span line-number="4" class=""><span class="tooltip-container"></span>  emptyListExpr[Option[U]] // requires a given `Type[Option[U]]`
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The <code>Type.of[T]</code> method is a primitive operation that the compiler will handle specially. It will provide the implicit if the type <code>T</code> is statically known, or if <code>T</code> contains some other types <code>Ui</code> for which we have an implicit <code>Type[Ui]</code>. In the example, <code>Type.of[String]</code> has a statically known type and <code>Type.of[Option[U]]</code> requires an implicit <code>Type[U]</code> in scope.</p>
   </section>
   <section id="quote-context-1">
    <h4 class="h300"><a href="#quote-context-1" class="anchor"></a>Quote context</h4>
    <p>We also track the current quotation context using a given <code>Quotes</code> instance. To create a quote <code>'{..}</code> we require a given <code>Quotes</code> context, which should be passed as a contextual parameter <code>(using Quotes)</code> to the function. Each splice will provide a new <code>Quotes</code> context within the scope of the splice. Therefore quotes and splices can be seen as methods with the following signatures, but with special semantics.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def '[T](x: T): Quotes ?=&gt; Expr[T] // def '[T](x: T)(using Quotes): Expr[T]
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>def $[T](x: Quotes ?=&gt; Expr[T]): T
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The lambda with a question mark <code>?=&gt;</code> is a contextual function; it is a lambda that takes its argument implicitly and provides it implicitly in the implementation the lambda. <code>Quotes</code> are used for a variety of purposes that will be mentioned when covering those topics.</p>
   </section>
   <section id="quoted-values-1">
    <h2 class="h500"><a href="#quoted-values-1" class="anchor"></a>Quoted Values</h2>
   </section>
   <section id="lifting-1">
    <h4 class="h300"><a href="#lifting-1" class="anchor"></a>Lifting</h4>
    <p>While it is not possible to use cross-stage persistence of local variables, it is possible to lift them to the next stage. To this end, we provide the <code>Expr.apply</code> method, which can take a value and lift it into a quoted representation of the value.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val expr1plus1: Expr[Int] = '{ 1 + 1 }
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>val expr2: Expr[Int] = Expr(1 + 1) // lift 2 into '{ 2 }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>While it looks type wise similar to <code>'{ 1 + 1 }</code>, the semantics of <code>Expr(1 + 1)</code> are quite different. <code>Expr(1 + 1)</code> will not stage or delay any computation; the argument is evaluated to a value and then lifted into a quote. The quote will contain code that will create a copy of this value in the next stage. <code>Expr</code> is polymorphic and user-extensible via the <code>ToExpr</code> type class.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait ToExpr[T]:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def apply(x: T)(using Quotes): Expr[T]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>We can implement a <code>ToExpr</code> using a <code>given</code> definition that will add the definition to the implicits in scope. In the following example we show how to implement a <code>ToExpr[Option[T]]</code> for any liftable type `T.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given OptionToExpr[T: Type: ToExpr]: ToExpr[Option[T]] with
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def apply(opt: Option[T])(using Quotes): Expr[Option[T]] =
</span><span line-number="3" class=""><span class="tooltip-container"></span>    opt match
</span><span line-number="4" class=""><span class="tooltip-container"></span>      case Some(x) =&gt; '{ Some[T]( ${Expr(x)} ) }
</span><span line-number="5" class=""><span class="tooltip-container"></span>      case None =&gt; '{ None }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The <code>ToExpr</code> for primitive types must be implemented as primitive operations in the system. In our case, we use the reflection API to implement them.</p>
   </section>
   <section id="extracting-values-from-quotes-1">
    <h4 class="h300"><a href="#extracting-values-from-quotes-1" class="anchor"></a>Extracting values from quotes</h4>
    <p>To be able to generate optimized code using the method <code>unrolledPowerCode</code>, the macro implementation <code>powerCode</code> needs to first determine whether the argument passed as parameter <code>n</code> is a known constant value. This can be achieved via <em>unlifting</em> using the <code>Expr.unapply</code> extractor from our library implementation, which will only match if <code>n</code> is a quoted constant and extracts its value.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  n match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case Expr(m) =&gt; // it is a constant: unlift code n='{m} into number m
</span><span line-number="4" class=""><span class="tooltip-container"></span>      unrolledPowerCode(x, m)
</span><span line-number="5" class=""><span class="tooltip-container"></span>    case _ =&gt; // not known: call power at run-time
</span><span line-number="6" class=""><span class="tooltip-container"></span>      '{ power($x, $n) }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Alternatively, the <code>n.value</code> method can be used to get an <code>Option[Int]</code> with the value or <code>n.valueOrAbort</code> to get the value directly.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  // emits an error message if `n` is not a constant
</span><span line-number="3" class=""><span class="tooltip-container"></span>  unrolledPowerCode(x, n.valueOrAbort)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><code>Expr.unapply</code> and all variants of <code>value</code> are polymorphic and user-extensible via a given <code>FromExpr</code> type class.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait FromExpr[T]:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def unapply(x: Expr[T])(using Quotes): Option[T]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>We can use <code>given</code> definitions to implement the <code>FromExpr</code> as we did for <code>ToExpr</code>. The <code>FromExpr</code> for primitive types must be implemented as primitive operations in the system. In our case, we use the reflection API to implement them. To implement <code>FromExpr</code> for non-primitive types we use quote pattern matching (for example <code>OptionFromExpr</code>).</p>
   </section>
   <section id="macros-and-multi-stage-programming-1">
    <h2 class="h500"><a href="#macros-and-multi-stage-programming-1" class="anchor"></a>Macros and Multi-Stage Programming</h2>
    <p>The system supports multi-stage macros and run-time multi-stage programming using the same quotation abstractions.</p>
   </section>
   <section id="multi-stage-macros-1">
    <h3 class="h400"><a href="#multi-stage-macros-1" class="anchor"></a>Multi-Stage Macros</h3>
   </section>
   <section id="macros-2">
    <h4 class="h300"><a href="#macros-2" class="anchor"></a>Macros</h4>
    <p>We can generalize the splicing abstraction to express macros. A macro consists of a top-level splice that is not nested in any quote. Conceptually, the contents of the splice are evaluated one stage earlier than the program. In other words, the contents are evaluated while compiling the program. The generated code resulting from the macro replaces the splice in the program.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def power2(x: Double): Double =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  ${ unrolledPowerCode('x, 2) } // x * x
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="inline-macros-1">
    <h4 class="h300"><a href="#inline-macros-1" class="anchor"></a>Inline macros</h4>
    <p>Since using the splices in the middle of a program is not as ergonomic as calling a function; we hide the staging mechanism from end-users of macros. We have a uniform way of calling macros and normal functions. For this, <em>we restrict the use of top-level splices to only appear in inline methods</em>[^1][^2].</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// inline macro definition
</span><span line-number="2" class=""><span class="tooltip-container"></span>inline def powerMacro(x: Double, inline n: Int): Double =
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${ powerCode('x, 'n) }
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>// user code
</span><span line-number="6" class=""><span class="tooltip-container"></span>def power2(x: Double): Double =
</span><span line-number="7" class=""><span class="tooltip-container"></span>  powerMacro(x, 2) // x * x
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The evaluation of the macro will only happen when the code is inlined into <code>power2</code>. When inlined, the code is equivalent to the previous definition of <code>power2</code>. A consequence of using inline methods is that none of the arguments nor the return type of the macro will have to mention the <code>Expr</code> types; this hides all aspects of metaprogramming from the end-users.</p>
   </section>
   <section id="avoiding-a-complete-interpreter-1">
    <h4 class="h300"><a href="#avoiding-a-complete-interpreter-1" class="anchor"></a>Avoiding a complete interpreter</h4>
    <p>When evaluating a top-level splice, the compiler needs to interpret the code that is within the splice. Providing an interpreter for the entire language is quite tricky, and it is even more challenging to make that interpreter run efficiently. To avoid needing a complete interpreter, we can impose the following restrictions on splices to simplify the evaluation of the code in top-level splices.</p>
    <ul>
     <li>The top-level splice must contain a single call to a compiled static method.</li>
     <li>Arguments to the function are literal constants, quoted expressions (parameters), calls to <code>Type.of</code> for type parameters and a reference to <code>Quotes</code>.</li>
    </ul>
    <p>In particular, these restrictions disallow the use of splices in top-level splices. Such a splice would require several stages of interpretation which would be unnecessarily inefficient.</p>
   </section>
   <section id="compilation-stages-1">
    <h4 class="h300"><a href="#compilation-stages-1" class="anchor"></a>Compilation stages</h4>
    <p>The macro implementation (i.e., the method called in the top-level splice) can come from any pre-compiled library. This provides a clear difference between the stages of the compilation process. Consider the following 3 source files defined in distinct libraries.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// Macro.scala
</span><span line-number="2" class=""><span class="tooltip-container"></span>def powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] = ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>inline def powerMacro(x: Double, inline n: Int): Double =
</span><span line-number="4" class=""><span class="tooltip-container"></span>  ${ powerCode('x, 'n) }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// Lib.scala (depends on Macro.scala)
</span><span line-number="2" class=""><span class="tooltip-container"></span>def power2(x: Double) =
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${ powerCode('x, '{2}) } // inlined from a call to: powerMacro(x, 2)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// App.scala  (depends on Lib.scala)
</span><span line-number="2" class=""><span class="tooltip-container"></span>@main def app() = power2(3.14)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>One way to syntactically visualize this is to put the application in a quote that delays the compilation of the application. Then the application dependencies can be placed in an outer quote that contains the quoted application, and we repeat this recursively for dependencies of dependencies.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{ // macro library (compilation stage 1)
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] =
</span><span line-number="3" class=""><span class="tooltip-container"></span>    ...
</span><span line-number="4" class=""><span class="tooltip-container"></span>  inline def powerMacro(x: Double, inline n: Int): Double =
</span><span line-number="5" class=""><span class="tooltip-container"></span>    ${ powerCode('x, 'n) }
</span><span line-number="6" class=""><span class="tooltip-container"></span>  '{ // library using macros (compilation stage 2)
</span><span line-number="7" class=""><span class="tooltip-container"></span>    def power2(x: Double) =
</span><span line-number="8" class=""><span class="tooltip-container"></span>      ${ powerCode('x, '{2}) } // inlined from a call to: powerMacro(x, 2)
</span><span line-number="9" class=""><span class="tooltip-container"></span>    '{ power2(3.14) /* app (compilation stage 3) */ }
</span><span line-number="10" class=""><span class="tooltip-container"></span>  }
</span><span line-number="11" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>To make the system more versatile, we allow calling macros in the project where it is defined, with some restrictions. For example, to compile <code>Macro.scala</code> and <code>Lib.scala</code> together in the same library. To this end, we do not follow the simpler syntactic model and rely on semantic information from the source files. When compiling a source, if we detect a call to a macro that is not compiled yet, we delay the compilation of this source to the following compilation stage. In the example, we would delay the compilation of <code>Lib.scala</code> because it contains a compile-time call to <code>powerCode</code>. Compilation stages are repeated until all sources are compiled, or no progress can be made. If no progress is made, there was a cyclic dependency between the definition and the use of the macro. We also need to detect if at runtime the macro depends on sources that have not been compiled yet. These are detected by executing the macro and checking for JVM linking errors to classes that have not been compiled yet.</p>
   </section>
   <section id="run-time-multi-stage-programming-2">
    <h3 class="h400"><a href="#run-time-multi-stage-programming-2" class="anchor"></a>Run-Time Multi-Stage Programming</h3>
    <p>See <a href="staging.html">Run-Time Multi-Stage Programming</a></p>
   </section>
   <section id="safety-1">
    <h2 class="h500"><a href="#safety-1" class="anchor"></a>Safety</h2>
    <p>Multi-stage programming is by design statically safe and cross-stage safe.</p>
   </section>
   <section id="static-safety-1">
    <h3 class="h400"><a href="#static-safety-1" class="anchor"></a>Static Safety</h3>
   </section>
   <section id="hygiene-1">
    <h4 class="h300"><a href="#hygiene-1" class="anchor"></a>Hygiene</h4>
    <p>All identifier names are interpreted as symbolic references to the corresponding variable in the context of the quote. Therefore, while evaluating the quote, it is not possible to accidentally rebind a reference to a new variable with the same textual name.</p>
   </section>
   <section id="well-typed-1">
    <h4 class="h300"><a href="#well-typed-1" class="anchor"></a>Well-typed</h4>
    <p>If a quote is well typed, then the generated code is well typed. This is a simple consequence of tracking the type of each expression. An <code>Expr[T]</code> can only be created from a quote that contains an expression of type <code>T</code>. Conversely, an <code>Expr[T]</code> can only be spliced in a location that expects a type <code>T</code>. As mentioned before, <code>Expr</code> is covariant in its type parameter. This means that an <code>Expr[T]</code> can contain an expression of a subtype of <code>T</code>. When spliced in a location that expects a type `T, these expressions also have a valid type.</p>
   </section>
   <section id="cross-stage-safety-1">
    <h3 class="h400"><a href="#cross-stage-safety-1" class="anchor"></a>Cross-Stage Safety</h3>
   </section>
   <section id="level-consistency-1">
    <h4 class="h300"><a href="#level-consistency-1" class="anchor"></a>Level consistency</h4>
    <p>We define the <em>staging level</em> of some code as the number of quotes minus the number of splices surrounding said code. Local variables must be defined and used in the same staging level.</p>
    <p>It is never possible to access a local variable from a lower staging level as it does not yet exist.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def badPower(x: Double, n: Int): Double =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  ${ unrolledPowerCode('x, n) } // error: value of `n` not known yet
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>In the context of macros and <em>cross-platform portability</em>, that is, macros compiled on one machine but potentially executed on another, we cannot support cross-stage persistence of local variables. Therefore, local variables can only be accessed at precisely the same staging level in our system.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def badPowerCode(x: Expr[Double], n: Int)(using Quotes): Expr[Double] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  // error: `n` potentially not available in the next execution environment
</span><span line-number="3" class=""><span class="tooltip-container"></span>  '{ power($x, n) }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The rules are slightly different for global definitions, such as <code>unrolledPowerCode</code>. It is possible to generate code that contains a reference to a <em>global</em> definition such as in <code>'{ power(2, 4) }</code>. This is a limited form of cross-stage persistence that does not impede cross-platform portability, where we refer to the already compiled code for <code>power</code>. Each compilation step will lower the staging level by one while keeping global definitions. In consequence, we can refer to compiled definitions in macros such as <code>unrolledPowerCode</code> in <code>${ unrolledPowerCode('x, 2) }</code>.</p>
    <p>We can sumarize level consistency in two rules:</p>
    <ul>
     <li>Local variables can be used only at the same staging level as their definition</li>
     <li>Global variables can be used at any staging level</li>
    </ul>
   </section>
   <section id="type-consistency-1">
    <h4 class="h300"><a href="#type-consistency-1" class="anchor"></a>Type consistency</h4>
    <p>As Scala uses type erasure, generic types will be erased at run-time and hence in any following stage. To ensure any quoted expression that refers to a generic type <code>T</code> does not lose the information it needs, we require a given <code>Type[T]</code> in scope. The <code>Type[T]</code> will carry over the non-erased representation of the type into the next phase. Therefore any generic type used at a higher staging level than its definition will require its <code>Type</code>.</p>
   </section>
   <section id="scope-extrusion-1">
    <h4 class="h300"><a href="#scope-extrusion-1" class="anchor"></a>Scope extrusion</h4>
    <p>Within the contents of a splice, it is possible to have a quote that refers to a local variable defined in the outer quote. If this quote is used within the splice, the variable will be in scope. However, if the quote is somehow <em>extruded</em> outside the splice, then variables might not be in scope anymore. Quoted expressions can be extruded using side effects such as mutable state and exceptions. The following example shows how a quote can be extruded using mutable state.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>var x: Expr[T] = null
</span><span line-number="2" class=""><span class="tooltip-container"></span>'{ (y: T) =&gt; ${ x = 'y; 1 } }
</span><span line-number="3" class=""><span class="tooltip-container"></span>x // has value '{y} but y is not in scope
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>A second way a variable can be extruded is through the <code>run</code> method. If <code>run</code> consumes a quoted variable reference, it will not be in scope anymore. The result will reference a variable that is defined in the next stage.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{ (x: Int) =&gt; ${ run('x); ... } }
</span><span line-number="2" class=""><span class="tooltip-container"></span>// evaluates to: '{ (x: Int) =&gt; ${ x; ... } 1
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>To catch both scope extrusion scenarios, our system restricts the use of quotes by only allowing a quote to be spliced if it was not extruded from a splice scope. Unlike level consistency, this is checked at run-time[^4] rather than compile-time to avoid making the static type system too complicated.</p>
    <p>Each <code>Quotes</code> instance contains a unique scope identifier and refers to its parent scope, forming a stack of identifiers. The parent of the scope of a <code>Quotes</code> is the scope of the <code>Quotes</code> used to create the enclosing quote. Top-level splices and <code>run</code> create new scope stacks. Every <code>Expr</code> knows in which scope it was created. When it is spliced, we check that the quote scope is either the same as the splice scope, or a parent scope thereof.</p>
   </section>
   <section id="staged-lambdas-1">
    <h2 class="h500"><a href="#staged-lambdas-1" class="anchor"></a>Staged Lambdas</h2>
    <p>When staging programs in a functional language there are two fundamental abstractions: a staged lambda <code>Expr[T =&gt; U]</code> and a staging lambda <code>Expr[T] =&gt; Expr[U]</code>. The first is a function that will exist in the next stage, whereas the second is a function that exists in the current stage. It is often convenient to have a mechanism to go from <code>Expr[T =&gt; U]</code> to <code>Expr[T] =&gt; Expr[U]</code> and vice versa.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def later[T: Type, U: Type](f: Expr[T] =&gt; Expr[U]): Expr[T =&gt; U] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  '{ (x: T) =&gt; ${ f('x) } }
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>def now[T: Type, U: Type](f: Expr[T =&gt; U]): Expr[T] =&gt; Expr[U] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  (x: Expr[T]) =&gt; '{ $f($x) }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Both conversions can be performed out of the box with quotes and splices. But if <code>f</code> is a known lambda function, <code>'{ $f($x) }</code> will not beta-reduce the lambda in place. This optimization is performed in a later phase of the compiler. Not reducing the application immediately can simplify analysis of generated code. Nevertheless, it is possible to beta-reduce the lambda in place using the <code>Expr.betaReduce</code> method.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def now[T: Type, U: Type](f: Expr[T =&gt; U]): Expr[T] =&gt; Expr[U] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  (x: Expr[T]) =&gt; Expr.betaReduce('{ $f($x) })
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The <code>betaReduce</code> method will beta-reduce the outermost application of the expression if possible (regardless of arity). If it is not possible to beta-reduce the expression, then it will return the original expression.</p>
   </section>
   <section id="staged-constructors-1">
    <h2 class="h500"><a href="#staged-constructors-1" class="anchor"></a>Staged Constructors</h2>
    <p>To create new class instances in a later stage, we can create them using factory methods (usually <code>apply</code> methods of an <code>object</code>), or we can instantiate them with a <code>new</code>. For example, we can write <code>Some(1)</code> or <code>new Some(1)</code>, creating the same value. In Scala 3, using the factory method call notation will fall back to a <code>new</code> if no <code>apply</code> method is found. We follow the usual staging rules when calling a factory method. Similarly, when we use a <code>new C</code>, the constructor of <code>C</code> is implicitly called, which also follows the usual staging rules. Therefore for an arbitrary known class <code>C</code>, we can use both <code>'{ C(...) }</code> or <code>'{ new C(...) }</code> as constructors.</p>
   </section>
   <section id="staged-classes-1">
    <h2 class="h500"><a href="#staged-classes-1" class="anchor"></a>Staged Classes</h2>
    <p>Quoted code can contain any valid expression including local class definitions. This allows the creation of new classes with specialized implementations. For example, we can implement a new version of <code>Runnable</code> that will perform some optimized operation.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def mkRunnable(x: Int)(using Quotes): Expr[Runnable] = '{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  class MyRunnable extends Runnable:
</span><span line-number="3" class=""><span class="tooltip-container"></span>    def run(): Unit = ... // generate some custom code that uses `x`
</span><span line-number="4" class=""><span class="tooltip-container"></span>  new MyRunnable
</span><span line-number="5" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The quoted class is a local class and its type cannot escape the enclosing quote. The class must be used inside the quote or an instance of it can be returned using a known interface (<code>Runnable</code> in this case).</p>
   </section>
   <section id="quote-pattern-matching-2">
    <h2 class="h500"><a href="#quote-pattern-matching-2" class="anchor"></a>Quote Pattern Matching</h2>
    <p>It is sometimes necessary to analyze the structure of the code or decompose the code into its sub-expressions. A classic example is an embedded DSL, where a macro knows a set of definitions that it can reinterpret while compiling the code (for instance, to perform optimizations). In the following example, we extend our previous implementation of <code>powCode</code> to look into <code>x</code> to perform further optimizations.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def fusedPowCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  x match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case '{ power($y, $m) } =&gt; // we have (y^m)^n
</span><span line-number="4" class=""><span class="tooltip-container"></span>      fusedPowCode(y, '{ $n * $m }) // generate code for y^(n*m)
</span><span line-number="5" class=""><span class="tooltip-container"></span>    case _ =&gt;
</span><span line-number="6" class=""><span class="tooltip-container"></span>      '{ power($x, $n) }
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="sub-patterns-1">
    <h4 class="h300"><a href="#sub-patterns-1" class="anchor"></a>Sub-patterns</h4>
    <p>In quoted patterns, the <code>$</code> binds the sub-expression to an expression <code>Expr</code> that can be used in that <code>case</code> branch. The contents of <code>${..}</code> in a quote pattern are regular Scala patterns. For example, we can use the <code>Expr(_)</code> pattern within the <code>${..}</code> to only match if it is a known value and extract it.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def fusedUnrolledPowCode(x: Expr[Double], n: Int)(using Quotes): Expr[Double] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  x match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case '{ power($y, ${Expr(m)}) } =&gt; // we have (y^m)^n
</span><span line-number="4" class=""><span class="tooltip-container"></span>      fusedUnrolledPowCode(y, n * m) // generate code for y * ... * y
</span><span line-number="5" class=""><span class="tooltip-container"></span>    case _ =&gt;                        //                  ( n*m times )
</span><span line-number="6" class=""><span class="tooltip-container"></span>      unrolledPowerCode(x, n)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>These value extraction sub-patterns can be polymorphic using an instance of <code>FromExpr</code>. In the following example, we show the implementation of <code>OptionFromExpr</code> which internally uses the <code>FromExpr[T]</code> to extract the value using the <code>Expr(x)</code> pattern.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given OptionFromExpr[T](using Type[T], FromExpr[T]): FromExpr[Option[T]] with
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def unapply(x: Expr[Option[T]])(using Quotes): Option[Option[T]] =
</span><span line-number="3" class=""><span class="tooltip-container"></span>    x match
</span><span line-number="4" class=""><span class="tooltip-container"></span>      case '{ Some( ${Expr(x)} ) } =&gt; Some(Some(x))
</span><span line-number="5" class=""><span class="tooltip-container"></span>      case '{ None } =&gt; Some(None)
</span><span line-number="6" class=""><span class="tooltip-container"></span>      case _ =&gt; None
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="closed-patterns-1">
    <h4 class="h300"><a href="#closed-patterns-1" class="anchor"></a>Closed patterns</h4>
    <p>Patterns may contain two kinds of references: global references such as the call to the <code>power</code> method in <code>'{ power(...) }</code>, or references to bindings defined in the pattern such as <code>x</code> in <code>case '{ (x: Int) =&gt; x }</code>. When extracting an expression from a quote, we need to ensure that we do not extrude any variable from the scope where it is defined.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{ (x: Int) =&gt; x + 1 } match
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case '{ (y: Int) =&gt; $z } =&gt;
</span><span line-number="3" class=""><span class="tooltip-container"></span>    // should not match, otherwise: z = '{ x + 1 }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>In this example, we see that the pattern should not match. Otherwise, any use of the expression <code>z</code> would contain an unbound reference to <code>x</code>. To avoid any such extrusion, we only match on a <code>${..}</code> if its expression is closed under the definitions within the pattern. Therefore, the pattern will not match if the expression is not closed.</p>
   </section>
   <section id="hoas-patterns-1">
    <h4 class="h300"><a href="#hoas-patterns-1" class="anchor"></a>HOAS patterns</h4>
    <p>To allow extracting expressions that may contain extruded references we offer a <em>higher-order abstract syntax</em> (HOAS) pattern <code>$f(y)</code> (or <code>$f(y1,...,yn)</code>). This pattern will eta-expand the sub-expression with respect to <code>y</code> and bind it to <code>f</code>. The lambda arguments will replace the variables that might have been extruded.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{ ((x: Int) =&gt; x + 1).apply(2) } match
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case '{ ((y: Int) =&gt; $f(y)).apply($z: Int) } =&gt;
</span><span line-number="3" class=""><span class="tooltip-container"></span>    // f may contain references to `x` (replaced by `$y`)
</span><span line-number="4" class=""><span class="tooltip-container"></span>    // f = (y: Expr[Int]) =&gt; '{ $y + 1 }
</span><span line-number="5" class=""><span class="tooltip-container"></span>    f(z) // generates '{ 2 + 1 }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>A HOAS pattern <code>$x(y1,...,yn)</code> will only match the expression if it does not contain references to variables defined in the pattern that are not in the set <code>y1,...,yn</code>. In other words, the pattern will match if the expression only contains references to variables defined in the pattern that are in <code>y1,...,yn</code>. Note that the HOAS patterns <code>$x()</code> are semantically equivalent to closed patterns <code>$x</code>.</p>
   </section>
   <section id="type-variables-1">
    <h4 class="h300"><a href="#type-variables-1" class="anchor"></a>Type variables</h4>
    <p>Expressions may contain types that are not statically known. For example, an <code>Expr[List[Int]]</code> may contain <code>list.map(_.toInt)</code> where <code>list</code> is a <code>List</code> of some type. To cover all the possible cases we would need to explicitly match <code>list</code> on all possible types (<code>List[Int]</code>, <code>List[Int =&gt; Int]</code>, ...). This is an infinite set of types and therefore pattern cases. Even if we would know all possible types that a specific program could use, we may still end up with an unmanageable number of cases. To overcome this, we introduce type variables in quoted patterns, which will match any type.</p>
    <p>In the following example, we show how type variables <code>t</code> and <code>u</code> match all possible pairs of consecutive calls to <code>map</code> on lists. In the quoted patterns, types named with lower cases are identified as type variables. This follows the same notation as type variables used in normal patterns.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def fuseMapCode(x: Expr[List[Int]]): Expr[List[Int]] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  x match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case '{ ($ls: List[t]).map[u]($f).map[Int]($g) } =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>      '{ $ls.map($g.compose($f)) }
</span><span line-number="5" class=""><span class="tooltip-container"></span>    ...
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>fuseMapCode('{ List(1.2).map(f).map(g) }) // '{ List(1.2).map(g.compose(f)) }
</span><span line-number="8" class=""><span class="tooltip-container"></span>fuseMapCode('{ List('a').map(h).map(i) }) // '{ List('a').map(i.compose(h))  }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Variables <code>f</code> and <code>g</code> are inferred to be of type <code>Expr[t =&gt; u]</code> and <code>Expr[u =&gt; Int]</code> respectively. Subsequently, we can infer <code>$g.compose($f)</code> to be of type <code>Expr[t =&gt; Int]</code> which is the type of the argument of <code>$ls.map(..)</code>.</p>
    <p>Type variables are abstract types that will be erased; this implies that to reference them in the second quote we need a given <code>Type[t]</code> and <code>Type[u]</code>. The quoted pattern will implicitly provide those given types. At run-time, when the pattern matches, the type of <code>t</code> and <code>u</code> will be known, and the <code>Type[t]</code> and <code>Type[u]</code> will contain the precise types in the expression.</p>
    <p>As <code>Expr</code> is covariant, the statically known type of the expression might not be the actual type. Type variables can also be used to recover the precise type of the expression.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def let(x: Expr[Any])(using Quotes): Expr[Any] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  x match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case '{ $x: t } =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>      '{ val y: t = $x; y }
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>let('{1}) // will return a `Expr[Any]` that contains an `Expr[Int]]`
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>It is also possible to refer to the same type variable multiple times in a pattern.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case '{ $x: (t, t) } =&gt;
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>While we can define the type variable in the middle of the pattern, their normal form is to define them as a <code>type</code> with a lower case name at the start of the pattern.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case '{ type t; $x: t } =&gt;
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This is a bit more verbose but has some expressivity advantages such as allowing to define bounds on the variables.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case '{ type t &gt;: List[Int] &lt;: Seq[Int]; $x: t } =&gt;
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="type-patterns-1">
    <h4 class="h300"><a href="#type-patterns-1" class="anchor"></a>Type patterns</h4>
    <p>It is possible to only have a type and no expression of that type. To be able to inspect a type, we introduce quoted type pattern <code>case '[..] =&gt;</code>. It works the same way as a quoted pattern but is restricted to contain a type. Type variables can be used in quoted type patterns to extract a type.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def empty[T: Type](using Quotes): Expr[T] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  Type.of[T] match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case '[String] =&gt; '{ "" }
</span><span line-number="4" class=""><span class="tooltip-container"></span>    case '[List[t]] =&gt; '{ List.empty[t] }
</span><span line-number="5" class=""><span class="tooltip-container"></span>    case '[type t &lt;: Option[Int]; List[t]] =&gt; '{ List.empty[t] }
</span><span line-number="6" class=""><span class="tooltip-container"></span>    ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><code>Type.of[T]</code> is used to summon the given instance of <code>Type[T]</code> in scope, it is equivalent to <code>summon[Type[T]]</code>.</p>
    <p>It is possible to match against a higher-kinded type using appropriate type bounds on type variables.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def empty[K &lt;: AnyKind : Type](using Quotes): Type[?] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  Type.of[K] match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case '[type f[X]; f] =&gt; Type.of[f]
</span><span line-number="4" class=""><span class="tooltip-container"></span>    case '[type f[X &lt;: Int, Y]; f] =&gt; Type.of[f]
</span><span line-number="5" class=""><span class="tooltip-container"></span>    case '[type k &lt;: AnyKind; k ] =&gt; Type.of[k]
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="type-testing-and-casting-1">
    <h4 class="h300"><a href="#type-testing-and-casting-1" class="anchor"></a>Type testing and casting</h4>
    <p>It is important to note that instance checks and casts on <code>Expr</code>, such as <code>isInstanceOf[Expr[T]]</code> and <code>asInstanceOf[Expr[T]]</code>, will only check if the instance is of the class <code>Expr</code> but will not be able to check the <code>T</code> argument. These cases will issue a warning at compile-time, but if they are ignored, they can result in unexpected behavior.</p>
    <p>These operations can be supported correctly in the system. For a simple type test it is possible to use the <code>isExprOf[T]</code> method of <code>Expr</code> to check if it is an instance of that type. Similarly, it is possible to use <code>asExprOf[T]</code> to cast an expression to a given type. These operations use a given <code>Type[T]</code> to work around type erasure.</p>
   </section>
   <section id="sub-expression-transformation-1">
    <h2 class="h500"><a href="#sub-expression-transformation-1" class="anchor"></a>Sub-Expression Transformation</h2>
    <p>The system provides a mechanism to transform all sub-expressions of an expression. This is useful when the sub-expressions we want to transform are deep in the expression. It is also necessary if the expression contains sub-expressions that cannot be matched using quoted patterns (such as local class definitions).</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait ExprMap:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def transform[T](e: Expr[T])(using Type[T])(using Quotes): Expr[T]
</span><span line-number="3" class=""><span class="tooltip-container"></span>  def transformChildren[T](e: Expr[T])(using Type[T])(using Quotes): Expr[T] =
</span><span line-number="4" class=""><span class="tooltip-container"></span>    ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Users can extend the <code>ExprMap</code> trait and implement the <code>transform</code> method. This interface is flexible and can implement top-down, bottom-up, or other transformations.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>object OptimizeIdentity extends ExprMap:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def transform[T](e: Expr[T])(using Type[T])(using Quotes): Expr[T] =
</span><span line-number="3" class=""><span class="tooltip-container"></span>    transformChildren(e) match // bottom-up transformation
</span><span line-number="4" class=""><span class="tooltip-container"></span>      case '{ identity($x) } =&gt; x
</span><span line-number="5" class=""><span class="tooltip-container"></span>      case _ =&gt; e
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The <code>transformChildren</code> method is implemented as a primitive that knows how to reach all the direct sub-expressions and calls <code>transform</code> on each one. The type passed to <code>transform</code> is the expected type of this sub-expression in its expression. For example while transforming <code>Some(1)</code> in <code>'{ val x: Option[Int] = Some(1); ...}</code> the type will be <code>Option[Int]</code> and not <code>Some[Int]</code>. This implies that we can safely transform <code>Some(1)</code> into <code>None</code>.</p>
   </section>
   <section id="staged-implicit-summoning-1">
    <h2 class="h500"><a href="#staged-implicit-summoning-1" class="anchor"></a>Staged Implicit Summoning</h2>
    <p>When summoning implicit arguments using <code>summon</code>, we will find the given instances in the current scope. It is possible to use <code>summon</code> to get staged implicit arguments by explicitly staging them first. In the following example, we can pass an implicit <code>Ordering[T]</code> in a macro as an <code>Expr[Ordering[T]]</code> to its implementation. Then we can splice it and give it implicitly in the next stage.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>inline def treeSetFor[T](using ord: Ordering[T]): Set[T] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  ${ setExpr[T](using 'ord) }
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>def setExpr[T:Type](using ord: Expr[Ordering[T]])(using Quotes): Expr[Set[T]] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  '{ given Ordering[T] = $ord; new TreeSet[T]() }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>We pass it as an implicit <code>Expr[Ordering[T]]</code> because there might be intermediate methods that can pass it along implicitly.</p>
    <p>An alternative is to summon implicit values in the scope where the macro is invoked. Using the <code>Expr.summon</code> method we get an optional expression containing the implicit instance. This provides the ability to search for implicit instances conditionally.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def summon[T: Type](using Quotes): Option[Expr[T]]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>inline def setFor[T]: Set[T] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  ${ setForExpr[T] }
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>def setForExpr[T: Type]()(using Quotes): Expr[Set[T]] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  Expr.summon[Ordering[T]] match
</span><span line-number="6" class=""><span class="tooltip-container"></span>    case Some(ord) =&gt;
</span><span line-number="7" class=""><span class="tooltip-container"></span>      '{ new TreeSet[T]()($ord) }
</span><span line-number="8" class=""><span class="tooltip-container"></span>    case _ =&gt;
</span><span line-number="9" class=""><span class="tooltip-container"></span>      '{ new HashSet[T] }
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="more-details-1">
    <h2 class="h500"><a href="#more-details-1" class="anchor"></a>More details</h2>
    <ul>
     <li><a href="macros-spec.html">Specification</a></li>
     <li>Scalable Metaprogramming in Scala 3[^1]</li>
    </ul>
    <p>[^1]: <a href="https://infoscience.epfl.ch/record/299370">Scalable Metaprogramming in Scala 3</a> [^2]: <a href="https://dl.acm.org/doi/10.1145/3426426.3428486">Semantics-preserving inlining for metaprogramming</a> [^3]: Implemented in the Scala 3 Dotty project <a href="https://github.com/lampepfl/dotty">https://github.com/lampepfl/dotty</a>. sbt library dependency <code>"org.scala-lang" %% "scala3-staging" % scalaVersion.value</code> [^4]: Using the <code>-Xcheck-macros</code> compiler flag</p>
   </section>
  </main>
  <div class="divider"></div>
  <nav class="arrow-navigation" aria-label="Page navigation">
   <div>
    <span class="body-small">Previous</span> <a rel="prev" href="compiletime-ops.html" aria-keyshortcuts="Left" class="body-medium"> <span class="body-medium">Compile-time operations</span> </a>
   </div>
   <div>
    <span class="body-small">Next</span> <a rel="next" href="staging.html" aria-keyshortcuts="Right" class="body-medium"> <span class="body-medium">Run-Time Multi-Stage Programming</span> </a>
   </div>
  </nav>
 </div>
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#multi-staging-1">Multi-Staging</a><ul><li><ul><li><a href="#quoted-expressions-1">Quoted expressions</a></li><li><a href="#abstract-types-1">Abstract types</a></li><li><a href="#quote-context-1">Quote context</a></li></ul></li></ul></li><li><a href="#quoted-values-1">Quoted Values</a><ul><li><ul><li><a href="#lifting-1">Lifting</a></li><li><a href="#extracting-values-from-quotes-1">Extracting values from quotes</a></li></ul></li></ul></li><li><a href="#macros-and-multi-stage-programming-1">Macros and Multi-Stage Programming</a><ul><li><a href="#multi-stage-macros-1">Multi-Stage Macros</a><ul><li><a href="#macros-2">Macros</a></li><li><a href="#inline-macros-1">Inline macros</a></li><li><a href="#avoiding-a-complete-interpreter-1">Avoiding a complete interpreter</a></li><li><a href="#compilation-stages-1">Compilation stages</a></li></ul></li><li><a href="#run-time-multi-stage-programming-2">Run-Time Multi-Stage Programming</a></li></ul></li><li><a href="#safety-1">Safety</a><ul><li><a href="#static-safety-1">Static Safety</a><ul><li><a href="#hygiene-1">Hygiene</a></li><li><a href="#well-typed-1">Well-typed</a></li></ul></li><li><a href="#cross-stage-safety-1">Cross-Stage Safety</a><ul><li><a href="#level-consistency-1">Level consistency</a></li><li><a href="#type-consistency-1">Type consistency</a></li><li><a href="#scope-extrusion-1">Scope extrusion</a></li></ul></li></ul></li><li><a href="#staged-lambdas-1">Staged Lambdas</a></li><li><a href="#staged-constructors-1">Staged Constructors</a></li><li><a href="#staged-classes-1">Staged Classes</a></li><li><a href="#quote-pattern-matching-2">Quote Pattern Matching</a><ul><li><ul><li><a href="#sub-patterns-1">Sub-patterns</a></li><li><a href="#closed-patterns-1">Closed patterns</a></li><li><a href="#hoas-patterns-1">HOAS patterns</a></li><li><a href="#type-variables-1">Type variables</a></li><li><a href="#type-patterns-1">Type patterns</a></li><li><a href="#type-testing-and-casting-1">Type testing and casting</a></li></ul></li></ul></li><li><a href="#sub-expression-transformation-1">Sub-Expression Transformation</a></li><li><a href="#staged-implicit-summoning-1">Staged Implicit Summoning</a></li><li><a href="#more-details-1">More details</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2024, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2024, LAMP/EPFL</div></div></div></div></body></html>