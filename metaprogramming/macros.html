<html data-githubContributorsUrl="https://api.github.com/repos/lampepfl/dotty" data-githubContributorsFilename="docs/_docs/reference/metaprogramming/macros.md" data-pathToRoot="../"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Macros</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><link rel="stylesheet" href="../css/color-brewer.css"></link><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><link rel="dns-prefetch" href="//fonts.googleapis.com"> 
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.2.1</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../index.html">Docs</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni n1 "><span class="nh de"><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni n1 "><span class="nh de"><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>Metaprogramming</span></a></span><div class="ni n1 "><span class="nh de"><a href="inline.html"><span>Inline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n1 expanded"><span class="nh h100 selected de"><a href="#"><span>Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="staging.html"><span>Runtime Multi-Stage Programming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="reflection.html"><span>Reflection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-checking.html"><span>Changes in Type Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../experimental/index.html"><span>Experimental</span></a></span><div class="ni n1 "><span class="nh de"><a href="../experimental/canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/cc.html"><span>Capture Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/tupled-function.html"><span>Tupled Function</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">© 2002-2021 · LAMP/EPFL</div></div><div class="text-mobile">© 2002-2021 · LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Metaprogramming</a>/<a href="macros.html">Macros</a></div><div id="content" class="body-medium"><div><div id="content-wrapper"> 
 <div class="site-container"> 
  <div id="site-header"></div> 
  <main> 
   <header> <a class="text-button with-link body-small" href="https://github.com/lampepfl/dotty/edit/language-reference-stable/docs/_docs/reference/metaprogramming/macros.md">Edit this page on GitHub</a> 
    <h1 class="h600">Macros</h1> 
   </header> 
   <blockquote> 
    <p>When developing macros enable <code>-Xcheck-macros</code> scalac option flag to have extra runtime checks.</p> 
   </blockquote> 
   <section id="macros-quotes-and-splices"> 
    <h2 class="h500"><a href="#macros-quotes-and-splices" class="anchor"></a>Macros: Quotes and Splices</h2> 
    <p>Macros are built on two well-known fundamental operations: quotation and splicing. Quotation is expressed as <code>'{...}</code> for expressions and splicing is expressed as <code>${ ... }</code>. Additionally, within a quote or a splice we can quote or splice identifiers directly (i.e. <code>'e</code> and <code>$e</code>). Readers may notice the resemblance of the two aforementioned syntactic schemes with the familiar string interpolation syntax.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>println(s"Hello, $name, here is the result of 1 + 1 = ${1 + 1}")
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>In string interpolation we <em>quoted</em> a string and then we <em>spliced</em> into it, two others. The first, <code>name</code>, is a reference to a value of type <a href="https://scala-lang.org/api/3.x/scala/Predef$.html#String-0"><code>String</code></a>, and the second is an arithmetic expression that will be <em>evaluated</em> followed by the splicing of its string representation.</p> 
    <p>Quotes and splices in this section allow us to treat code in a similar way, effectively supporting macros. The entry point for macros is an inline method with a top-level splice. We call it a top-level because it is the only occasion where we encounter a splice outside a quote (consider as a quote the compilation-unit at the call-site). For example, the code below presents an <code>inline</code> method <code>assert</code> which calls at compile-time a method <code>assertImpl</code> with a boolean expression tree as argument. <code>assertImpl</code> evaluates the expression and prints it again in an error message if it evaluates to <code>false</code>.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.quoted.*
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>inline def assert(inline expr: Boolean): Unit =
</span><span line-number="4" class=""><span class="tooltip-container"></span>  ${ assertImpl('expr) }
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>def assertImpl(expr: Expr[Boolean])(using Quotes) = '{
</span><span line-number="7" class=""><span class="tooltip-container"></span>  if !$expr then
</span><span line-number="8" class=""><span class="tooltip-container"></span>    throw AssertionError(s"failed assertion: ${${ showExpr(expr) }}")
</span><span line-number="9" class=""><span class="tooltip-container"></span>}
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>def showExpr(expr: Expr[Boolean])(using Quotes): Expr[String] =
</span><span line-number="12" class=""><span class="tooltip-container"></span>  '{ [actual implementation later in this document] }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>If <code>e</code> is an expression, then <code>'{e}</code> represents the typed abstract syntax tree representing <code>e</code>. If <code>T</code> is a type, then <code>Type.of[T]</code> represents the type structure representing <code>T</code>. The precise definitions of "typed abstract syntax tree" or "type-structure" do not matter for now, the terms are used only to give some intuition. Conversely, <code>${e}</code> evaluates the expression <code>e</code>, which must yield a typed abstract syntax tree or type structure, and embeds the result as an expression (respectively, type) in the enclosing program.</p> 
    <p>Quotations can have spliced parts in them; in this case the embedded splices are evaluated and embedded as part of the formation of the quotation.</p> 
    <p>Quotes and splices can also be applied directly to identifiers. An identifier <code>$x</code> starting with a <code>$</code> that appears inside a quoted expression or type is treated as a splice <code>${x}</code>. Analogously, an quoted identifier <code>'x</code> that appears inside a splice is treated as a quote <code>'{x}</code>. See the Syntax section below for details.</p> 
    <p>Quotes and splices are duals of each other. For arbitrary expressions <code>e</code> we have:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>${'{e}} = e
</span><span line-number="2" class=""><span class="tooltip-container"></span>'{${e}} = e
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="types-for-quotations"> 
    <h2 class="h500"><a href="#types-for-quotations" class="anchor"></a>Types for Quotations</h2> 
    <p>The type signatures of quotes and splices can be described using two fundamental types:</p> 
    <ul> 
     <li><code>Expr[T]</code>: abstract syntax trees representing expressions of type <code>T</code></li> 
     <li><code>Type[T]</code>: non erased representation of type <code>T</code>.</li> 
    </ul> 
    <p>Quoting takes expressions of type <code>T</code> to expressions of type <code>Expr[T]</code> and it takes types <code>T</code> to expressions of type <code>Type[T]</code>. Splicing takes expressions of type <code>Expr[T]</code> to expressions of type <code>T</code> and it takes expressions of type <code>Type[T]</code> to types <code>T</code>.</p> 
    <p>The two types can be defined in package <a href="https://scala-lang.org/api/3.x/scala/quoted.html"><code>scala.quoted</code></a> as follows:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>package scala.quoted
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>sealed trait Expr[+T]
</span><span line-number="4" class=""><span class="tooltip-container"></span>sealed trait Type[T]
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Both <code>Expr</code> and <code>Type</code> are abstract and sealed, so all constructors for these types are provided by the system. One way to construct values of these types is by quoting, the other is by type-specific lifting operations that will be discussed later on.</p> 
   </section> 
   <section id="the-phase-consistency-principle"> 
    <h2 class="h500"><a href="#the-phase-consistency-principle" class="anchor"></a>The Phase Consistency Principle</h2> 
    <p>A fundamental <em>phase consistency principle</em> (PCP) regulates accesses to free variables in quoted and spliced code:</p> 
    <ul> 
     <li><em>For any free variable reference <code>x</code>, the number of quoted scopes and the number of spliced scopes between the reference to <code>x</code> and the definition of <code>x</code> must be equal</em>.</li> 
    </ul> 
    <p>Here, <code>this</code>-references count as free variables. On the other hand, we assume that all imports are fully expanded and that <code>_root_</code> is not a free variable. So references to global definitions are allowed everywhere.</p> 
    <p>The phase consistency principle can be motivated as follows: First, suppose the result of a program <code>P</code> is some quoted text <code>'{ ... x ... }</code> that refers to a free variable <code>x</code> in <code>P</code>. This can be represented only by referring to the original variable <code>x</code>. Hence, the result of the program will need to persist the program state itself as one of its parts. We don’t want to do this, hence this situation should be made illegal. Dually, suppose a top-level part of a program is a spliced text <code>${ ... x ... }</code> that refers to a free variable <code>x</code> in <code>P</code>. This would mean that we refer during <em>construction</em> of <code>P</code> to a value that is available only during <em>execution</em> of <code>P</code>. This is of course impossible and therefore needs to be ruled out. Now, the small-step evaluation of a program will reduce quotes and splices in equal measure using the cancellation rules above. But it will neither create nor remove quotes or splices individually. So the PCP ensures that program elaboration will lead to neither of the two unwanted situations described above.</p> 
    <p>In what concerns the range of features it covers, this form of macros introduces a principled metaprogramming framework that is quite close to the MetaML family of languages. One difference is that MetaML does not have an equivalent of the PCP - quoted code in MetaML <em>can</em> access variables in its immediately enclosing environment, with some restrictions and caveats since such accesses involve serialization. However, this does not constitute a fundamental gain in expressiveness.</p> 
   </section> 
   <section id="from-exprs-to-functions-and-back"> 
    <h2 class="h500"><a href="#from-exprs-to-functions-and-back" class="anchor"></a>From <code>Expr</code>s to Functions and Back</h2> 
    <p>It is possible to convert any <code>Expr[T =&gt; R]</code> into <code>Expr[T] =&gt; Expr[R]</code> and back. These conversions can be implemented as follows:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def to[T: Type, R: Type](f: Expr[T] =&gt; Expr[R])(using Quotes): Expr[T =&gt; R] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  '{ (x: T) =&gt; ${ f('x) } }
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>def from[T: Type, R: Type](f: Expr[T =&gt; R])(using Quotes): Expr[T] =&gt; Expr[R] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  (x: Expr[T]) =&gt; '{ $f($x) }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Note how the fundamental phase consistency principle works in two different directions here for <code>f</code> and <code>x</code>. In the method <code>to</code>, the reference to <code>f</code> is legal because it is quoted, then spliced, whereas the reference to <code>x</code> is legal because it is spliced, then quoted.</p> 
    <p>They can be used as follows:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val f1: Expr[Int =&gt; String] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  to((x: Expr[Int]) =&gt; '{ $x.toString }) // '{ (x: Int) =&gt; x.toString }
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>val f2: Expr[Int] =&gt; Expr[String] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  from('{ (x: Int) =&gt; x.toString }) // (x: Expr[Int]) =&gt; '{ ((x: Int) =&gt; x.toString)($x) }
</span><span line-number="6" class=""><span class="tooltip-container"></span>f2('{2}) // '{ ((x: Int) =&gt; x.toString)(2) }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>One limitation of <code>from</code> is that it does not β-reduce when a lambda is called immediately, as evidenced in the code <code>{ ((x: Int) =&gt; x.toString)(2) }</code>. In some cases we want to remove the lambda from the code, for this we provide the method <code>Expr.betaReduce</code> that turns a tree describing a function into a function mapping trees to trees.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>object Expr:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>  def betaReduce[T](expr: Expr[T])(using Quotes): Expr[T]
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p><code>Expr.betaReduce</code> returns an expression that is functionally equivalent to e, however if e is of the form <code>((y1, ..., yn) =&gt; e2)(e1, ..., en)</code> then it optimizes the top most call by returning the result of beta-reducing the application. Otherwise returns expr.</p> 
   </section> 
   <section id="lifting-types"> 
    <h2 class="h500"><a href="#lifting-types" class="anchor"></a>Lifting Types</h2> 
    <p>Types are not directly affected by the phase consistency principle. It is possible to use types defined at any level in any other level. But, if a type is used in a subsequent stage it will need to be lifted to a <code>Type</code>. Indeed, the definition of <code>to</code> above uses <code>T</code> in the next stage, there is a quote but no splice between the parameter binding of <code>T</code> and its usage. But the code can be rewritten by adding an explicit binding of a <code>Type[T]</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def to[T, R](f: Expr[T] =&gt; Expr[R])(using t: Type[T], r: Type[R])(using Quotes): Expr[T =&gt; R] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  '{ (x: t.Underlying) =&gt; ${ f('x) } }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>In this version of <code>to</code>, the type of <code>x</code> is now the result of inserting the type <code>Type[T]</code> and selecting its <code>Underlying</code>.</p> 
    <p>To avoid clutter, the compiler converts any type reference to a type <code>T</code> in subsequent phases to <code>summon[Type[T]].Underlying</code>.</p> 
    <p>And to avoid duplication it does it once per type, and creates an alias for that type at the start of the quote.</p> 
    <p>For instance, the user-level definition of <code>to</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def to[T, R](f: Expr[T] =&gt; Expr[R])(using t: Type[T], r: Type[R])(using Quotes): Expr[T =&gt; R] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  '{ (x: T) =&gt; ${ f('x) } }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>would be rewritten to</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def to[T, R](f: Expr[T] =&gt; Expr[R])(using t: Type[T], r: Type[R])(using Quotes): Expr[T =&gt; R] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  '{
</span><span line-number="3" class=""><span class="tooltip-container"></span>    type T = summon[Type[T]].Underlying
</span><span line-number="4" class=""><span class="tooltip-container"></span>    (x: T) =&gt; ${ f('x) }
</span><span line-number="5" class=""><span class="tooltip-container"></span>  }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>The <code>summon</code> query succeeds because there is a using parameter of type <code>Type[T]</code>, and the reference to that value is phase-correct. If that was not the case, the phase inconsistency for <code>T</code> would be reported as an error.</p> 
   </section> 
   <section id="lifting-expressions"> 
    <h2 class="h500"><a href="#lifting-expressions" class="anchor"></a>Lifting Expressions</h2> 
    <p>Consider the following implementation of a staged interpreter that implements a compiler through staging.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.quoted.*
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>enum Exp:
</span><span line-number="4" class=""><span class="tooltip-container"></span>  case Num(n: Int)
</span><span line-number="5" class=""><span class="tooltip-container"></span>  case Plus(e1: Exp, e2: Exp)
</span><span line-number="6" class=""><span class="tooltip-container"></span>  case Var(x: String)
</span><span line-number="7" class=""><span class="tooltip-container"></span>  case Let(x: String, e: Exp, in: Exp)
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>import Exp.*
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>The interpreted language consists of numbers <code>Num</code>, addition <code>Plus</code>, and variables <code>Var</code> which are bound by <code>Let</code>. Here are two sample expressions in the language:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val exp = Plus(Plus(Num(2), Var("x")), Num(4))
</span><span line-number="2" class=""><span class="tooltip-container"></span>val letExp = Let("x", Num(3), exp)
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Here’s a compiler that maps an expression given in the interpreted language to quoted Scala code of type <code>Expr[Int]</code>. The compiler takes an environment that maps variable names to Scala <code>Expr</code>s.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.quoted.*
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>def compile(e: Exp, env: Map[String, Expr[Int]])(using Quotes): Expr[Int] =
</span><span line-number="4" class=""><span class="tooltip-container"></span>  e match
</span><span line-number="5" class=""><span class="tooltip-container"></span>    case Num(n) =&gt;
</span><span line-number="6" class=""><span class="tooltip-container"></span>      Expr(n)
</span><span line-number="7" class=""><span class="tooltip-container"></span>    case Plus(e1, e2) =&gt;
</span><span line-number="8" class=""><span class="tooltip-container"></span>      '{ ${ compile(e1, env) } + ${ compile(e2, env) } }
</span><span line-number="9" class=""><span class="tooltip-container"></span>    case Var(x) =&gt;
</span><span line-number="10" class=""><span class="tooltip-container"></span>      env(x)
</span><span line-number="11" class=""><span class="tooltip-container"></span>    case Let(x, e, body) =&gt;
</span><span line-number="12" class=""><span class="tooltip-container"></span>      '{ val y = ${ compile(e, env) }; ${ compile(body, env + (x -&gt; 'y)) } }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Running <code>compile(letExp, Map())</code> would yield the following Scala code:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{ val y = 3; (2 + y) + 4 }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>The body of the first clause, <code>case Num(n) =&gt; Expr(n)</code>, looks suspicious. <code>n</code> is declared as an <code>Int</code>, yet it is converted to an <code>Expr[Int]</code> with <code>Expr()</code>. Shouldn’t <code>n</code> be quoted? In fact this would not work since replacing <code>n</code> by <code>'n</code> in the clause would not be phase correct.</p> 
    <p>The <code>Expr.apply</code> method is defined in package <code>quoted</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>package quoted
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>object Expr:
</span><span line-number="4" class=""><span class="tooltip-container"></span>  ...
</span><span line-number="5" class=""><span class="tooltip-container"></span>  def apply[T: ToExpr](x: T)(using Quotes): Expr[T] =
</span><span line-number="6" class=""><span class="tooltip-container"></span>    summon[ToExpr[T]].toExpr(x)
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>This method says that values of types implementing the <code>ToExpr</code> type class can be converted to <code>Expr</code> values using <code>Expr.apply</code>.</p> 
    <p>Scala 3 comes with given instances of <code>ToExpr</code> for several types including <code>Boolean</code>, <code>String</code>, and all primitive number types. For example, <code>Int</code> values can be converted to <code>Expr[Int]</code> values by wrapping the value in a <code>Literal</code> tree node. This makes use of the underlying tree representation in the compiler for efficiency. But the <code>ToExpr</code> instances are nevertheless not <em>magic</em> in the sense that they could all be defined in a user program without knowing anything about the representation of <code>Expr</code> trees. For instance, here is a possible instance of <code>ToExpr[Boolean]</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given ToExpr[Boolean] with
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def toExpr(b: Boolean) =
</span><span line-number="3" class=""><span class="tooltip-container"></span>    if b then '{ true } else '{ false }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Once we can lift bits, we can work our way up. For instance, here is a possible implementation of <code>ToExpr[Int]</code> that does not use the underlying tree machinery:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given ToExpr[Int] with
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def toExpr(n: Int) = n match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case Int.MinValue    =&gt; '{ Int.MinValue }
</span><span line-number="4" class=""><span class="tooltip-container"></span>    case _ if n &lt; 0      =&gt; '{ - ${ toExpr(-n) } }
</span><span line-number="5" class=""><span class="tooltip-container"></span>    case 0               =&gt; '{ 0 }
</span><span line-number="6" class=""><span class="tooltip-container"></span>    case _ if n % 2 == 0 =&gt; '{ ${ toExpr(n / 2) } * 2 }
</span><span line-number="7" class=""><span class="tooltip-container"></span>    case _               =&gt; '{ ${ toExpr(n / 2) } * 2 + 1 }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Since <code>ToExpr</code> is a type class, its instances can be conditional. For example, a <code>List</code> is liftable if its element type is:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given [T: ToExpr : Type]: ToExpr[List[T]] with
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def toExpr(xs: List[T]) = xs match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case head :: tail =&gt; '{ ${ Expr(head) } :: ${ toExpr(tail) } }
</span><span line-number="4" class=""><span class="tooltip-container"></span>    case Nil          =&gt; '{ Nil: List[T] }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>In the end, <code>ToExpr</code> resembles very much a serialization framework. Like the latter it can be derived systematically for all collections, case classes and enums. Note also that the synthesis of <em>type-tag</em> values of type <code>Type[T]</code> is essentially the type-level analogue of lifting.</p> 
    <p>Using lifting, we can now give the missing definition of <code>showExpr</code> in the introductory example:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def showExpr[T](expr: Expr[T])(using Quotes): Expr[String] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val code: String = expr.show
</span><span line-number="3" class=""><span class="tooltip-container"></span>  Expr(code)
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>That is, the <code>showExpr</code> method converts its <code>Expr</code> argument to a string (<code>code</code>), and lifts the result back to an <code>Expr[String]</code> using <code>Expr.apply</code>.</p> 
   </section> 
   <section id="lifting-types1"> 
    <h2 class="h500"><a href="#lifting-types1" class="anchor"></a>Lifting Types</h2> 
    <p>The previous section has shown that the metaprogramming framework has to be able to take a type <code>T</code> and convert it to a type tree of type <code>Type[T]</code> that can be reified. This means that all free variables of the type tree refer to types and values defined in the current stage.</p> 
    <p>For a reference to a global class, this is easy: Just issue the fully qualified name of the class. Members of reifiable types are handled by just reifying the containing type together with the member name. But what to do for references to type parameters or local type definitions that are not defined in the current stage? Here, we cannot construct the <code>Type[T]</code> tree directly, so we need to get it from a recursive implicit search. For instance, to implement</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>summon[Type[List[T]]]
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>where <code>T</code> is not defined in the current stage, we construct the type constructor of <code>List</code> applied to the splice of the result of searching for a given instance for <code>Type[T]</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>Type.of[ List[ summon[Type[T]].Underlying ] ]
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>This is exactly the algorithm that Scala 2 uses to search for type tags. In fact Scala 2's type tag feature can be understood as a more ad-hoc version of <code>quoted.Type</code>. As was the case for type tags, the implicit search for a <code>quoted.Type</code> is handled by the compiler, using the algorithm sketched above.</p> 
   </section> 
   <section id="relationship-with-inline"> 
    <h2 class="h500"><a href="#relationship-with-inline" class="anchor"></a>Relationship with <code>inline</code></h2> 
    <p>Seen by itself, principled metaprogramming looks more like a framework for runtime metaprogramming than one for compile-time metaprogramming with macros. But combined with Scala 3’s <code>inline</code> feature it can be turned into a compile-time system. The idea is that macro elaboration can be understood as a combination of a macro library and a quoted program. For instance, here’s the <code>assert</code> macro again together with a program that calls <code>assert</code>.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>object Macros:
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  inline def assert(inline expr: Boolean): Unit =
</span><span line-number="4" class=""><span class="tooltip-container"></span>    ${ assertImpl('expr) }
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  def assertImpl(expr: Expr[Boolean])(using Quotes) =
</span><span line-number="7" class=""><span class="tooltip-container"></span>    val failMsg: Expr[String] = Expr("failed assertion: " + expr.show)
</span><span line-number="8" class=""><span class="tooltip-container"></span>    '{ if !($expr) then throw new AssertionError($failMsg) }
</span><span line-number="9" class=""><span class="tooltip-container"></span>
</span><span line-number="10" class=""><span class="tooltip-container"></span>@main def program =
</span><span line-number="11" class=""><span class="tooltip-container"></span>  val x = 1
</span><span line-number="12" class=""><span class="tooltip-container"></span>  Macros.assert(x != 0)
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Inlining the <code>assert</code> function would give the following program:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>@main def program =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val x = 1
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${ Macros.assertImpl('{ x != 0}) }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>The example is only phase correct because <code>Macros</code> is a global value and as such not subject to phase consistency checking. Conceptually that’s a bit unsatisfactory. If the PCP is so fundamental, it should be applicable without the global value exception. But in the example as given this does not hold since both <code>assert</code> and <code>program</code> call <code>assertImpl</code> with a splice but no quote.</p> 
    <p>However, one could argue that the example is really missing an important aspect: The macro library has to be compiled in a phase prior to the program using it, but in the code above, macro and program are defined together. A more accurate view of macros would be to have the user program be in a phase after the macro definitions, reflecting the fact that macros have to be defined and compiled before they are used. Hence, conceptually the program part should be treated by the compiler as if it was quoted:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>@main def program = '{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val x = 1
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${ Macros.assertImpl('{ x != 0 }) }
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>If <code>program</code> is treated as a quoted expression, the call to <code>Macro.assertImpl</code> becomes phase correct even if macro library and program are conceptualized as local definitions.</p> 
    <p>But what about the call from <code>assert</code> to <code>assertImpl</code>? Here, we need a tweak of the typing rules. An inline function such as <code>assert</code> that contains a splice operation outside an enclosing quote is called a <em>macro</em>. Macros are supposed to be expanded in a subsequent phase, i.e. in a quoted context. Therefore, they are also type checked as if they were in a quoted context. For instance, the definition of <code>assert</code> is typechecked as if it appeared inside quotes. This makes the call from <code>assert</code> to <code>assertImpl</code> phase-correct, even if we assume that both definitions are local.</p> 
    <p>The <code>inline</code> modifier is used to declare a <code>val</code> that is either a constant or is a parameter that will be a constant when instantiated. This aspect is also important for macro expansion.</p> 
    <p>To get values out of expressions containing constants <code>Expr</code> provides the method <code>value</code> (or <code>valueOrError</code>). This will convert the <code>Expr[T]</code> into a <code>Some[T]</code> (or <code>T</code>) when the expression contains value. Otherwise it will return <code>None</code> (or emit an error). To avoid having incidental val bindings generated by the inlining of the <code>def</code> it is recommended to use an inline parameter. To illustrate this, consider an implementation of the <code>power</code> function that makes use of a statically known exponent:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>inline def power(x: Double, inline n: Int) = ${ powerCode('x, 'n) }
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>private def powerCode(x: Expr[Double], n: Expr[Int])(using Quotes): Expr[Double] =
</span><span line-number="4" class=""><span class="tooltip-container"></span>  n.value match
</span><span line-number="5" class=""><span class="tooltip-container"></span>    case Some(m) =&gt; powerCode(x, m)
</span><span line-number="6" class=""><span class="tooltip-container"></span>    case None =&gt; '{ Math.pow($x, $n.toDouble) }
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>private def powerCode(x: Expr[Double], n: Int)(using Quotes): Expr[Double] =
</span><span line-number="9" class=""><span class="tooltip-container"></span>  if n == 0 then '{ 1.0 }
</span><span line-number="10" class=""><span class="tooltip-container"></span>  else if n == 1 then x
</span><span line-number="11" class=""><span class="tooltip-container"></span>  else if n % 2 == 0 then '{ val y = $x * $x; ${ powerCode('y, n / 2) } }
</span><span line-number="12" class=""><span class="tooltip-container"></span>  else '{ $x * ${ powerCode(x, n - 1) } }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="scope-extrusion"> 
    <h2 class="h500"><a href="#scope-extrusion" class="anchor"></a>Scope Extrusion</h2> 
    <p>Quotes and splices are duals as far as the PCP is concerned. But there is an additional restriction that needs to be imposed on splices to guarantee soundness: code in splices must be free of side effects. The restriction prevents code like this:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>var x: Expr[T] = ...
</span><span line-number="2" class=""><span class="tooltip-container"></span>'{ (y: T) =&gt; ${ x = 'y; 1 } }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>This code, if it was accepted, would <em>extrude</em> a reference to a quoted variable <code>y</code> from its scope. This would subsequently allow access to a variable outside the scope where it is defined, which is likely problematic. The code is clearly phase consistent, so we cannot use PCP to rule it out. Instead, we postulate a future effect system that can guarantee that splices are pure. In the absence of such a system we simply demand that spliced expressions are pure by convention, and allow for undefined compiler behavior if they are not. This is analogous to the status of pattern guards in Scala, which are also required, but not verified, to be pure.</p> 
    <p><a href="staging.html">Multi-Stage Programming</a> introduces one additional method where you can expand code at runtime with a method <code>run</code>. There is also a problem with that invocation of <code>run</code> in splices. Consider the following expression:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{ (x: Int) =&gt; ${ run('x); 1 } }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>This is again phase correct, but will lead us into trouble. Indeed, evaluating the splice will reduce the expression <code>run('x)</code> to <code>x</code>. But then the result</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{ (x: Int) =&gt; ${ x; 1 } }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>is no longer phase correct. To prevent this soundness hole it seems easiest to classify <code>run</code> as a side-effecting operation. It would thus be prevented from appearing in splices. In a base language with side effects we would have to do this anyway: Since <code>run</code> runs arbitrary code it can always produce a side effect if the code it runs produces one.</p> 
   </section> 
   <section id="example-expansion"> 
    <h2 class="h500"><a href="#example-expansion" class="anchor"></a>Example Expansion</h2> 
    <p>Assume we have two methods, <code>map</code> that takes an <code>Expr[Array[T]]</code> and a function <code>f</code>, and <code>sum</code> that performs a sum by delegating to <code>map</code>.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>object Macros:
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  def map[T](arr: Expr[Array[T]], f: Expr[T] =&gt; Expr[Unit])
</span><span line-number="4" class=""><span class="tooltip-container"></span>            (using Type[T], Quotes): Expr[Unit] = '{
</span><span line-number="5" class=""><span class="tooltip-container"></span>    var i: Int = 0
</span><span line-number="6" class=""><span class="tooltip-container"></span>    while i &lt; ($arr).length do
</span><span line-number="7" class=""><span class="tooltip-container"></span>      val element: T = ($arr)(i)
</span><span line-number="8" class=""><span class="tooltip-container"></span>      ${f('element)}
</span><span line-number="9" class=""><span class="tooltip-container"></span>      i += 1
</span><span line-number="10" class=""><span class="tooltip-container"></span>  }
</span><span line-number="11" class=""><span class="tooltip-container"></span>
</span><span line-number="12" class=""><span class="tooltip-container"></span>  def sum(arr: Expr[Array[Int]])(using Quotes): Expr[Int] = '{
</span><span line-number="13" class=""><span class="tooltip-container"></span>    var sum = 0
</span><span line-number="14" class=""><span class="tooltip-container"></span>    ${ map(arr, x =&gt; '{sum += $x}) }
</span><span line-number="15" class=""><span class="tooltip-container"></span>    sum
</span><span line-number="16" class=""><span class="tooltip-container"></span>  }
</span><span line-number="17" class=""><span class="tooltip-container"></span>
</span><span line-number="18" class=""><span class="tooltip-container"></span>  inline def sum_m(arr: Array[Int]): Int = ${sum('arr)}
</span><span line-number="19" class=""><span class="tooltip-container"></span>
</span><span line-number="20" class=""><span class="tooltip-container"></span>end Macros
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>A call to <code>sum_m(Array(1, 2, 3))</code> will first inline <code>sum_m</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val arr: Array[Int] = Array.apply(1, 2, 3)
</span><span line-number="2" class=""><span class="tooltip-container"></span>${ _root_.Macros.sum('arr) }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>then it will call <code>sum</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val arr: Array[Int] = Array.apply(1, 2, 3)
</span><span line-number="2" class=""><span class="tooltip-container"></span>${ '{
</span><span line-number="3" class=""><span class="tooltip-container"></span>  var sum = 0
</span><span line-number="4" class=""><span class="tooltip-container"></span>  ${ map('arr, x =&gt; '{sum += $x}) }
</span><span line-number="5" class=""><span class="tooltip-container"></span>  sum
</span><span line-number="6" class=""><span class="tooltip-container"></span>} }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>and cancel the <code>${'{...}}</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val arr: Array[Int] = Array.apply(1, 2, 3)
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>var sum = 0
</span><span line-number="4" class=""><span class="tooltip-container"></span>${ map('arr, x =&gt; '{sum += $x}) }
</span><span line-number="5" class=""><span class="tooltip-container"></span>sum
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>then it will extract <code>x =&gt; '{sum += $x}</code> into <code>f</code>, to have a value:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val arr: Array[Int] = Array.apply(1, 2, 3)
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>var sum = 0
</span><span line-number="4" class=""><span class="tooltip-container"></span>val f = x =&gt; '{sum += $x}
</span><span line-number="5" class=""><span class="tooltip-container"></span>${ _root_.Macros.map('arr, 'f)(Type.of[Int]) }
</span><span line-number="6" class=""><span class="tooltip-container"></span>sum
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>and then call <code>map</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val arr: Array[Int] = Array.apply(1, 2, 3)
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>var sum = 0
</span><span line-number="4" class=""><span class="tooltip-container"></span>val f = x =&gt; '{sum += $x}
</span><span line-number="5" class=""><span class="tooltip-container"></span>${ '{
</span><span line-number="6" class=""><span class="tooltip-container"></span>  var i: Int = 0
</span><span line-number="7" class=""><span class="tooltip-container"></span>  while i &lt; arr.length do
</span><span line-number="8" class=""><span class="tooltip-container"></span>    val element: Int = (arr)(i)
</span><span line-number="9" class=""><span class="tooltip-container"></span>    sum += element
</span><span line-number="10" class=""><span class="tooltip-container"></span>    i += 1
</span><span line-number="11" class=""><span class="tooltip-container"></span>  sum
</span><span line-number="12" class=""><span class="tooltip-container"></span>} }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>and cancel the <code>${'{...}}</code> again:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val arr: Array[Int] = Array.apply(1, 2, 3)
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>var sum = 0
</span><span line-number="4" class=""><span class="tooltip-container"></span>val f = x =&gt; '{sum += $x}
</span><span line-number="5" class=""><span class="tooltip-container"></span>var i: Int = 0
</span><span line-number="6" class=""><span class="tooltip-container"></span>while i &lt; arr.length do
</span><span line-number="7" class=""><span class="tooltip-container"></span>  val element: Int = (arr)(i)
</span><span line-number="8" class=""><span class="tooltip-container"></span>  sum += element
</span><span line-number="9" class=""><span class="tooltip-container"></span>  i += 1
</span><span line-number="10" class=""><span class="tooltip-container"></span>sum
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Finally cleanups and dead code elimination:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val arr: Array[Int] = Array.apply(1, 2, 3)
</span><span line-number="2" class=""><span class="tooltip-container"></span>var sum = 0
</span><span line-number="3" class=""><span class="tooltip-container"></span>var i: Int = 0
</span><span line-number="4" class=""><span class="tooltip-container"></span>while i &lt; arr.length do
</span><span line-number="5" class=""><span class="tooltip-container"></span>  val element: Int = arr(i)
</span><span line-number="6" class=""><span class="tooltip-container"></span>  sum += element
</span><span line-number="7" class=""><span class="tooltip-container"></span>  i += 1
</span><span line-number="8" class=""><span class="tooltip-container"></span>sum
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="find-implicits-within-a-macro"> 
    <h2 class="h500"><a href="#find-implicits-within-a-macro" class="anchor"></a>Find implicits within a macro</h2> 
    <p>Similarly to the <code>summonFrom</code> construct, it is possible to make implicit search available in a quote context. For this we simply provide <code>scala.quoted.Expr.summon</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.collection.immutable.{ TreeSet, HashSet }
</span><span line-number="2" class=""><span class="tooltip-container"></span>inline def setFor[T]: Set[T] = ${ setForExpr[T] }
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>def setForExpr[T: Type](using Quotes): Expr[Set[T]] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  Expr.summon[Ordering[T]] match
</span><span line-number="6" class=""><span class="tooltip-container"></span>    case Some(ord) =&gt; '{ new TreeSet[T]()($ord) }
</span><span line-number="7" class=""><span class="tooltip-container"></span>    case _ =&gt; '{ new HashSet[T] }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="relationship-with-transparent-inline"> 
    <h2 class="h500"><a href="#relationship-with-transparent-inline" class="anchor"></a>Relationship with Transparent Inline</h2> 
    <p><a href="inline.html">Inline</a> documents inlining. The code below introduces a transparent inline method that can calculate either a value of type <code>Int</code> or a value of type <code>String</code>.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>transparent inline def defaultOf(inline str: String) =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  ${ defaultOfImpl('str) }
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>def defaultOfImpl(strExpr: Expr[String])(using Quotes): Expr[Any] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  strExpr.valueOrError match
</span><span line-number="6" class=""><span class="tooltip-container"></span>    case "int" =&gt; '{1}
</span><span line-number="7" class=""><span class="tooltip-container"></span>    case "string" =&gt; '{"a"}
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>// in a separate file
</span><span line-number="10" class=""><span class="tooltip-container"></span>val a: Int = defaultOf("int")
</span><span line-number="11" class=""><span class="tooltip-container"></span>val b: String = defaultOf("string")
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="defining-a-macro-and-using-it-in-a-single-project"> 
    <h2 class="h500"><a href="#defining-a-macro-and-using-it-in-a-single-project" class="anchor"></a>Defining a macro and using it in a single project</h2> 
    <p>It is possible to define macros and use them in the same project as long as the implementation of the macros does not have run-time dependencies on code in the file where it is used. It might still have compile-time dependencies on types and quoted code that refers to the use-site file.</p> 
    <p>To provide this functionality Scala 3 provides a transparent compilation mode where files that try to expand a macro but fail because the macro has not been compiled yet are suspended. If there are any suspended files when the compilation ends, the compiler will automatically restart compilation of the suspended files using the output of the previous (partial) compilation as macro classpath. In case all files are suspended due to cyclic dependencies the compilation will fail with an error.</p> 
   </section> 
   <section id="pattern-matching-on-quoted-expressions"> 
    <h2 class="h500"><a href="#pattern-matching-on-quoted-expressions" class="anchor"></a>Pattern matching on quoted expressions</h2> 
    <p>It is possible to deconstruct or extract values out of <code>Expr</code> using pattern matching.</p> 
    <p><code>scala.quoted</code> contains objects that can help extracting values from <code>Expr</code>.</p> 
    <ul> 
     <li><code>scala.quoted.Expr</code>/<code>scala.quoted.Exprs</code>: matches an expression of a value (resp. list of values) and returns the value (resp. list of values).</li> 
     <li><code>scala.quoted.Const</code>/<code>scala.quoted.Consts</code>: Same as <code>Expr</code>/<code>Exprs</code> but only works on primitive values.</li> 
     <li><code>scala.quoted.Varargs</code>: matches an explicit sequence of expressions and returns them. These sequences are useful to get individual <code>Expr[T]</code> out of a varargs expression of type <code>Expr[Seq[T]]</code>.</li> 
    </ul> 
    <p>These could be used in the following way to optimize any call to <code>sum</code> that has statically known values.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>inline def sum(inline args: Int*): Int = ${ sumExpr('args) }
</span><span line-number="2" class=""><span class="tooltip-container"></span>private def sumExpr(argsExpr: Expr[Seq[Int]])(using Quotes): Expr[Int] =
</span><span line-number="3" class=""><span class="tooltip-container"></span>  argsExpr match
</span><span line-number="4" class=""><span class="tooltip-container"></span>    case Varargs(args @ Exprs(argValues)) =&gt;
</span><span line-number="5" class=""><span class="tooltip-container"></span>      // args is of type Seq[Expr[Int]]
</span><span line-number="6" class=""><span class="tooltip-container"></span>      // argValues is of type Seq[Int]
</span><span line-number="7" class=""><span class="tooltip-container"></span>      Expr(argValues.sum) // precompute result of sum
</span><span line-number="8" class=""><span class="tooltip-container"></span>    case Varargs(argExprs) =&gt; // argExprs is of type Seq[Expr[Int]]
</span><span line-number="9" class=""><span class="tooltip-container"></span>      val staticSum: Int = argExprs.map(_.value.getOrElse(0)).sum
</span><span line-number="10" class=""><span class="tooltip-container"></span>      val dynamicSum: Seq[Expr[Int]] = argExprs.filter(_.value.isEmpty)
</span><span line-number="11" class=""><span class="tooltip-container"></span>      dynamicSum.foldLeft(Expr(staticSum))((acc, arg) =&gt; '{ $acc + $arg })
</span><span line-number="12" class=""><span class="tooltip-container"></span>    case _ =&gt;
</span><span line-number="13" class=""><span class="tooltip-container"></span>      '{ $argsExpr.sum }
</span><span line-number="14" class=""><span class="tooltip-container"></span>
</span><span line-number="15" class=""><span class="tooltip-container"></span>sum(1, 2, 3) // gets matched by Varargs
</span><span line-number="16" class=""><span class="tooltip-container"></span>
</span><span line-number="17" class=""><span class="tooltip-container"></span>val xs = List(1, 2, 3)
</span><span line-number="18" class=""><span class="tooltip-container"></span>sum(xs*) // doesn't get matched by Varargs
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="quoted-patterns"> 
    <h3 class="h400"><a href="#quoted-patterns" class="anchor"></a>Quoted patterns</h3> 
    <p>Quoted pattens allow deconstructing complex code that contains a precise structure, types or methods. Patterns <code>'{ ... }</code> can be placed in any location where Scala expects a pattern.</p> 
    <p>For example</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>optimize {
</span><span line-number="2" class=""><span class="tooltip-container"></span>   sum(sum(1, a, 2), 3, b)
</span><span line-number="3" class=""><span class="tooltip-container"></span>} // should be optimized to 6 + a + b
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def sum(args: Int*): Int = args.sum
</span><span line-number="2" class=""><span class="tooltip-container"></span>inline def optimize(inline arg: Int): Int = ${ optimizeExpr('arg) }
</span><span line-number="3" class=""><span class="tooltip-container"></span>private def optimizeExpr(body: Expr[Int])(using Quotes): Expr[Int] =
</span><span line-number="4" class=""><span class="tooltip-container"></span>  body match
</span><span line-number="5" class=""><span class="tooltip-container"></span>    // Match a call to sum without any arguments
</span><span line-number="6" class=""><span class="tooltip-container"></span>    case '{ sum() } =&gt; Expr(0)
</span><span line-number="7" class=""><span class="tooltip-container"></span>    // Match a call to sum with an argument $n of type Int.
</span><span line-number="8" class=""><span class="tooltip-container"></span>    // n will be the Expr[Int] representing the argument.
</span><span line-number="9" class=""><span class="tooltip-container"></span>    case '{ sum($n) } =&gt; n
</span><span line-number="10" class=""><span class="tooltip-container"></span>    // Match a call to sum and extracts all its args in an `Expr[Seq[Int]]`
</span><span line-number="11" class=""><span class="tooltip-container"></span>    case '{ sum(${Varargs(args)}: _*) } =&gt; sumExpr(args)
</span><span line-number="12" class=""><span class="tooltip-container"></span>    case body =&gt; body
</span><span line-number="13" class=""><span class="tooltip-container"></span>
</span><span line-number="14" class=""><span class="tooltip-container"></span>private def sumExpr(args1: Seq[Expr[Int]])(using Quotes): Expr[Int] =
</span><span line-number="15" class=""><span class="tooltip-container"></span>  def flatSumArgs(arg: Expr[Int]): Seq[Expr[Int]] = arg match
</span><span line-number="16" class=""><span class="tooltip-container"></span>    case '{ sum(${Varargs(subArgs)}: _*) } =&gt; subArgs.flatMap(flatSumArgs)
</span><span line-number="17" class=""><span class="tooltip-container"></span>    case arg =&gt; Seq(arg)
</span><span line-number="18" class=""><span class="tooltip-container"></span>  val args2 = args1.flatMap(flatSumArgs)
</span><span line-number="19" class=""><span class="tooltip-container"></span>  val staticSum: Int = args2.map(_.value.getOrElse(0)).sum
</span><span line-number="20" class=""><span class="tooltip-container"></span>  val dynamicSum: Seq[Expr[Int]] = args2.filter(_.value.isEmpty)
</span><span line-number="21" class=""><span class="tooltip-container"></span>  dynamicSum.foldLeft(Expr(staticSum))((acc, arg) =&gt; '{ $acc + $arg })
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="recovering-precise-types-using-patterns"> 
    <h3 class="h400"><a href="#recovering-precise-types-using-patterns" class="anchor"></a>Recovering precise types using patterns</h3> 
    <p>Sometimes it is necessary to get a more precise type for an expression. This can be achieved using the following pattern match.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def f(expr: Expr[Any])(using Quotes) = expr match
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case '{ $x: t } =&gt;
</span><span line-number="3" class=""><span class="tooltip-container"></span>    // If the pattern match succeeds, then there is
</span><span line-number="4" class=""><span class="tooltip-container"></span>    // some type `t` such that
</span><span line-number="5" class=""><span class="tooltip-container"></span>    // - `x` is bound to a variable of type `Expr[t]`
</span><span line-number="6" class=""><span class="tooltip-container"></span>    // - `t` is bound to a new type `t` and a given
</span><span line-number="7" class=""><span class="tooltip-container"></span>    //   instance `Type[t]` is provided for it
</span><span line-number="8" class=""><span class="tooltip-container"></span>    // That is, we have `x: Expr[t]` and `given Type[t]`,
</span><span line-number="9" class=""><span class="tooltip-container"></span>    // for some (unknown) type `t`.
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>This might be used to then perform an implicit search as in:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>extension (inline sc: StringContext)
</span><span line-number="2" class=""><span class="tooltip-container"></span>  inline def showMe(inline args: Any*): String = ${ showMeExpr('sc, 'args) }
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>private def showMeExpr(sc: Expr[StringContext], argsExpr: Expr[Seq[Any]])(using Quotes): Expr[String] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  import quotes.reflect.report
</span><span line-number="6" class=""><span class="tooltip-container"></span>  argsExpr match
</span><span line-number="7" class=""><span class="tooltip-container"></span>    case Varargs(argExprs) =&gt;
</span><span line-number="8" class=""><span class="tooltip-container"></span>      val argShowedExprs = argExprs.map {
</span><span line-number="9" class=""><span class="tooltip-container"></span>        case '{ $arg: tp } =&gt;
</span><span line-number="10" class=""><span class="tooltip-container"></span>          Expr.summon[Show[tp]] match
</span><span line-number="11" class=""><span class="tooltip-container"></span>            case Some(showExpr) =&gt;
</span><span line-number="12" class=""><span class="tooltip-container"></span>              '{ $showExpr.show($arg) }
</span><span line-number="13" class=""><span class="tooltip-container"></span>            case None =&gt;
</span><span line-number="14" class=""><span class="tooltip-container"></span>              report.error(s"could not find implicit for ${Type.show[Show[tp]]}", arg); '{???}
</span><span line-number="15" class=""><span class="tooltip-container"></span>      }
</span><span line-number="16" class=""><span class="tooltip-container"></span>      val newArgsExpr = Varargs(argShowedExprs)
</span><span line-number="17" class=""><span class="tooltip-container"></span>      '{ $sc.s($newArgsExpr: _*) }
</span><span line-number="18" class=""><span class="tooltip-container"></span>    case _ =&gt;
</span><span line-number="19" class=""><span class="tooltip-container"></span>      // `new StringContext(...).showMeExpr(args: _*)` not an explicit `showMeExpr"..."`
</span><span line-number="20" class=""><span class="tooltip-container"></span>      report.error(s"Args must be explicit", argsExpr)
</span><span line-number="21" class=""><span class="tooltip-container"></span>      '{???}
</span><span line-number="22" class=""><span class="tooltip-container"></span>
</span><span line-number="23" class=""><span class="tooltip-container"></span>trait Show[-T]:
</span><span line-number="24" class=""><span class="tooltip-container"></span>  def show(x: T): String
</span><span line-number="25" class=""><span class="tooltip-container"></span>
</span><span line-number="26" class=""><span class="tooltip-container"></span>// in a different file
</span><span line-number="27" class=""><span class="tooltip-container"></span>given Show[Boolean] with
</span><span line-number="28" class=""><span class="tooltip-container"></span>  def show(b: Boolean) = "boolean!"
</span><span line-number="29" class=""><span class="tooltip-container"></span>
</span><span line-number="30" class=""><span class="tooltip-container"></span>println(showMe"${true}")
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="open-code-patterns"> 
    <h3 class="h400"><a href="#open-code-patterns" class="anchor"></a>Open code patterns</h3> 
    <p>Quoted pattern matching also provides higher-order patterns to match open terms. If a quoted term contains a definition, then the rest of the quote can refer to this definition.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val x: Int = 4
</span><span line-number="3" class=""><span class="tooltip-container"></span>  x * x
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>To match such a term we need to match the definition and the rest of the code, but we need to explicitly state that the rest of the code may refer to this definition.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case '{ val y: Int = $x; $body(y): Int } =&gt;
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Here <code>$x</code> will match any closed expression while <code>$body(y)</code> will match an expression that is closed under <code>y</code>. Then the subexpression of type <code>Expr[Int]</code> is bound to <code>body</code> as an <code>Expr[Int =&gt; Int]</code>. The extra argument represents the references to <code>y</code>. Usually this expression is used in combination with <code>Expr.betaReduce</code> to replace the extra argument.</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>inline def eval(inline e: Int): Int = ${ evalExpr('e) }
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>private def evalExpr(e: Expr[Int])(using Quotes): Expr[Int] = e match
</span><span line-number="4" class=""><span class="tooltip-container"></span>  case '{ val y: Int = $x; $body(y): Int } =&gt;
</span><span line-number="5" class=""><span class="tooltip-container"></span>    // body: Expr[Int =&gt; Int] where the argument represents
</span><span line-number="6" class=""><span class="tooltip-container"></span>    // references to y
</span><span line-number="7" class=""><span class="tooltip-container"></span>    evalExpr(Expr.betaReduce('{$body(${evalExpr(x)})}))
</span><span line-number="8" class=""><span class="tooltip-container"></span>  case '{ ($x: Int) * ($y: Int) } =&gt;
</span><span line-number="9" class=""><span class="tooltip-container"></span>    (x.value, y.value) match
</span><span line-number="10" class=""><span class="tooltip-container"></span>      case (Some(a), Some(b)) =&gt; Expr(a * b)
</span><span line-number="11" class=""><span class="tooltip-container"></span>      case _ =&gt; e
</span><span line-number="12" class=""><span class="tooltip-container"></span>  case _ =&gt; e
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>eval { // expands to the code: (16: Int)
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val x: Int = 4
</span><span line-number="3" class=""><span class="tooltip-container"></span>  x * x
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>We can also close over several bindings using <code>$b(a1, a2, ..., an)</code>. To match an actual application we can use braces on the function part <code>${b}(a1, a2, ..., an)</code>.</p> 
   </section> 
   <section id="more-details"> 
    <h2 class="h500"><a href="#more-details" class="anchor"></a>More details</h2> 
    <p><a href="macros-spec.html">More details</a></p> 
   </section> 
  </main> 
  <div class="divider"></div> 
  <nav class="arrow-navigation" aria-label="Page navigation"> 
   <div> <span class="body-small">Previous</span> <a rel="prev" href="compiletime-ops.html" aria-keyshortcuts="Left" class="body-medium"> <span class="body-medium">Compile-time operations</span> </a> 
   </div> 
   <div> <span class="body-small">Next</span> <a rel="next" href="staging.html" aria-keyshortcuts="Right" class="body-medium"> <span class="body-medium">Runtime Multi-Stage Programming</span> </a> 
   </div> 
  </nav> 
 </div> 
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#macros-quotes-and-splices">Macros: Quotes and Splices</a></li><li><a href="#types-for-quotations">Types for Quotations</a></li><li><a href="#the-phase-consistency-principle">The Phase Consistency Principle</a></li><li><a href="#from-exprs-to-functions-and-back">From Exprs to Functions and Back</a></li><li><a href="#lifting-types">Lifting Types</a></li><li><a href="#lifting-expressions">Lifting Expressions</a></li><li><a href="#lifting-types1">Lifting Types</a></li><li><a href="#relationship-with-inline">Relationship with inline</a></li><li><a href="#scope-extrusion">Scope Extrusion</a></li><li><a href="#example-expansion">Example Expansion</a></li><li><a href="#find-implicits-within-a-macro">Find implicits within a macro</a></li><li><a href="#relationship-with-transparent-inline">Relationship with Transparent Inline</a></li><li><a href="#defining-a-macro-and-using-it-in-a-single-project">Defining a macro and using it in a single project</a></li><li><a href="#pattern-matching-on-quoted-expressions">Pattern matching on quoted expressions</a><ul><li><a href="#quoted-patterns">Quoted patterns</a></li><li><a href="#recovering-precise-types-using-patterns">Recovering precise types using patterns</a></li><li><a href="#open-code-patterns">Open code patterns</a></li></ul></li><li><a href="#more-details">More details</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://gitter.im/scala/scala"><button class="icon-button gitter"></button></a><div class="text">© 2002-2021 · LAMP/EPFL</div></div><div class="text-mobile">© 2002-2021 · LAMP/EPFL</div></div></div></div></body></html>