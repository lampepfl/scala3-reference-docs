<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/scala/scala3" data-githubContributorsFilename="docs/_docs/reference/metaprogramming/macros-spec.md" data-pathToRoot="../" data-rawLocation="metaprogramming/macros-spec" data-dynamicSideMenu="false"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Macros Spec</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="/css/dottydoc.css"></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.6.4</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 " href="../index.html">Docs</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni n1 "><span class="nh de"><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni n1 "><span class="nh de"><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/deferred-givens.html"><span>Deferred Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/more-givens.html"><span>Other Forms Of Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/previous-givens.html"><span>Previous Given Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="index.html"><span>Metaprogramming</span></a></span><div class="ni n1 "><span class="nh de"><a href="inline.html"><span>Inline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="macros.html"><span>Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="staging.html"><span>Run-Time Multi-Stage Programming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="reflection.html"><span>Reflection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits and Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/binary-literals.html"><span>Binary Integer Literals</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../experimental/index.html"><span>Experimental</span></a></span><div class="ni n1 "><span class="nh de"><a href="../experimental/canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/cc.html"><span>Capture Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/tupled-function.html"><span>Tupled Function</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Metaprogramming</a>/<a href="macros-spec.html">Macros Spec</a></div><div id="content" class="body-medium"><div><div id="content-wrapper">
 <div class="site-container">
  <div id="site-header"></div>
  <main>
   <header>
    <a class="text-button with-link body-small" href="https://github.com/scala/scala3/edit/language-reference-stable/docs/_docs/reference/metaprogramming/macros-spec.md">Edit this page on GitHub</a>
    <h1 class="h600">Macros Spec</h1>
   </header>
   <section id="formalization-1">
    <h2 class="h500"><a href="#formalization-1" class="anchor"></a>Formalization</h2>
    <ul>
     <li>Multi-stage programming with generative and analytical macros[^2]</li>
     <li>Multi-Stage Macro Calculus, Chapter 4 of Scalable Metaprogramming in Scala 3[^1]. Contains and extends the calculus of <em>Multi-stage programming with generative and analytical macros</em> with type polymorphism.</li>
    </ul>
   </section>
   <section id="syntax-33">
    <h2 class="h500"><a href="#syntax-33" class="anchor"></a>Syntax</h2>
    <p>The quotation syntax using <code>'</code> and <code>$</code> was chosen to mimic the string interpolation syntax of Scala. Like a string double-quotation, a single-quote block can contain splices. However, unlike strings, splices can contain quotes using the same rules.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>s" Hello $name"           s" Hello ${name}"
</span><span line-number="2" class=""><span class="tooltip-container"></span>'{ hello($name) }         '{ hello(${name}) }
</span><span line-number="3" class=""><span class="tooltip-container"></span>${ hello('name) }         ${ hello('{name}) }
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="quotes-2">
    <h3 class="h400"><a href="#quotes-2" class="anchor"></a>Quotes</h3>
    <p>Quotes come in four flavors: quoted identifiers, quoted blocks, quoted block patterns and quoted type patterns. Scala 2 used quoted identifiers to represent <code>Symbol</code> literals. They were deprecated in Scala 3, allowing the syntax to be used for quotation.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>SimpleExpr ::= ...
</span><span line-number="2" class=""><span class="tooltip-container"></span>             |  `'` alphaid                           // quoted identifier
</span><span line-number="3" class=""><span class="tooltip-container"></span>             |  `'` `{` Block `}`                     // quoted block
</span><span line-number="4" class=""><span class="tooltip-container"></span>Pattern    ::= ...
</span><span line-number="5" class=""><span class="tooltip-container"></span>             |  `'` `{` Block `}`                     // quoted block pattern
</span><span line-number="6" class=""><span class="tooltip-container"></span>             |  `'` `[` Type `]`                      // quoted type pattern
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Quoted blocks and quoted block patterns contain an expression equivalent to a normal block of code. When entering either of those we track the fact that we are in a quoted block (<code>inQuoteBlock</code>) which is used for spliced identifiers. When entering a quoted block pattern we additionally track the fact that we are in a quoted pattern (<code>inQuotePattern</code>) which is used to distinguish spliced blocks and splice patterns. Lastly, the quoted type pattern simply contains a type.</p>
   </section>
   <section id="splices-1">
    <h3 class="h400"><a href="#splices-1" class="anchor"></a>Splices</h3>
    <p>Splices come in three flavors: spliced identifiers, spliced blocks and splice patterns. Scala specifies identifiers containing <code>$</code> as valid identifiers but reserves them for compiler and standard library use only. Unfortunately, many libraries have used such identifiers in Scala 2. Therefore to mitigate the cost of migration, we still support them. We work around this by only allowing spliced identifiers[^3] within quoted blocks or quoted block patterns (<code>inQuoteBlock</code>). Splice blocks and splice patterns can contain an arbitrary block or pattern respectively. They are distinguished based on their surrounding quote (<code>inQuotePattern</code>), a quote block will contain spliced blocks, and a quote block pattern will contain splice patterns.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>SimpleExpr ::= ...
</span><span line-number="2" class=""><span class="tooltip-container"></span>             |  `$` alphaid         if  inQuoteBlock    // spliced identifier
</span><span line-number="3" class=""><span class="tooltip-container"></span>             |  `$` `{` Block `}`   if !inQuotePattern  // spliced block
</span><span line-number="4" class=""><span class="tooltip-container"></span>             |  `$` `{` Pattern `}` if  inQuotePattern  // splice pattern
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="quoted-pattern-type-variables-1">
    <h3 class="h400"><a href="#quoted-pattern-type-variables-1" class="anchor"></a>Quoted Pattern Type Variables</h3>
    <p>Quoted pattern type variables in quoted patterns and quoted type patterns do not require additional syntax. Any type definition or reference with a name composed of lower cases is assumed to be a pattern type variable definition while typing. A backticked type name with lower cases is interpreted as a reference to the type with that name.</p>
   </section>
   <section id="implementation-9">
    <h2 class="h500"><a href="#implementation-9" class="anchor"></a>Implementation</h2>
   </section>
   <section id="run-time-representation-1">
    <h3 class="h400"><a href="#run-time-representation-1" class="anchor"></a>Run-Time Representation</h3>
    <p>The standard library defines the <code>Quotes</code> interface which contains all the logic and the abstract classes <code>Expr</code> and <code>Type</code>. The compiler implements the <code>Quotes</code> interface and provides the implementation of <code>Expr</code> and <code>Type</code>.</p>
   </section>
   <section id="class-expr-1">
    <h5 class="h50"><a href="#class-expr-1" class="anchor"></a><code>class Expr</code></h5>
    <p>Expressions of type <code>Expr[T]</code> are represented by the following abstract class:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>abstract class Expr[+T] private[scala]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The only implementation of <code>Expr</code> is in the compiler along with the implementation of <code>Quotes</code>. It is a class that wraps a typed AST and a <code>Scope</code> object with no methods of its own. The <code>Scope</code> object is used to track the current splice scope and detect scope extrusions.</p>
   </section>
   <section id="object-expr-1">
    <h5 class="h50"><a href="#object-expr-1" class="anchor"></a><code>object Expr</code></h5>
    <p>The companion object of <code>Expr</code> contains a few useful static methods; the <code>apply</code>/<code>unapply</code> methods to use <code>ToExpr</code>/<code>FromExpr</code> with ease; the <code>betaReduce</code> and <code>summon</code> methods. It also contains methods to create expressions out of lists or sequences of expressions: <code>block</code>, <code>ofSeq</code>, <code>ofList</code>, <code>ofTupleFromSeq</code> and <code>ofTuple</code>.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>object Expr:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def apply[T](x: T)(using ToExpr[T])(using Quotes): Expr[T] = ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>  def unapply[T](x: Expr[T])(using FromExpr[T])(using Quotes): Option[T] = ...
</span><span line-number="4" class=""><span class="tooltip-container"></span>  def betaReduce[T](e: Expr[T])(using Quotes): Expr[T] = ...
</span><span line-number="5" class=""><span class="tooltip-container"></span>  def summon[T: Type](using Quotes): Option[Expr[T]] = ...
</span><span line-number="6" class=""><span class="tooltip-container"></span>  def block[T](stats: List[Expr[Any]], e: Expr[T])(using Quotes): Expr[T] = ...
</span><span line-number="7" class=""><span class="tooltip-container"></span>  def ofSeq[T: Type](xs: Seq[Expr[T]])(using Quotes): Expr[Seq[T]] = ...
</span><span line-number="8" class=""><span class="tooltip-container"></span>  def ofList[T: Type](xs: Seq[Expr[T]])(using Quotes): Expr[List[T]] = ...
</span><span line-number="9" class=""><span class="tooltip-container"></span>  def ofTupleFromSeq(xs: Seq[Expr[Any]])(using Quotes): Expr[Tuple] = ...
</span><span line-number="10" class=""><span class="tooltip-container"></span>  def ofTuple[T &lt;: Tuple: Tuple.IsMappedBy[Expr]: Type](tup: T)(using Quotes):
</span><span line-number="11" class=""><span class="tooltip-container"></span>      Expr[Tuple.InverseMap[T, Expr]] = ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="class-type-1">
    <h5 class="h50"><a href="#class-type-1" class="anchor"></a><code>class Type</code></h5>
    <p>Types of type <code>Type[T]</code> are represented by the following abstract class:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>abstract class Type[T &lt;: AnyKind] private[scala]:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  type Underlying = T
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The only implementation of <code>Type</code> is in the compiler along with the implementation of <code>Quotes</code>. It is a class that wraps the AST of a type and a <code>Scope</code> object with no methods of its own. The upper bound of <code>T</code> is <code>AnyKind</code> which implies that <code>T</code> may be a higher-kinded type. The <code>Underlying</code> alias is used to select the type from an instance of <code>Type</code>. Users never need to use this alias as they can always use <code>T</code> directly. <code>Underlying</code> is used for internal encoding while compiling the code (see <em>Type Healing</em>).</p>
   </section>
   <section id="object-type-1">
    <h5 class="h50"><a href="#object-type-1" class="anchor"></a><code>object Type</code></h5>
    <p>The companion object of <code>Type</code> contains a few useful static methods. The first and most important one is the <code>Type.of</code> given definition. This instance of <code>Type[T]</code> is summoned by default when no other instance is available. The <code>of</code> operation is an intrinsic operation that the compiler will transform into code that will generate the <code>Type[T]</code> at run-time. Secondly, the <code>Type.show[T]</code> operation will show a string representation of the type, which is often useful when debugging. Finally, the object defines <code>valueOfConstant</code> (and <code>valueOfTuple</code>) which can transform singleton types (or tuples of singleton types) into their value.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>object Type:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  given of: [T &lt;: AnyKind] =&gt; Quotes =&gt; Type[T] = ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>  def show[T &lt;: AnyKind](using Type[T])(using Quotes): String = ...
</span><span line-number="4" class=""><span class="tooltip-container"></span>  def valueOfConstant[T](using Type[T])(using Quotes): Option[T] = ...
</span><span line-number="5" class=""><span class="tooltip-container"></span>  def valueOfTuple[T &lt;: Tuple](using Type[T])(using Quotes): Option[T] = ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="quotes-3">
    <h5 class="h50"><a href="#quotes-3" class="anchor"></a><code>Quotes</code></h5>
    <p>The <code>Quotes</code> interface is where most of the primitive operations of the quotation system are defined.</p>
    <p>Quotes define all the <code>Expr[T]</code> methods as extension methods. <code>Type[T]</code> does not have methods and therefore does not appear here. These methods are available as long as <code>Quotes</code> is implicitly given in the current scope.</p>
    <p>The <code>Quotes</code> instance is also the entry point to the <a href="reflection.html">reflection API</a> through the <code>reflect</code> object.</p>
    <p>Finally, <code>Quotes</code> provides the internal logic used in quote un-pickling (<code>QuoteUnpickler</code>) in quote pattern matching (<code>QuoteMatching</code>). These interfaces are added to the self-type of the trait to make sure they are implemented on this object but not visible to users of <code>Quotes</code>.</p>
    <p>Internally, the implementation of <code>Quotes</code> will also track its current splicing scope <code>Scope</code>. This scope will be attached to any expression that is created using this <code>Quotes</code> instance.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait Quotes:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  this: runtime.QuoteUnpickler &amp; runtime.QuoteMatching =&gt;
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>  extension [T](self: Expr[T])
</span><span line-number="5" class=""><span class="tooltip-container"></span>    def show: String
</span><span line-number="6" class=""><span class="tooltip-container"></span>    def matches(that: Expr[Any]): Boolean
</span><span line-number="7" class=""><span class="tooltip-container"></span>    def value(using FromExpr[T]): Option[T]
</span><span line-number="8" class=""><span class="tooltip-container"></span>    def valueOrAbort(using FromExpr[T]): T
</span><span line-number="9" class=""><span class="tooltip-container"></span>  end extension
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>  extension (self: Expr[Any])
</span><span line-number="12" class=""><span class="tooltip-container"></span>    def isExprOf[X](using Type[X]): Boolean
</span><span line-number="13" class=""><span class="tooltip-container"></span>    def asExprOf[X](using Type[X]): Expr[X]
</span><span line-number="14" class=""><span class="tooltip-container"></span>  end extension
</span><span line-number="15" class=""><span class="tooltip-container"></span>
</span><span line-number="16" class=""><span class="tooltip-container"></span>  // abstract object reflect ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="scope-1">
    <h5 class="h50"><a href="#scope-1" class="anchor"></a><code>Scope</code></h5>
    <p>The splice context is represented as a stack (immutable list) of <code>Scope</code> objects. Each <code>Scope</code> contains the position of the splice (used for error reporting) and a reference to the enclosing splice scope <code>Scope</code>. A scope is a sub-scope of another if the other is contained in its parents. This check is performed when an expression is spliced into another using the <code>Scope</code> provided in the current scope in <code>Quotes</code> and the one in the <code>Expr</code> or <code>Type</code>.</p>
   </section>
   <section id="entry-points-1">
    <h3 class="h400"><a href="#entry-points-1" class="anchor"></a>Entry Points</h3>
    <p>The two entry points for multi-stage programming are macros and the <code>run</code> operation.</p>
   </section>
   <section id="macros-3">
    <h4 class="h300"><a href="#macros-3" class="anchor"></a>Macros</h4>
    <p>Inline macro definitions will inline a top-level splice (a splice not nested in a quote). This splice needs to be evaluated at compile-time. In <em>Avoiding a complete interpreter</em>[^1], we stated the following restrictions:</p>
    <ul>
     <li>The top-level splice must contain a single call to a compiled static method.</li>
     <li>Arguments to the function are either literal constants, quoted expressions (parameters), <code>Type.of</code> for type parameters and a reference to <code>Quotes</code>.</li>
    </ul>
    <p>These restrictions make the implementation of the interpreter quite simple. Java Reflection is used to call the single function call in the top-level splice. The execution of that function is entirely done on compiled bytecode. These are Scala static methods and may not always become Java static methods, they might be inside module objects. As modules are encoded as class instances, we need to interpret the prefix of the method to instantiate it before we can invoke the method.</p>
    <p>The code of the arguments has not been compiled and therefore needs to be interpreted by the compiler. Interpreting literal constants is as simple as extracting the constant from the AST that represents literals. When interpreting a quoted expression, the contents of the quote is kept as an AST which is wrapped inside the implementation of <code>Expr</code>. Calls to <code>Type.of[T]</code> also wrap the AST of the type inside the implementation of <code>Type</code>. Finally, the reference to <code>Quotes</code> is supposed to be the reference to the quotes provided by the splice. This reference is interpreted as a new instance of <code>Quotes</code> that contains a fresh initial <code>Scope</code> with no parents.</p>
    <p>The result of calling the method via Java Reflection will return an <code>Expr</code> containing a new AST that was generated by the implementation of that macro. The scope of this <code>Expr</code> is checked to make sure it did not extrude from some splice or <code>run</code> operation. Then the AST is extracted from the <code>Expr</code> and it is inserted as replacement for the AST that contained the top-level splice.</p>
   </section>
   <section id="run-time-multi-stage-programming-3">
    <h4 class="h300"><a href="#run-time-multi-stage-programming-3" class="anchor"></a>Run-time Multi-Stage Programming</h4>
    <p>To be able to compile the code, the <code>scala.quoted.staging</code> library defines the <code>Compiler</code> trait. An instance of <code>staging.Compiler</code> is a wrapper over the normal Scala~3 compiler. To be instantiated it requires an instance of the JVM <em>classloader</em> of the application.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.quoted.staging.*
</span><span line-number="2" class=""><span class="tooltip-container"></span>given Compiler = Compiler.make(getClass.getClassLoader)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The classloader is needed for the compiler to know which dependencies have been loaded and to load the generated code using the same classloader. Below is an example method <code>mkPower2</code> that is passed to <code>staging.run</code>:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def mkPower2()(using Quotes): Expr[Double =&gt; Double] = ...
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>run(mkPower2())
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>To run the previous example, the compiler will create code equivalent to the following class and compile it using a new <code>Scope</code> without parents.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class RunInstance:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def exec(): Double =&gt; Double = ${ mkPower2() }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Finally, <code>run</code> will interpret <code>(new RunInstance).exec()</code> to evaluate the contents of the quote. To do this, the resulting <code>RunInstance</code> class is loaded in the JVM using Java Reflection, instantiated and then the <code>exec</code> method is invoked.</p>
   </section>
   <section id="compilation-1">
    <h3 class="h400"><a href="#compilation-1" class="anchor"></a>Compilation</h3>
    <p>Quotes and splices are primitive forms in the generated typed abstract syntax trees. These need to be type-checked with some extra rules, e.g., staging levels need to be checked and the references to generic types need to be adapted. Finally, quoted expressions that will be generated at run-time need to be encoded (serialized/pickled) and decoded (deserialized/unpickled).</p>
   </section>
   <section id="typing-quoted-expressions-1">
    <h4 class="h300"><a href="#typing-quoted-expressions-1" class="anchor"></a>Typing Quoted Expressions</h4>
    <p>The typing process for quoted expressions and splices with <code>Expr</code> is relatively straightforward. At its core, quotes are desugared into calls to <code>quote</code>, splices are desugared into calls to <code>splice</code>. We track the quotation level when desugaring into these methods.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def quote[T](x: T): Quotes ?=&gt; Expr[T]
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>def splice[T](x: Quotes ?=&gt; Expr[T]): T
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>It would be impossible to track the quotation levels if users wrote calls to these methods directly. To know if it is a call to one of those methods we would need to type it first, but to type it we would need to know if it is one of these methods to update the quotation level. Therefore these methods can only be used by the compiler.</p>
    <p>At run-time, the splice needs to have a reference to the <code>Quotes</code> that created its surrounding quote. To simplify this for later phases, we track the current <code>Quotes</code> and encode a reference directly in the splice using <code>nestedSplice</code> instead of <code>splice</code>.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def nestedSplice[T](q: Quotes)(x: q.Nested ?=&gt; Expr[T]): T
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>With this addition, the original <code>splice</code> is only used for top-level splices.</p>
    <p>The levels are mostly used to identify top-level splices that need to be evaluated while typing. We do not use the quotation level to influence the typing process. Level checking is performed at a later phase. This ensures that a source expression in a quote will have the same elaboration as a source expression outside the quote.</p>
   </section>
   <section id="quote-pattern-matching-3">
    <h4 class="h300"><a href="#quote-pattern-matching-3" class="anchor"></a>Quote Pattern Matching</h4>
    <p>Pattern matching is defined in the trait <code>QuoteMatching</code>, which is part of the self type of <code>Quotes</code>. It is implemented by <code>Quotes</code> but not available to users of <code>Quotes</code>. To access it, the compiler generates a cast from <code>Quotes</code> to <code>QuoteMatching</code> and then selects one of its two members: <code>ExprMatch</code> or <code>TypeMatch</code>. <code>ExprMatch</code> defines an <code>unapply</code> extractor method that is used to encode quote patterns and <code>TypeMatch</code> defines an <code>unapply</code> method for quoted type patterns.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait Quotes:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  self: runtime.QuoteMatching &amp; ...  =&gt;
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ...
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>trait QuoteMatching:
</span><span line-number="6" class=""><span class="tooltip-container"></span>  object ExprMatch:
</span><span line-number="7" class=""><span class="tooltip-container"></span>    def unapply[TypeBindings &lt;: Tuple, Tup &lt;: Tuple]
</span><span line-number="8" class=""><span class="tooltip-container"></span>               (scrutinee: Expr[Any])
</span><span line-number="9" class=""><span class="tooltip-container"></span>               (using pattern: Expr[Any]): Option[Tup] = ...
</span><span line-number="10" class=""><span class="tooltip-container"></span>  object TypeMatch:
</span><span line-number="11" class=""><span class="tooltip-container"></span>    ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>These extractor methods are only meant to be used in code generated by the compiler. The call to the extractor that is generated has an already elaborated form that cannot be written in source, namely explicit type parameters and explicit contextual parameters.</p>
    <p>This extractor returns a tuple type <code>Tup</code> which cannot be inferred from the types in the method signature. This type will be computed when typing the quote pattern and will be explicitly added to the extractor call. To refer to type variables in arbitrary places of <code>Tup</code>, we need to define them all before their use, hence we have <code>TypeBindings</code>, which will contain all pattern type variable definitions. The extractor also receives a given parameter of type <code>Expr[Any]</code> that will contain an expression that represents the pattern. The compiler will explicitly add this pattern expression. We use a given parameter because these are the only parameters we are allowed to add to the extractor call in a pattern position.</p>
    <p>This extractor is a bit convoluted, but it encodes away all the quotation-specific features. It compiles the pattern down into a representation that the pattern matcher compiler phase understands.</p>
    <p>The quote patterns are encoded into two parts: a tuple pattern that is tasked with extracting the result of the match and a quoted expression representing the pattern. For example, if the pattern has no <code>$</code> we will have an <code>EmptyTuple</code> as the pattern and <code>'{1}</code> to represent the pattern.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  case '{ 1 } =&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>// is elaborated to
</span><span line-number="3" class=""><span class="tooltip-container"></span>  case ExprMatch(EmptyTuple)(using '{1}) =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>//               ^^^^^^^^^^  ^^^^^^^^^^
</span><span line-number="5" class=""><span class="tooltip-container"></span>//                pattern    expression
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>When extracting expressions, each pattern that is contained in a splice <code>${..}</code> will be placed in order in the tuple pattern. In the following case, the <code>f</code> and <code>x</code> are placed in a tuple pattern <code>(f, x)</code>. The type of the tuple is encoded in the <code>Tup</code> and not only in the tuple itself. Otherwise, the extractor would return a tuple <code>Tuple</code> for which the types need to be tested which is in turn not possible due to type erasure.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  case '{ ((y: Int) =&gt; $f(y)).apply($x) } =&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>// is elaborated to
</span><span line-number="3" class=""><span class="tooltip-container"></span>  case ExprMatch[.., (Expr[Int =&gt; Int], Expr[Int])]((f, x))(using pattern) =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>// pattern = '{ ((y: Int) =&gt; pat[Int](y)).apply(pat[Int]()) }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The contents of the quote are transformed into a valid quote expression by replacing the splice with a marker expression <code>pat[T](..)</code>. The type <code>T</code> is taken from the type of the splice and the arguments are the HOAS arguments. This implies that a <code>pat[T]()</code> is a closed pattern and <code>pat[T](y)</code> is an HOAS pattern that can refer to <code>y</code>.</p>
    <p>Type variables in quoted patterns are first normalized to have all definitions at the start of the pattern. For each definition of a type variable <code>t</code> in the pattern we will add a type variable definition in <code>TypeBindings</code>. Each one will have a corresponding <code>Type[t]</code> that will get extracted if the pattern matches. These <code>Type[t]</code> are also listed in the <code>Tup</code> and added in the tuple pattern. It is additionally marked as <code>using</code> in the pattern to make it implicitly available in this case branch.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  case '{ type t; ($xs: List[t]).map[t](identity[t]) } =&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>// is elaborated to
</span><span line-number="3" class=""><span class="tooltip-container"></span>  case ExprMatch[(t), (Type[t], Expr[List[t]])]((using t, xs))(using p) =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>//               ^^^  ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^
</span><span line-number="5" class=""><span class="tooltip-container"></span>//     type bindings        result type            pattern     expression
</span><span line-number="6" class=""><span class="tooltip-container"></span>// p = '{ @patternType type u; pat[List[u]]().map[u](identity[u]) }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The contents of the quote are transformed into a valid quote expression by replacing type variables with fresh ones that do not escape the quote scope. These are also annotated to be easily identifiable as pattern variables.</p>
   </section>
   <section id="level-consistency-checking-1">
    <h4 class="h300"><a href="#level-consistency-checking-1" class="anchor"></a>Level Consistency Checking</h4>
    <p>Level consistency checking is performed after typing the program as a static check. To check level consistency we traverse the tree top-down remembering the context staging level. Each local definition in scope is recorded with its level and each term reference to a definition is checked against the current staging level.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// level 0
</span><span line-number="2" class=""><span class="tooltip-container"></span>'{ // level 1
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val x = ... // level 1 with (x -&gt; 1)
</span><span line-number="4" class=""><span class="tooltip-container"></span>  ${ // level 0 (x -&gt; 1)
</span><span line-number="5" class=""><span class="tooltip-container"></span>    val y = ... // level 0 with (x -&gt; 1, y -&gt; 0)
</span><span line-number="6" class=""><span class="tooltip-container"></span>    x // error: defined at level 1 but used in level 0
</span><span line-number="7" class=""><span class="tooltip-container"></span>  }
</span><span line-number="8" class=""><span class="tooltip-container"></span>  // level 1 (x -&gt; 1)
</span><span line-number="9" class=""><span class="tooltip-container"></span>  x // x is ok
</span><span line-number="10" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="type-healing-1">
    <h4 class="h300"><a href="#type-healing-1" class="anchor"></a>Type Healing</h4>
    <p>When using a generic type <code>T</code> in a future stage, it is necessary to have a given <code>Type[T]</code> in scope. The compiler needs to identify those references and link them with the instance of <code>Type[T]</code>. For instance consider the following example:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def emptyList[T](using t: Type[T])(using Quotes): Expr[List[T]] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  '{ List.empty[T] }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>For each reference to a generic type <code>T</code> that is defined at level 0 and used at level 1 or greater, the compiler will summon a <code>Type[T]</code>. This is usually the given type that is provided as parameter, <code>t</code> in this case. We can use the type <code>t.Underlying</code> to replace <code>T</code> as it is an alias of that type. But <code>t.Underlying</code> contains the extra information that it is <code>t</code> that will be used in the evaluation of the quote. In a sense, <code>Underlying</code> acts like a splice for types.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def emptyList[T](using t: Type[T])(using Quotes): Expr[List[T]] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  '{ List.empty[t.Underlying] }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Due to some technical limitations, it is not always possible to replace the type reference with the AST containing <code>t.Underlying</code>. To overcome this limitation, we can simply define a list of type aliases at the start of the quote and insert the <code>t.Underlying</code> there. This has the added advantage that we do not have to repeatedly insert the <code>t.Underlying</code> in the quote.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def emptyList[T](using t: Type[T])(using Quotes): Expr[List[T]] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  '{ type U = t.Underlying; List.empty[U] }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>These aliases can be used at any level within the quote and this transformation is only performed on quotes that are at level 0.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  '{ List.empty[T] ... '{ List.empty[T] } ... }
</span><span line-number="2" class=""><span class="tooltip-container"></span>// becomes
</span><span line-number="3" class=""><span class="tooltip-container"></span>  '{ type U = t.Underlying; List.empty[U] ... '{ List.empty[U] } ... }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>If we define a generic type at level 1 or greater, it will not be subject to this transformation. In some future compilation stage, when the definition of the generic type is at level 0, it will be subject to this transformation. This simplifies the transformation logic and avoids leaking the encoding into code that a macro could inspect.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def emptyList[T: Type](using Quotes): Expr[List[T]] = '{ List.empty[T] }
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ...
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>A similar transformation is performed on <code>Type.of[T]</code>. Any generic type in <code>T</code> needs to have an implicitly given <code>Type[T]</code> in scope, which will also be used as a path. The example:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def empty[T](using t: Type[T])(using Quotes): Expr[T] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  Type.of[T] match ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>// becomes
</span><span line-number="4" class=""><span class="tooltip-container"></span>def empty[T](using t: Type[T])(using Quotes): Expr[T] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  Type.of[t.Underlying] match ...
</span><span line-number="6" class=""><span class="tooltip-container"></span>// then becomes
</span><span line-number="7" class=""><span class="tooltip-container"></span>def empty[T](using t: Type[T])(using Quotes): Expr[T] =
</span><span line-number="8" class=""><span class="tooltip-container"></span>  t match ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The operation <code>Type.of[t.Underlying]</code> can be optimized to just <code>t</code>. But this is not always the case. If the generic reference is nested in the type, we will need to keep the <code>Type.of</code>.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def matchOnList[T](using t: Type[T])(using Quotes): Expr[List[T]] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  Type.of[List[T]] match ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>// becomes
</span><span line-number="4" class=""><span class="tooltip-container"></span>def matchOnList[T](using t: Type[T])(using Quotes): Expr[List[T]] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  Type.of[List[t.Underlying]] match ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>By doing this transformation, we ensure that each abstract type <code>U</code> used in <code>Type.of</code> has an implicit <code>Type[U]</code> in scope. This representation makes it simpler to identify parts of the type that are statically known from those that are known dynamically. Type aliases are also added within the type of the <code>Type.of</code> though these are not valid source code. These would look like <code>Type.of[{type U = t.Underlying; Map[U, U]}]</code> if written in source code.</p>
   </section>
   <section id="splice-normalization-1">
    <h4 class="h300"><a href="#splice-normalization-1" class="anchor"></a>Splice Normalization</h4>
    <p>The contents of a splice may refer to variables defined in the enclosing quote. This complicates the process of serialization of the contents of the quotes. To make serialization simple, we first transform the contents of each level 1 splice. Consider the following example:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def power5to(n: Expr[Int]): Expr[Double] = '{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val x: Int = 5
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${ powerCode('{x}, n) }
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The variable <code>x</code> is defined in the quote and used in the splice. The normal form will extract all references to <code>x</code> and replace them with a staged version of <code>x</code>. We will replace the reference to <code>x</code> of type <code>T</code> with a <code>$y</code> where <code>y</code> is of type <code>Expr[T]</code>. Then we wrap the new contents of the splice in a lambda that defines <code>y</code> and apply it to the quoted version of <code>x</code>. After this transformation we have 2 parts, a lambda without references to the quote, which knows how to compute the contents of the splice, and a sequence of quoted arguments that refer to variables defined in the lambda.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def power5to(n: Expr[Int]): Expr[Double] = '{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val x: Int = 5
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${ ((y: Expr[Int]) =&gt; powerCode('{$y}, n)).apply('x) }
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>In general, the splice normal form has the shape <code>${ &lt;lambda&gt;.apply(&lt;args&gt;*) }</code> and the following constraints:</p>
    <ul>
     <li><code>&lt;lambda&gt;</code> a lambda expression that does not refer to variables defined in the outer quote</li>
     <li><code>&lt;args&gt;</code> sequence of quoted expressions or <code>Type.of</code> containing references to variables defined in the enclosing quote and no references to local variables defined outside the enclosing quote</li>
    </ul>
   </section>
   <section id="function-references-normalization-1">
    <h5 class="h50"><a href="#function-references-normalization-1" class="anchor"></a>Function references normalization</h5>
    <p>A reference to a function <code>f</code> that receives parameters is not a valid value in Scala. Such a function reference <code>f</code> can be eta-expanded as <code>x =&gt; f(x)</code> to be used as a lambda value. Therefore function references cannot be transformed by the normalization as directly as other expressions as we cannot represent <code>'{f}</code> with a method reference type. We can use the eta-expanded form of <code>f</code> in the normalized form. For example, consider the reference to <code>f</code> below.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def f(a: Int)(b: Int, c: Int): Int = 2 + a + b + c
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${ '{ f(3)(4, 5) } }
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>To normalize this code, we can eta-expand the reference to <code>f</code> and place it in a quote containing a proper expression. Therefore the normalized form of the argument <code>'{f}</code> becomes the quoted lambda <code>'{ (a: Int) =&gt; (b: Int, c: Int) =&gt; f(a)(b, c) }</code> and is an expression of type <code>Expr[Int =&gt; (Int, Int) =&gt; Int]</code>. The eta-expansion produces one curried lambda per parameter list. The application <code>f(3)(4, 5)</code> does not become <code>$g(3)(4, 5)</code> but <code>$g.apply(3).apply(4, 5)</code>. We add the <code>apply</code> because <code>g</code> is not a quoted reference to a function but a curried lambda.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def f(a: Int)(b: Int, c: Int): Int = 2 + a + b + c
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${
</span><span line-number="4" class=""><span class="tooltip-container"></span>    (
</span><span line-number="5" class=""><span class="tooltip-container"></span>      (g: Expr[Int =&gt; (Int, Int) =&gt; Int]) =&gt; '{$g.apply(3).apply(4, 5)}
</span><span line-number="6" class=""><span class="tooltip-container"></span>    ).apply('{ (a: Int) =&gt; (b: Int, c: Int) =&gt; f(a)(b, c) })
</span><span line-number="7" class=""><span class="tooltip-container"></span>  }
</span><span line-number="8" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Then we can apply it and beta-reduce the application when generating the code.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">      </span>(g: Expr[Int =&gt; Int =&gt; Int]) =&gt; betaReduce('{$g.apply(3).apply(4)})
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="variable-assignment-normalization-1">
    <h5 class="h50"><a href="#variable-assignment-normalization-1" class="anchor"></a>Variable assignment normalization</h5>
    <p>A reference to a mutable variable in the left-hand side of an assignment cannot be transformed directly as it is not in an expression position.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  var x: Int = 5
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${ g('{x = 2}) }
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>We can use the same strategy used for function references by eta-expanding the assignment operation <code>x = _</code> into <code>y =&gt; x = y</code>.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  var x: Int = 5
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${
</span><span line-number="4" class=""><span class="tooltip-container"></span>    g(
</span><span line-number="5" class=""><span class="tooltip-container"></span>      (
</span><span line-number="6" class=""><span class="tooltip-container"></span>        (f: Expr[Int =&gt; Unit]) =&gt; betaReduce('{$f(2)})
</span><span line-number="7" class=""><span class="tooltip-container"></span>      ).apply('{ (y: Int) =&gt; x = $y })
</span><span line-number="8" class=""><span class="tooltip-container"></span>    )
</span><span line-number="9" class=""><span class="tooltip-container"></span>  }
</span><span line-number="10" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="type-normalization-1">
    <h5 class="h50"><a href="#type-normalization-1" class="anchor"></a>Type normalization</h5>
    <p>Types defined in the quote are subject to a similar transformation. In this example, <code>T</code> is defined within the quote at level 1 and used in the splice again at level 1.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{ def f[T] = ${ '{g[T]} } }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The normalization will add a <code>Type[T]</code> to the lambda, and we will insert this reference. The difference is that it will add an alias similar to the one used in type healing. In this example, we create a <code>type U</code> that aliases the staged type.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def f[T] = ${
</span><span line-number="3" class=""><span class="tooltip-container"></span>    (
</span><span line-number="4" class=""><span class="tooltip-container"></span>      (t: Type[T]) =&gt; '{type U = t.Underling; g[U]}
</span><span line-number="5" class=""><span class="tooltip-container"></span>    ).apply(Type.of[T])
</span><span line-number="6" class=""><span class="tooltip-container"></span>  }
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="serialization-1">
    <h4 class="h300"><a href="#serialization-1" class="anchor"></a>Serialization</h4>
    <p>Quoted code needs to be pickled to make it available at run-time in the next compilation phase. We implement this by pickling the AST as a TASTy binary.</p>
   </section>
   <section id="tasty-1">
    <h5 class="h50"><a href="#tasty-1" class="anchor"></a>TASTy</h5>
    <p>The TASTy format is the typed abstract syntax tree serialization format of Scala 3. It usually pickles the fully elaborated code after type-checking and is kept along the generated Java classfiles.</p>
   </section>
   <section id="pickling-1">
    <h5 class="h50"><a href="#pickling-1" class="anchor"></a>Pickling</h5>
    <p>We use TASTy as a serialization format for the contents of the quotes. To show how serialization is performed, we will use the following example.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val (x, n): (Double, Int) = (5, 2)
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${ powerCode('{x}, '{n}) } * ${ powerCode('{2}, '{n}) }
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This quote is transformed into the following code when normalizing the splices.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val (x, n): (Double, Int) = (5, 2)
</span><span line-number="3" class=""><span class="tooltip-container"></span>  ${
</span><span line-number="4" class=""><span class="tooltip-container"></span>    ((y: Expr[Double], m: Expr[Int]) =&gt; powerCode(y, m)).apply('x, 'n)
</span><span line-number="5" class=""><span class="tooltip-container"></span>  } * ${
</span><span line-number="6" class=""><span class="tooltip-container"></span>    ((m: Expr[Int]) =&gt; powerCode('{2}, m)).apply('n)
</span><span line-number="7" class=""><span class="tooltip-container"></span>  }
</span><span line-number="8" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Splice normalization is a key part of the serialization process as it only allows references to variables defined in the quote in the arguments of the lambda in the splice. This makes it possible to create a closed representation of the quote without much effort. The first step is to remove all the splices and replace them with holes. A hole is like a splice but it lacks the knowledge of how to compute the contents of the splice. Instead, it knows the index of the hole and the contents of the arguments of the splice. We can see this transformation in the following example where a hole is represented by <code>&lt;&lt; idx; holeType; args* &gt;&gt;</code>.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  ${ ((y: Expr[Double], m: Expr[Int]) =&gt; powerCode(y, m)).apply('x, 'n) }
</span><span line-number="2" class=""><span class="tooltip-container"></span>// becomes
</span><span line-number="3" class=""><span class="tooltip-container"></span>  &lt;&lt; 0; Double; x, n &gt;&gt;
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>As this was the first hole it has index 0. The hole type is <code>Double</code>, which needs to be remembered now that we cannot infer it from the contents of the splice. The arguments of the splice are <code>x</code> and <code>n</code>; note that they do not require quoting because they were moved out of the splice.</p>
    <p>References to healed types are handled in a similar way. Consider the <code>emptyList</code> example, which shows the type aliases that are inserted into the quote.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{ List.empty[T] }
</span><span line-number="2" class=""><span class="tooltip-container"></span>// type healed to
</span><span line-number="3" class=""><span class="tooltip-container"></span>'{ type U = t.Underlying; List.empty[U] }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Instead of replacing a splice, we replace the <code>t.Underlying</code> type with a type hole. The type hole is represented by <code>&lt;&lt; idx; bounds &gt;&gt;</code>.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>'{ type U = &lt;&lt; 0; Nothing..Any &gt;&gt;; List.empty[U] }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Here, the bounds of <code>Nothing..Any</code> are the bounds of the original <code>T</code> type. The types of a <code>Type.of</code> are transformed in the same way.</p>
    <p>With these transformations, the contents of the quote or <code>Type.of</code> are guaranteed to be closed and therefore can be pickled. The AST is pickled into TASTy, which is a sequence of bytes. This sequence of bytes needs to be instantiated in the bytecode, but unfortunately it cannot be dumped into the classfile as bytes. To reify it we encode the bytes into a Java <code>String</code>. In the following examples we display this encoding in human readable form with the fictitious <code>|tasty"..."|</code> string literal.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// pickled AST bytes encoded in a base64 string
</span><span line-number="2" class=""><span class="tooltip-container"></span>tasty"""
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val (x, n): (Double, Int) = (5, 2)
</span><span line-number="4" class=""><span class="tooltip-container"></span>  &lt;&lt; 0; Double; x, n &gt;&gt; * &lt;&lt; 1; Double; n &gt;&gt;
</span><span line-number="5" class=""><span class="tooltip-container"></span>"""
</span><span line-number="6" class=""><span class="tooltip-container"></span>// or
</span><span line-number="7" class=""><span class="tooltip-container"></span>tasty"""
</span><span line-number="8" class=""><span class="tooltip-container"></span>  type U = &lt;&lt; 0; Nothing..Any; &gt;&gt;
</span><span line-number="9" class=""><span class="tooltip-container"></span>  List.empty[U]
</span><span line-number="10" class=""><span class="tooltip-container"></span>"""
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The contents of a quote or <code>Type.of</code> are not always pickled. In some cases it is better to generate equivalent (smaller and/or faster) code that will compute the expression. Literal values are compiled into a call to <code>Expr(&lt;literal&gt;)</code> using the implementation of <code>ToExpr</code> to create the quoted expression. This is currently performed only on literal values, but can be extended to any value for which we have a <code>ToExpr</code> defined in the standard library. Similarly, for non-generic types we can use their respective <code>java.lang.Class</code> and convert them into a <code>Type</code> using a primitive operation <code>typeConstructorOf</code> defined in the reflection API.</p>
   </section>
   <section id="unpickling-1">
    <h5 class="h50"><a href="#unpickling-1" class="anchor"></a>Unpickling</h5>
    <p>Now that we have seen how a quote is pickled, we can look at how to unpickle it. We will continue with the previous example.</p>
    <p>Holes were used to replace the splices in the quote. When we perform this transformation we also need to remember the lambdas from the splices and their hole index. When unpickling a hole, the corresponding splice lambda will be used to compute the contents of the hole. The lambda will receive as parameters quoted versions of the arguments of the hole. For example to compute the contents of <code>&lt;&lt; 0; Double; x, n &gt;&gt;</code> we will evaluate the following code</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>((y: Expr[Double], m: Expr[Int]) =&gt; powerCode(y, m)).apply('x, 'n)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The evaluation is not as trivial as it looks, because the lambda comes from compiled code and the rest is code that must be interpreted. We put the AST of <code>x</code> and <code>n</code> into <code>Expr</code> objects to simulate the quotes and then we use Java Reflection to call the <code>apply</code> method.</p>
    <p>We may have many holes in a quote and therefore as many lambdas. To avoid the instantiation of many lambdas, we can join them together into a single lambda. Apart from the list of arguments, this lambda will also take the index of the hole that is being evaluated. It will perform a switch match on the index and call the corresponding lambda in each branch. Each branch will also extract the arguments depending on the definition of the lambda. The application of the original lambdas are beta-reduced to avoid extra overhead.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>(idx: Int, args: Seq[Any]) =&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>  idx match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case 0 =&gt; // for &lt;&lt; 0; Double; x, n &gt;&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>      val x = args(0).asInstanceOf[Expr[Double]]
</span><span line-number="5" class=""><span class="tooltip-container"></span>      val n = args(1).asInstanceOf[Expr[Int]]
</span><span line-number="6" class=""><span class="tooltip-container"></span>      powerCode(x, n)
</span><span line-number="7" class=""><span class="tooltip-container"></span>    case 1 =&gt; // for &lt;&lt; 1; Double; n &gt;&gt;
</span><span line-number="8" class=""><span class="tooltip-container"></span>      val n = args(0).asInstanceOf[Expr[Int]]
</span><span line-number="9" class=""><span class="tooltip-container"></span>      powerCode('{2}, n)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This is similar to what we do for splices when we replace the type aliased with holes we keep track of the index of the hole. Instead of lambdas, we will have a list of references to instances of <code>Type</code>. From the following example we would extract <code>t</code>, <code>u</code>, ... .</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  '{ type T1 = t1.Underlying; type Tn = tn.Underlying; ... }
</span><span line-number="2" class=""><span class="tooltip-container"></span>// with holes
</span><span line-number="3" class=""><span class="tooltip-container"></span>  '{ type T1 = &lt;&lt; 0; ... &gt;&gt;; type Tn = &lt;&lt; n-1; ... &gt;&gt;; ... }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>As the type holes are at the start of the quote, they will have the first <code>N</code> indices. This implies that we can place the references in a sequence <code>Seq(t, u, ...)</code> where the index in the sequence is the same as the hole index.</p>
    <p>Lastly, the quote itself is replaced by a call to <code>QuoteUnpickler.unpickleExpr</code> which will unpickle the AST, evaluate the holes, i.e., splices, and wrap the resulting AST in an <code>Expr[Int]</code>. This method takes takes the pickled <code>|tasty"..."|</code>, the types and the hole lambda. Similarly, <code>Type.of</code> is replaced with a call to <code>QuoteUnpickler.unpickleType</code> but only receives the pickled <code>|tasty"..."|</code> and the types. Because <code>QuoteUnpickler</code> is part of the self-type of the <code>Quotes</code> class, we have to cast the instance but know that this cast will always succeed.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>quotes.asInstanceOf[runtime.QuoteUnpickler].unpickleExpr[T](
</span><span line-number="2" class=""><span class="tooltip-container"></span>  pickled = tasty"...",
</span><span line-number="3" class=""><span class="tooltip-container"></span>  types = Seq(...),
</span><span line-number="4" class=""><span class="tooltip-container"></span>  holes = (idx: Int, args: Seq[Any]) =&gt; idx match ...
</span><span line-number="5" class=""><span class="tooltip-container"></span>)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>[^1]: <a href="https://infoscience.epfl.ch/record/299370">Scalable Metaprogramming in Scala 3</a> [^2]: <a href="https://dl.acm.org/doi/10.1145/3486609.3487203">Multi-stage programming with generative and analytical macros</a>. [^3]: In quotes, identifiers starting with <code>$</code> must be surrounded by backticks (<code>`$`</code>). For example <code>$conforms</code> from <code>scala.Predef</code>.</p>
   </section>
  </main>
  <div class="divider"></div>
  <nav class="arrow-navigation" aria-label="Page navigation">
  </nav>
 </div>
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#formalization-1">Formalization</a></li><li><a href="#syntax-33">Syntax</a><ul><li><a href="#quotes-2">Quotes</a></li><li><a href="#splices-1">Splices</a></li><li><a href="#quoted-pattern-type-variables-1">Quoted Pattern Type Variables</a></li></ul></li><li><a href="#implementation-9">Implementation</a><ul><li><a href="#run-time-representation-1">Run-Time Representation</a><ul><li><ul><li><a href="#class-expr-1">class Expr</a></li><li><a href="#object-expr-1">object Expr</a></li><li><a href="#class-type-1">class Type</a></li><li><a href="#object-type-1">object Type</a></li><li><a href="#quotes-3">Quotes</a></li><li><a href="#scope-1">Scope</a></li></ul></li></ul></li><li><a href="#entry-points-1">Entry Points</a><ul><li><a href="#macros-3">Macros</a></li><li><a href="#run-time-multi-stage-programming-3">Run-time Multi-Stage Programming</a></li></ul></li><li><a href="#compilation-1">Compilation</a><ul><li><a href="#typing-quoted-expressions-1">Typing Quoted Expressions</a></li><li><a href="#quote-pattern-matching-3">Quote Pattern Matching</a></li><li><a href="#level-consistency-checking-1">Level Consistency Checking</a></li><li><a href="#type-healing-1">Type Healing</a></li><li><a href="#splice-normalization-1">Splice Normalization</a><ul><li><a href="#function-references-normalization-1">Function references normalization</a></li><li><a href="#variable-assignment-normalization-1">Variable assignment normalization</a></li><li><a href="#type-normalization-1">Type normalization</a></li></ul></li><li><a href="#serialization-1">Serialization</a><ul><li><a href="#tasty-1">TASTy</a></li><li><a href="#pickling-1">Pickling</a></li><li><a href="#unpickling-1">Unpickling</a></li></ul></li></ul></li></ul></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div></div></div></body></html>