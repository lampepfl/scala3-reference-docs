<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/lampepfl/dotty" data-githubContributorsFilename="docs/_docs/reference/syntax.md" data-pathToRoot=""><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Scala 3 Syntax Summary</title><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></link><script type="text/javascript" src="scripts/theme.js"></script><script type="text/javascript" src="scripts/searchData.js" defer="true"></script><script type="text/javascript" src="scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="styles/theme/bundle.css"></link><link rel="stylesheet" href="styles/theme/components/bundle.css"></link><link rel="stylesheet" href="styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="styles/nord-light.css"></link><link rel="stylesheet" href="styles/dotty-icons.css"></link><link rel="stylesheet" href="styles/filter-bar.css"></link><link rel="stylesheet" href="styles/code-snippets.css"></link><link rel="stylesheet" href="styles/searchbar.css"></link><link rel="stylesheet" href="styles/social-links.css"></link><link rel="stylesheet" href="styles/versions-dropdown.css"></link><link rel="stylesheet" href="styles/content-contributors.css"></link><link rel="stylesheet" href="styles/fontawesome.css"></link><script type="text/javascript" src="hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="scripts/ux.js" defer="true"></script><script type="text/javascript" src="scripts/common/component.js" defer="true"></script><script type="text/javascript" src="scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="scripts/data.js" defer="true"></script><link rel="stylesheet" href="styles/staticsitestyles.css"></link><script>var pathToRoot = "";</script><link rel="dns-prefetch" href="//fonts.googleapis.com"> 
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
<link rel="stylesheet" href="/css/dottydoc.css"></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="" class="logo-container"><span id="project-logo" class="project-logo"><img src="project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.3.1-RC1</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="index.html">Docs</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="new-types/index.html"><span>New Types</span></a></span><div class="ni n1 "><span class="nh de"><a href="new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="enums/index.html"><span>Enums</span></a></span><div class="ni n1 "><span class="nh de"><a href="enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni n1 "><span class="nh de"><a href="contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni n1 "><span class="nh de"><a href="metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="metaprogramming/staging.html"><span>Run-Time Multi-Stage Programming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/transparent-traits.html"><span>Transparent Traits and Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/type-checking.html"><span>Changes in Type Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="experimental/index.html"><span>Experimental</span></a></span><div class="ni n1 "><span class="nh de"><a href="experimental/canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="experimental/erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="experimental/named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="experimental/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="experimental/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="experimental/main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="experimental/cc.html"><span>Capture Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="experimental/tupled-function.html"><span>Tupled Function</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 selected de"><a href="#"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n1 "><span class="nh de"><a href="language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2023, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2023, LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="index.html">Scala 3 Reference</a>/<a href="syntax.html">Scala 3 Syntax Summary</a></div><div id="content" class="body-medium"><div><div id="content-wrapper"> 
 <div class="site-container"> 
  <div id="site-header"></div> 
  <main> 
   <header> <a class="text-button with-link body-small" href="https://github.com/lampepfl/dotty/edit/language-reference-stable/docs/_docs/reference/syntax.md">Edit this page on GitHub</a> 
    <h1 class="h600">Scala 3 Syntax Summary</h1> 
   </header> <!--

This page has a companion page at _docs/internals/syntax.md.

!! Make sure to edit both pages in sync. !!

reference/syntax.md shows the official Scala 3 syntax, without deprecated or experimental features.

internals/syntax.md shows the Scala 3 syntax as supported by the parser, including
deprecated and experimental features. It also gives some indications how
productions map to AST nodes.

--> 
   <p class="body-large first-p">The following description of Scala tokens uses literal characters <code>‘c’</code> when referring to the ASCII fragment <code>\u0000</code> – <code>\u007F</code>.</p> 
   <p>Informal descriptions are typeset as <code>“some comment”</code>.</p> 
   <section id="lexical-syntax-1"> 
    <h2 class="h500"><a href="#lexical-syntax-1" class="anchor"></a>Lexical Syntax</h2> 
    <p>The lexical syntax of Scala is given by the following grammar in EBNF form:</p> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-ebnf"><span line-number="1" class=""><span class="tooltip-container"></span>whiteSpace       ::=  ‘\u0020’ | ‘\u0009’ | ‘\u000D’ | ‘\u000A’
</span><span line-number="2" class=""><span class="tooltip-container"></span>upper            ::=  ‘A’ | ... | ‘Z’ | ‘$’ and any character in Unicode categories Lu, Lt or Nl,
</span><span line-number="3" class=""><span class="tooltip-container"></span>                      and any character in Unicode categories Lo and Lm that doesn't have
</span><span line-number="4" class=""><span class="tooltip-container"></span>                      contributory property Other_Lowercase
</span><span line-number="5" class=""><span class="tooltip-container"></span>lower            ::=  ‘a’ | ... | ‘z’ | ‘_’ and any character in Unicode category Ll,
</span><span line-number="6" class=""><span class="tooltip-container"></span>                      and any character in Unicode categories Lo or Lm that has contributory
</span><span line-number="7" class=""><span class="tooltip-container"></span>                      property Other_Lowercase
</span><span line-number="8" class=""><span class="tooltip-container"></span>letter           ::=  upper | lower
</span><span line-number="9" class=""><span class="tooltip-container"></span>digit            ::=  ‘0’ | ... | ‘9’
</span><span line-number="10" class=""><span class="tooltip-container"></span>paren            ::=  ‘(’ | ‘)’ | ‘[’ | ‘]’ | ‘{’ | ‘}’
</span><span line-number="11" class=""><span class="tooltip-container"></span>delim            ::=  ‘`’ | ‘'’ | ‘"’ | ‘.’ | ‘;’ | ‘,’
</span><span line-number="12" class=""><span class="tooltip-container"></span>opchar           ::=  ‘!’ | ‘#’ | ‘%’ | ‘&amp;’ | ‘*’ | ‘+’ | ‘-’ | ‘/’ | ‘:’ |
</span><span line-number="13" class=""><span class="tooltip-container"></span>                      ‘&lt;’ | ‘=’ | ‘&gt;’ | ‘?’ | ‘@’ | ‘\’ | ‘^’ | ‘|’ | ‘~’
</span><span line-number="14" class=""><span class="tooltip-container"></span>                      and any character in Unicode categories Sm or So
</span><span line-number="15" class=""><span class="tooltip-container"></span>printableChar    ::=  all characters in [\u0020, \u007E] inclusive
</span><span line-number="16" class=""><span class="tooltip-container"></span>UnicodeEscape    ::=  ‘\’ ‘u’ {‘u’} hexDigit hexDigit hexDigit hexDigit
</span><span line-number="17" class=""><span class="tooltip-container"></span>hexDigit         ::=  ‘0’ | ... | ‘9’ | ‘A’ | ... | ‘F’ | ‘a’ | ... | ‘f’
</span><span line-number="18" class=""><span class="tooltip-container"></span>charEscapeSeq    ::=  ‘\’ (‘b’ | ‘t’ | ‘n’ | ‘f’ | ‘r’ | ‘"’ | ‘'’ | ‘\’)
</span><span line-number="19" class=""><span class="tooltip-container"></span>escapeSeq        ::=  UnicodeEscape | charEscapeSeq
</span><span line-number="20" class=""><span class="tooltip-container"></span>
</span><span line-number="21" class=""><span class="tooltip-container"></span>op               ::=  opchar {opchar}
</span><span line-number="22" class=""><span class="tooltip-container"></span>varid            ::=  lower idrest
</span><span line-number="23" class=""><span class="tooltip-container"></span>boundvarid       ::=  varid
</span><span line-number="24" class=""><span class="tooltip-container"></span>                   |  ‘`’ varid ‘`’
</span><span line-number="25" class=""><span class="tooltip-container"></span>plainid          ::=  alphaid
</span><span line-number="26" class=""><span class="tooltip-container"></span>                   |  op
</span><span line-number="27" class=""><span class="tooltip-container"></span>id               ::=  plainid
</span><span line-number="28" class=""><span class="tooltip-container"></span>                   |  ‘`’ { charNoBackQuoteOrNewline | escapeSeq } ‘`’
</span><span line-number="29" class=""><span class="tooltip-container"></span>idrest           ::=  {letter | digit} [‘_’ op]
</span><span line-number="30" class=""><span class="tooltip-container"></span>quoteId          ::=  ‘'’ alphaid
</span><span line-number="31" class=""><span class="tooltip-container"></span>spliceId         ::=  ‘$’ alphaid ;
</span><span line-number="32" class=""><span class="tooltip-container"></span>
</span><span line-number="33" class=""><span class="tooltip-container"></span>integerLiteral   ::=  (decimalNumeral | hexNumeral) [‘L’ | ‘l’]
</span><span line-number="34" class=""><span class="tooltip-container"></span>decimalNumeral   ::=  ‘0’ | digit [{digit | ‘_’} digit]
</span><span line-number="35" class=""><span class="tooltip-container"></span>hexNumeral       ::=  ‘0’ (‘x’ | ‘X’) hexDigit [{hexDigit | ‘_’} hexDigit]
</span><span line-number="36" class=""><span class="tooltip-container"></span>
</span><span line-number="37" class=""><span class="tooltip-container"></span>floatingPointLiteral
</span><span line-number="38" class=""><span class="tooltip-container"></span>                 ::=  [decimalNumeral] ‘.’ digit [{digit | ‘_’} digit] [exponentPart] [floatType]
</span><span line-number="39" class=""><span class="tooltip-container"></span>                   |  decimalNumeral exponentPart [floatType]
</span><span line-number="40" class=""><span class="tooltip-container"></span>                   |  decimalNumeral floatType
</span><span line-number="41" class=""><span class="tooltip-container"></span>exponentPart     ::=  (‘E’ | ‘e’) [‘+’ | ‘-’] digit [{digit | ‘_’} digit]
</span><span line-number="42" class=""><span class="tooltip-container"></span>floatType        ::=  ‘F’ | ‘f’ | ‘D’ | ‘d’
</span><span line-number="43" class=""><span class="tooltip-container"></span>
</span><span line-number="44" class=""><span class="tooltip-container"></span>booleanLiteral   ::=  ‘true’ | ‘false’
</span><span line-number="45" class=""><span class="tooltip-container"></span>
</span><span line-number="46" class=""><span class="tooltip-container"></span>characterLiteral ::=  ‘'’ (charNoQuoteOrNewline | escapeSeq) ‘'’
</span><span line-number="47" class=""><span class="tooltip-container"></span>
</span><span line-number="48" class=""><span class="tooltip-container"></span>stringLiteral    ::=  ‘"’ {stringElement} ‘"’
</span><span line-number="49" class=""><span class="tooltip-container"></span>                   |  ‘"""’ multiLineChars ‘"""’
</span><span line-number="50" class=""><span class="tooltip-container"></span>stringElement    ::=  charNoDoubleQuoteOrNewline
</span><span line-number="51" class=""><span class="tooltip-container"></span>                   |  escapeSeq
</span><span line-number="52" class=""><span class="tooltip-container"></span>multiLineChars   ::=  {[‘"’] [‘"’] charNoDoubleQuote} {‘"’}
</span><span line-number="53" class=""><span class="tooltip-container"></span>
</span><span line-number="54" class=""><span class="tooltip-container"></span>interpolatedString
</span><span line-number="55" class=""><span class="tooltip-container"></span>                 ::=  alphaid ‘"’ {[‘\’] interpolatedStringPart | ‘\\’ | ‘\"’} ‘"’
</span><span line-number="56" class=""><span class="tooltip-container"></span>                   |  alphaid ‘"""’ {[‘"’] [‘"’] char \ (‘"’ | ‘\$’) | escape} {‘"’} ‘"""’
</span><span line-number="57" class=""><span class="tooltip-container"></span>interpolatedStringPart
</span><span line-number="58" class=""><span class="tooltip-container"></span>                 ::= printableChar \ (‘"’ | ‘$’ | ‘\’) | escape
</span><span line-number="59" class=""><span class="tooltip-container"></span>escape           ::=  ‘\$\$’
</span><span line-number="60" class=""><span class="tooltip-container"></span>                   |  ‘\$"’
</span><span line-number="61" class=""><span class="tooltip-container"></span>                   |  ‘\$’ alphaid
</span><span line-number="62" class=""><span class="tooltip-container"></span>                   |  ‘\$’ BlockExpr
</span><span line-number="63" class=""><span class="tooltip-container"></span>alphaid          ::=  upper idrest
</span><span line-number="64" class=""><span class="tooltip-container"></span>                   |  varid
</span><span line-number="65" class=""><span class="tooltip-container"></span>
</span><span line-number="66" class=""><span class="tooltip-container"></span>comment          ::=  ‘/*’ “any sequence of characters; nested comments are allowed” ‘*/’
</span><span line-number="67" class=""><span class="tooltip-container"></span>                   |  ‘//’ “any sequence of characters up to end of line”
</span><span line-number="68" class=""><span class="tooltip-container"></span>
</span><span line-number="69" class=""><span class="tooltip-container"></span>nl               ::=  “new line character”
</span><span line-number="70" class=""><span class="tooltip-container"></span>semi             ::=  ‘;’ |  nl {nl}
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="optional-braces-3"> 
    <h2 class="h500"><a href="#optional-braces-3" class="anchor"></a>Optional Braces</h2> 
    <p>The principle of optional braces is that any keyword that can be followed by <code>{</code> can also be followed by an indented block, without needing an intervening <code>:</code>. (Allowing an optional <code>:</code> would be counterproductive since it would introduce several ways to do the same thing.)</p> 
    <p>The lexical analyzer inserts <code>indent</code> and <code>outdent</code> tokens that represent regions of indented code <a href="other-new-features/indentation.html">at certain points</a>.</p> 
    <p>In the context-free productions below we use the notation <code>&lt;&lt;&lt; ts &gt;&gt;&gt;</code> to indicate a token sequence <code>ts</code> that is either enclosed in a pair of braces <code>{ ts }</code> or that constitutes an indented region <code>indent ts outdent</code>. Analogously, the notation <code>:&lt;&lt;&lt; ts &gt;&gt;&gt;</code> indicates a token sequence <code>ts</code> that is either enclosed in a pair of braces <code>{ ts }</code> or that constitutes an indented region <code>indent ts outdent</code> that follows a <code>colon</code> token.</p> 
    <p>A <code>colon</code> token reads as the standard colon "<code>:</code>" but is generated instead of it where <code>colon</code> is legal according to the context free syntax, but only if the previous token is an alphanumeric identifier, a backticked identifier, or one of the tokens <code>this</code>, <code>super</code>, <code>new</code>, "<code>)</code>", and "<code>]</code>".</p> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>colon         ::=  ':'    -- with side conditions explained above
</span><span line-number="2" class=""><span class="tooltip-container"></span> &lt;&lt;&lt; ts &gt;&gt;&gt;   ::=  ‘{’ ts ‘}’
</span><span line-number="3" class=""><span class="tooltip-container"></span>                |  indent ts outdent
</span><span line-number="4" class=""><span class="tooltip-container"></span>:&lt;&lt;&lt; ts &gt;&gt;&gt;   ::=  [nl] ‘{’ ts ‘}’
</span><span line-number="5" class=""><span class="tooltip-container"></span>                |  colon indent ts outdent
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="keywords-1"> 
    <h2 class="h500"><a href="#keywords-1" class="anchor"></a>Keywords</h2> 
   </section> 
   <section id="regular-keywords-1"> 
    <h3 class="h400"><a href="#regular-keywords-1" class="anchor"></a>Regular keywords</h3> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>abstract  case      catch     class     def       do        else
</span><span line-number="2" class=""><span class="tooltip-container"></span>enum      export    extends   false     final     finally   for
</span><span line-number="3" class=""><span class="tooltip-container"></span>given     if        implicit  import    lazy      match     new
</span><span line-number="4" class=""><span class="tooltip-container"></span>null      object    override  package   private   protected return
</span><span line-number="5" class=""><span class="tooltip-container"></span>sealed    super     then      throw     trait     true      try
</span><span line-number="6" class=""><span class="tooltip-container"></span>type      val       var       while     with      yield
</span><span line-number="7" class=""><span class="tooltip-container"></span>:         =         &lt;-        =&gt;        &lt;:        &gt;:        #
</span><span line-number="8" class=""><span class="tooltip-container"></span>@         =&gt;&gt;       ?=&gt;
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="soft-keywords-1"> 
    <h3 class="h400"><a href="#soft-keywords-1" class="anchor"></a>Soft keywords</h3> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>as  derives  end  extension  infix  inline  opaque  open  transparent  using  |  *  +  -
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>See the <a href="soft-modifier.html">separate section on soft keywords</a> for additional details on where a soft keyword is recognized.</p> 
   </section> 
   <section id="context-free-syntax-1"> 
    <h2 class="h500"><a href="#context-free-syntax-1" class="anchor"></a>Context-free Syntax</h2> 
    <p>The context-free syntax of Scala is given by the following EBNF grammar:</p> 
   </section> 
   <section id="literals-and-paths-1"> 
    <h3 class="h400"><a href="#literals-and-paths-1" class="anchor"></a>Literals and Paths</h3> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>SimpleLiteral     ::=  [‘-’] integerLiteral
</span><span line-number="2" class=""><span class="tooltip-container"></span>                    |  [‘-’] floatingPointLiteral
</span><span line-number="3" class=""><span class="tooltip-container"></span>                    |  booleanLiteral
</span><span line-number="4" class=""><span class="tooltip-container"></span>                    |  characterLiteral
</span><span line-number="5" class=""><span class="tooltip-container"></span>                    |  stringLiteral
</span><span line-number="6" class=""><span class="tooltip-container"></span>Literal           ::=  SimpleLiteral
</span><span line-number="7" class=""><span class="tooltip-container"></span>                    |  interpolatedStringLiteral
</span><span line-number="8" class=""><span class="tooltip-container"></span>                    |  symbolLiteral
</span><span line-number="9" class=""><span class="tooltip-container"></span>                    |  ‘null’
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>QualId            ::=  id {‘.’ id}
</span><span line-number="12" class=""><span class="tooltip-container"></span>ids               ::=  id {‘,’ id}
</span><span line-number="13" class=""><span class="tooltip-container"></span>
</span><span line-number="14" class=""><span class="tooltip-container"></span>SimpleRef         ::=  id
</span><span line-number="15" class=""><span class="tooltip-container"></span>                    |  [id ‘.’] ‘this’
</span><span line-number="16" class=""><span class="tooltip-container"></span>                    |  [id ‘.’] ‘super’ [ClassQualifier] ‘.’ id
</span><span line-number="17" class=""><span class="tooltip-container"></span>
</span><span line-number="18" class=""><span class="tooltip-container"></span>ClassQualifier    ::=  ‘[’ id ‘]’
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="types-1"> 
    <h3 class="h400"><a href="#types-1" class="anchor"></a>Types</h3> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>Type              ::=  FunType
</span><span line-number="2" class=""><span class="tooltip-container"></span>                    |  HkTypeParamClause ‘=&gt;&gt;’ Type
</span><span line-number="3" class=""><span class="tooltip-container"></span>                    |  FunParamClause ‘=&gt;&gt;’ Type
</span><span line-number="4" class=""><span class="tooltip-container"></span>                    |  MatchType
</span><span line-number="5" class=""><span class="tooltip-container"></span>                    |  InfixType
</span><span line-number="6" class=""><span class="tooltip-container"></span>FunType           ::=  FunTypeArgs (‘=&gt;’ | ‘?=&gt;’) Type
</span><span line-number="7" class=""><span class="tooltip-container"></span>                    |  HKTypeParamClause '=&gt;' Type
</span><span line-number="8" class=""><span class="tooltip-container"></span>FunTypeArgs       ::=  InfixType
</span><span line-number="9" class=""><span class="tooltip-container"></span>                    |  ‘(’ [ FunArgTypes ] ‘)’
</span><span line-number="10" class=""><span class="tooltip-container"></span>                    |  FunParamClause
</span><span line-number="11" class=""><span class="tooltip-container"></span>FunParamClause    ::=  ‘(’ TypedFunParam {‘,’ TypedFunParam } ‘)’
</span><span line-number="12" class=""><span class="tooltip-container"></span>TypedFunParam     ::=  id ‘:’ Type
</span><span line-number="13" class=""><span class="tooltip-container"></span>MatchType         ::=  InfixType `match` &lt;&lt;&lt; TypeCaseClauses &gt;&gt;&gt;
</span><span line-number="14" class=""><span class="tooltip-container"></span>InfixType         ::=  RefinedType {id [nl] RefinedType}
</span><span line-number="15" class=""><span class="tooltip-container"></span>RefinedType       ::=  AnnotType {[nl] Refinement}
</span><span line-number="16" class=""><span class="tooltip-container"></span>AnnotType         ::=  SimpleType {Annotation}
</span><span line-number="17" class=""><span class="tooltip-container"></span>
</span><span line-number="18" class=""><span class="tooltip-container"></span>SimpleType        ::=  SimpleLiteral
</span><span line-number="19" class=""><span class="tooltip-container"></span>                    |  ‘?’ TypeBounds
</span><span line-number="20" class=""><span class="tooltip-container"></span>                    |  id
</span><span line-number="21" class=""><span class="tooltip-container"></span>                    |  Singleton ‘.’ id
</span><span line-number="22" class=""><span class="tooltip-container"></span>                    |  Singleton ‘.’ ‘type’
</span><span line-number="23" class=""><span class="tooltip-container"></span>                    |  ‘(’ Types ‘)’
</span><span line-number="24" class=""><span class="tooltip-container"></span>                    |  Refinement
</span><span line-number="25" class=""><span class="tooltip-container"></span>                    |  SimpleType1 TypeArgs
</span><span line-number="26" class=""><span class="tooltip-container"></span>                    |  SimpleType1 ‘#’ id
</span><span line-number="27" class=""><span class="tooltip-container"></span>Singleton         ::=  SimpleRef
</span><span line-number="28" class=""><span class="tooltip-container"></span>                    |  SimpleLiteral
</span><span line-number="29" class=""><span class="tooltip-container"></span>                    |  Singleton ‘.’ id
</span><span line-number="30" class=""><span class="tooltip-container"></span>
</span><span line-number="31" class=""><span class="tooltip-container"></span>FunArgType        ::=  Type
</span><span line-number="32" class=""><span class="tooltip-container"></span>                    |  ‘=&gt;’ Type
</span><span line-number="33" class=""><span class="tooltip-container"></span>FunArgTypes       ::=  FunArgType { ‘,’ FunArgType }
</span><span line-number="34" class=""><span class="tooltip-container"></span>ParamType         ::=  [‘=&gt;’] ParamValueType
</span><span line-number="35" class=""><span class="tooltip-container"></span>ParamValueType    ::=  Type [‘*’]
</span><span line-number="36" class=""><span class="tooltip-container"></span>TypeArgs          ::=  ‘[’ Types ‘]’
</span><span line-number="37" class=""><span class="tooltip-container"></span>Refinement        ::=  :&lt;&lt;&lt; [RefineDcl] {semi [RefineDcl]} &gt;&gt;&gt;
</span><span line-number="38" class=""><span class="tooltip-container"></span>TypeBounds        ::=  [‘&gt;:’ Type] [‘&lt;:’ Type]
</span><span line-number="39" class=""><span class="tooltip-container"></span>TypeParamBounds   ::=  TypeBounds {‘:’ Type}
</span><span line-number="40" class=""><span class="tooltip-container"></span>Types             ::=  Type {‘,’ Type}
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="expressions-1"> 
    <h3 class="h400"><a href="#expressions-1" class="anchor"></a>Expressions</h3> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>Expr              ::=  FunParams (‘=&gt;’ | ‘?=&gt;’) Expr
</span><span line-number="2" class=""><span class="tooltip-container"></span>                    |  HkTypeParamClause ‘=&gt;’ Expr
</span><span line-number="3" class=""><span class="tooltip-container"></span>                    |  Expr1
</span><span line-number="4" class=""><span class="tooltip-container"></span>BlockResult       ::=  FunParams (‘=&gt;’ | ‘?=&gt;’) Block
</span><span line-number="5" class=""><span class="tooltip-container"></span>                    |  HkTypeParamClause ‘=&gt;’ Block
</span><span line-number="6" class=""><span class="tooltip-container"></span>                    |  Expr1
</span><span line-number="7" class=""><span class="tooltip-container"></span>FunParams         ::=  Bindings
</span><span line-number="8" class=""><span class="tooltip-container"></span>                    |  id
</span><span line-number="9" class=""><span class="tooltip-container"></span>                    |  ‘_’
</span><span line-number="10" class=""><span class="tooltip-container"></span>Expr1             ::=  [‘inline’] ‘if’ ‘(’ Expr ‘)’ {nl} Expr [[semi] ‘else’ Expr]
</span><span line-number="11" class=""><span class="tooltip-container"></span>                    |  [‘inline’] ‘if’  Expr ‘then’ Expr [[semi] ‘else’ Expr]
</span><span line-number="12" class=""><span class="tooltip-container"></span>                    |  ‘while’ ‘(’ Expr ‘)’ {nl} Expr
</span><span line-number="13" class=""><span class="tooltip-container"></span>                    |  ‘while’ Expr ‘do’ Expr
</span><span line-number="14" class=""><span class="tooltip-container"></span>                    |  ‘try’ Expr Catches [‘finally’ Expr]
</span><span line-number="15" class=""><span class="tooltip-container"></span>                    |  ‘try’ Expr [‘finally’ Expr]
</span><span line-number="16" class=""><span class="tooltip-container"></span>                    |  ‘throw’ Expr
</span><span line-number="17" class=""><span class="tooltip-container"></span>                    |  ‘return’ [Expr]
</span><span line-number="18" class=""><span class="tooltip-container"></span>                    |  ForExpr
</span><span line-number="19" class=""><span class="tooltip-container"></span>                    |  [SimpleExpr ‘.’] id ‘=’ Expr
</span><span line-number="20" class=""><span class="tooltip-container"></span>                    |  PrefixOperator SimpleExpr ‘=’ Expr
</span><span line-number="21" class=""><span class="tooltip-container"></span>                    |  SimpleExpr ArgumentExprs ‘=’ Expr
</span><span line-number="22" class=""><span class="tooltip-container"></span>                    |  PostfixExpr [Ascription]
</span><span line-number="23" class=""><span class="tooltip-container"></span>                    |  ‘inline’ InfixExpr MatchClause
</span><span line-number="24" class=""><span class="tooltip-container"></span>Ascription        ::=  ‘:’ InfixType
</span><span line-number="25" class=""><span class="tooltip-container"></span>                    |  ‘:’ Annotation {Annotation}
</span><span line-number="26" class=""><span class="tooltip-container"></span>Catches           ::=  ‘catch’ (Expr | ExprCaseClause)
</span><span line-number="27" class=""><span class="tooltip-container"></span>PostfixExpr       ::=  InfixExpr [id]                                          -- only if language.postfixOperators is enabled
</span><span line-number="28" class=""><span class="tooltip-container"></span>InfixExpr         ::=  PrefixExpr
</span><span line-number="29" class=""><span class="tooltip-container"></span>                    |  InfixExpr id [nl] InfixExpr
</span><span line-number="30" class=""><span class="tooltip-container"></span>                    |  InfixExpr id ColonArgument
</span><span line-number="31" class=""><span class="tooltip-container"></span>                    |  InfixExpr MatchClause
</span><span line-number="32" class=""><span class="tooltip-container"></span>MatchClause       ::=  ‘match’ &lt;&lt;&lt; CaseClauses &gt;&gt;&gt;
</span><span line-number="33" class=""><span class="tooltip-container"></span>PrefixExpr        ::=  [PrefixOperator] SimpleExpr
</span><span line-number="34" class=""><span class="tooltip-container"></span>PrefixOperator    ::=  ‘-’ | ‘+’ | ‘~’ | ‘!’                                    -- unless backquoted
</span><span line-number="35" class=""><span class="tooltip-container"></span>SimpleExpr        ::=  SimpleRef
</span><span line-number="36" class=""><span class="tooltip-container"></span>                    |  Literal
</span><span line-number="37" class=""><span class="tooltip-container"></span>                    |  ‘_’
</span><span line-number="38" class=""><span class="tooltip-container"></span>                    |  BlockExpr
</span><span line-number="39" class=""><span class="tooltip-container"></span>                    |  ExprSplice
</span><span line-number="40" class=""><span class="tooltip-container"></span>                    |  Quoted
</span><span line-number="41" class=""><span class="tooltip-container"></span>                    |  quoteId                                                  -- only inside splices
</span><span line-number="42" class=""><span class="tooltip-container"></span>                    |  ‘new’ ConstrApp {‘with’ ConstrApp} [TemplateBody]
</span><span line-number="43" class=""><span class="tooltip-container"></span>                    |  ‘new’ TemplateBody
</span><span line-number="44" class=""><span class="tooltip-container"></span>                    |  ‘(’ ExprsInParens ‘)’
</span><span line-number="45" class=""><span class="tooltip-container"></span>                    |  SimpleExpr ‘.’ id
</span><span line-number="46" class=""><span class="tooltip-container"></span>                    |  SimpleExpr ‘.’ MatchClause
</span><span line-number="47" class=""><span class="tooltip-container"></span>                    |  SimpleExpr TypeArgs
</span><span line-number="48" class=""><span class="tooltip-container"></span>                    |  SimpleExpr ArgumentExprs
</span><span line-number="49" class=""><span class="tooltip-container"></span>                    |  SimpleExpr ColonArgument
</span><span line-number="50" class=""><span class="tooltip-container"></span>ColonArgument     ::=  colon [LambdaStart]
</span><span line-number="51" class=""><span class="tooltip-container"></span>                       indent (CaseClauses | Block) outdent
</span><span line-number="52" class=""><span class="tooltip-container"></span>LambdaStart       ::=  FunParams (‘=&gt;’ | ‘?=&gt;’)
</span><span line-number="53" class=""><span class="tooltip-container"></span>                    |  HkTypeParamClause ‘=&gt;’
</span><span line-number="54" class=""><span class="tooltip-container"></span>Quoted            ::=  ‘'’ ‘{’ Block ‘}’
</span><span line-number="55" class=""><span class="tooltip-container"></span>                    |  ‘'’ ‘[’ Type ‘]’
</span><span line-number="56" class=""><span class="tooltip-container"></span>ExprSplice        ::= spliceId                                                  -- if inside quoted block
</span><span line-number="57" class=""><span class="tooltip-container"></span>                    |  ‘$’ ‘{’ Block ‘}’                                        -- unless inside quoted pattern
</span><span line-number="58" class=""><span class="tooltip-container"></span>                    |  ‘$’ ‘{’ Pattern ‘}’                                      -- when inside quoted pattern
</span><span line-number="59" class=""><span class="tooltip-container"></span>ExprsInParens     ::=  ExprInParens {‘,’ ExprInParens}
</span><span line-number="60" class=""><span class="tooltip-container"></span>ExprInParens      ::=  PostfixExpr ‘:’ Type
</span><span line-number="61" class=""><span class="tooltip-container"></span>                    |  Expr
</span><span line-number="62" class=""><span class="tooltip-container"></span>ParArgumentExprs  ::=  ‘(’ [ExprsInParens] ‘)’
</span><span line-number="63" class=""><span class="tooltip-container"></span>                    |  ‘(’ ‘using’ ExprsInParens ‘)’
</span><span line-number="64" class=""><span class="tooltip-container"></span>                    |  ‘(’ [ExprsInParens ‘,’] PostfixExpr ‘*’ ‘)’
</span><span line-number="65" class=""><span class="tooltip-container"></span>ArgumentExprs     ::=  ParArgumentExprs
</span><span line-number="66" class=""><span class="tooltip-container"></span>                    |  BlockExpr
</span><span line-number="67" class=""><span class="tooltip-container"></span>BlockExpr         ::=  &lt;&lt;&lt; (CaseClauses | Block) &gt;&gt;&gt;
</span><span line-number="68" class=""><span class="tooltip-container"></span>Block             ::=  {BlockStat semi} [BlockResult]
</span><span line-number="69" class=""><span class="tooltip-container"></span>BlockStat         ::=  Import
</span><span line-number="70" class=""><span class="tooltip-container"></span>                    |  {Annotation {nl}} {LocalModifier} Def
</span><span line-number="71" class=""><span class="tooltip-container"></span>                    |  Extension
</span><span line-number="72" class=""><span class="tooltip-container"></span>                    |  Expr1
</span><span line-number="73" class=""><span class="tooltip-container"></span>                    |  EndMarker
</span><span line-number="74" class=""><span class="tooltip-container"></span>
</span><span line-number="75" class=""><span class="tooltip-container"></span>ForExpr           ::=  ‘for’ ‘(’ Enumerators0 ‘)’ {nl} [‘do‘ | ‘yield’] Expr
</span><span line-number="76" class=""><span class="tooltip-container"></span>                    |  ‘for’ ‘{’ Enumerators0 ‘}’ {nl} [‘do‘ | ‘yield’] Expr
</span><span line-number="77" class=""><span class="tooltip-container"></span>                    |  ‘for’     Enumerators0          (‘do‘ | ‘yield’) Expr
</span><span line-number="78" class=""><span class="tooltip-container"></span>Enumerators0      ::=  {nl} Enumerators [semi]
</span><span line-number="79" class=""><span class="tooltip-container"></span>Enumerators       ::=  Generator {semi Enumerator | Guard}
</span><span line-number="80" class=""><span class="tooltip-container"></span>Enumerator        ::=  Generator
</span><span line-number="81" class=""><span class="tooltip-container"></span>                    |  Guard {Guard}
</span><span line-number="82" class=""><span class="tooltip-container"></span>                    |  Pattern1 ‘=’ Expr
</span><span line-number="83" class=""><span class="tooltip-container"></span>Generator         ::=  [‘case’] Pattern1 ‘&lt;-’ Expr
</span><span line-number="84" class=""><span class="tooltip-container"></span>Guard             ::=  ‘if’ PostfixExpr
</span><span line-number="85" class=""><span class="tooltip-container"></span>
</span><span line-number="86" class=""><span class="tooltip-container"></span>CaseClauses       ::=  CaseClause { CaseClause }
</span><span line-number="87" class=""><span class="tooltip-container"></span>CaseClause        ::=  ‘case’ Pattern [Guard] ‘=&gt;’ Block
</span><span line-number="88" class=""><span class="tooltip-container"></span>ExprCaseClause    ::=  ‘case’ Pattern [Guard] ‘=&gt;’ Expr
</span><span line-number="89" class=""><span class="tooltip-container"></span>TypeCaseClauses   ::=  TypeCaseClause { TypeCaseClause }
</span><span line-number="90" class=""><span class="tooltip-container"></span>TypeCaseClause    ::=  ‘case’ (InfixType | ‘_’) ‘=&gt;’ Type [semi]
</span><span line-number="91" class=""><span class="tooltip-container"></span>
</span><span line-number="92" class=""><span class="tooltip-container"></span>Pattern           ::=  Pattern1 { ‘|’ Pattern1 }
</span><span line-number="93" class=""><span class="tooltip-container"></span>Pattern1          ::=  PatVar ‘:’ RefinedType
</span><span line-number="94" class=""><span class="tooltip-container"></span>                    | [‘-’] integerLiteral ‘:’ RefinedType
</span><span line-number="95" class=""><span class="tooltip-container"></span>                    | [‘-’] floatingPointLiteral ‘:’ RefinedType
</span><span line-number="96" class=""><span class="tooltip-container"></span>                    |  Pattern2
</span><span line-number="97" class=""><span class="tooltip-container"></span>Pattern2          ::=  [id ‘@’] InfixPattern [‘*’]
</span><span line-number="98" class=""><span class="tooltip-container"></span>InfixPattern      ::=  SimplePattern { id [nl] SimplePattern }
</span><span line-number="99" class=""><span class="tooltip-container"></span>SimplePattern     ::=  PatVar
</span><span line-number="100" class=""><span class="tooltip-container"></span>                    |  Literal
</span><span line-number="101" class=""><span class="tooltip-container"></span>                    |  ‘(’ [Patterns] ‘)’
</span><span line-number="102" class=""><span class="tooltip-container"></span>                    |  Quoted
</span><span line-number="103" class=""><span class="tooltip-container"></span>                    |  SimplePattern1 [TypeArgs] [ArgumentPatterns]
</span><span line-number="104" class=""><span class="tooltip-container"></span>                    |  ‘given’ RefinedType
</span><span line-number="105" class=""><span class="tooltip-container"></span>SimplePattern1    ::=  SimpleRef
</span><span line-number="106" class=""><span class="tooltip-container"></span>                    |  SimplePattern1 ‘.’ id
</span><span line-number="107" class=""><span class="tooltip-container"></span>PatVar            ::=  varid
</span><span line-number="108" class=""><span class="tooltip-container"></span>                    |  ‘_’
</span><span line-number="109" class=""><span class="tooltip-container"></span>Patterns          ::=  Pattern {‘,’ Pattern}
</span><span line-number="110" class=""><span class="tooltip-container"></span>ArgumentPatterns  ::=  ‘(’ [Patterns] ‘)’
</span><span line-number="111" class=""><span class="tooltip-container"></span>                    |  ‘(’ [Patterns ‘,’] PatVar ‘*’ ‘)’
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="type-and-value-parameters-1"> 
    <h3 class="h400"><a href="#type-and-value-parameters-1" class="anchor"></a>Type and Value Parameters</h3> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>ClsTypeParamClause::=  ‘[’ ClsTypeParam {‘,’ ClsTypeParam} ‘]’
</span><span line-number="2" class=""><span class="tooltip-container"></span>ClsTypeParam      ::=  {Annotation} [‘+’ | ‘-’] id [HkTypeParamClause] TypeParamBounds
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>TypTypeParamClause::=  ‘[’ TypTypeParam {‘,’ TypTypeParam} ‘]’
</span><span line-number="5" class=""><span class="tooltip-container"></span>TypTypeParam      ::=  {Annotation} id [HkTypeParamClause] TypeBounds
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>HkTypeParamClause ::=  ‘[’ HkTypeParam {‘,’ HkTypeParam} ‘]’
</span><span line-number="8" class=""><span class="tooltip-container"></span>HkTypeParam       ::=  {Annotation} [‘+’ | ‘-’] (id [HkTypeParamClause] | ‘_’) TypeBounds
</span><span line-number="9" class=""><span class="tooltip-container"></span>
</span><span line-number="10" class=""><span class="tooltip-container"></span>ClsParamClauses   ::=  {ClsParamClause} [[nl] ‘(’ [‘implicit’] ClsParams ‘)’]
</span><span line-number="11" class=""><span class="tooltip-container"></span>ClsParamClause    ::=  [nl] ‘(’ ClsParams ‘)’
</span><span line-number="12" class=""><span class="tooltip-container"></span>                    |  [nl] ‘(’ ‘using’ (ClsParams | FunArgTypes) ‘)’
</span><span line-number="13" class=""><span class="tooltip-container"></span>ClsParams         ::=  ClsParam {‘,’ ClsParam}
</span><span line-number="14" class=""><span class="tooltip-container"></span>ClsParam          ::=  {Annotation} [{Modifier} (‘val’ | ‘var’) | ‘inline’] Param
</span><span line-number="15" class=""><span class="tooltip-container"></span>
</span><span line-number="16" class=""><span class="tooltip-container"></span>TypelessClauses   ::=  TypelessClause {TypelessClause}
</span><span line-number="17" class=""><span class="tooltip-container"></span>TypelessClause    ::=  DefTermParamClause
</span><span line-number="18" class=""><span class="tooltip-container"></span>                    |  UsingParamClause
</span><span line-number="19" class=""><span class="tooltip-container"></span>
</span><span line-number="20" class=""><span class="tooltip-container"></span>DefTypeParamClause::=  [nl] ‘[’ DefTypeParam {‘,’ DefTypeParam} ‘]’
</span><span line-number="21" class=""><span class="tooltip-container"></span>DefTypeParam      ::=  {Annotation} id [HkTypeParamClause] TypeParamBounds
</span><span line-number="22" class=""><span class="tooltip-container"></span>DefTermParamClause::=  [nl] ‘(’ [DefTermParams] ‘)’
</span><span line-number="23" class=""><span class="tooltip-container"></span>UsingParamClause  ::=  [nl] ‘(’ ‘using’ (DefTermParams | FunArgTypes) ‘)’
</span><span line-number="24" class=""><span class="tooltip-container"></span>DefImplicitClause ::=  [nl] ‘(’ ‘implicit’ DefTermParams ‘)’
</span><span line-number="25" class=""><span class="tooltip-container"></span>
</span><span line-number="26" class=""><span class="tooltip-container"></span>DefTermParams     ::= DefTermParam {‘,’ DefTermParam}
</span><span line-number="27" class=""><span class="tooltip-container"></span>DefTermParam      ::= {Annotation} [‘inline’] Param
</span><span line-number="28" class=""><span class="tooltip-container"></span>Param             ::=  id ‘:’ ParamType [‘=’ Expr]
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="bindings-and-imports-1"> 
    <h3 class="h400"><a href="#bindings-and-imports-1" class="anchor"></a>Bindings and Imports</h3> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>Bindings          ::=  ‘(’ [Binding {‘,’ Binding}] ‘)’
</span><span line-number="2" class=""><span class="tooltip-container"></span>Binding           ::=  (id | ‘_’) [‘:’ Type]
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>Modifier          ::=  LocalModifier
</span><span line-number="5" class=""><span class="tooltip-container"></span>                    |  AccessModifier
</span><span line-number="6" class=""><span class="tooltip-container"></span>                    |  ‘override’
</span><span line-number="7" class=""><span class="tooltip-container"></span>                    |  ‘opaque’
</span><span line-number="8" class=""><span class="tooltip-container"></span>LocalModifier     ::=  ‘abstract’
</span><span line-number="9" class=""><span class="tooltip-container"></span>                    |  ‘final’
</span><span line-number="10" class=""><span class="tooltip-container"></span>                    |  ‘sealed’
</span><span line-number="11" class=""><span class="tooltip-container"></span>                    |  ‘open’
</span><span line-number="12" class=""><span class="tooltip-container"></span>                    |  ‘implicit’
</span><span line-number="13" class=""><span class="tooltip-container"></span>                    |  ‘lazy’
</span><span line-number="14" class=""><span class="tooltip-container"></span>                    |  ‘inline’
</span><span line-number="15" class=""><span class="tooltip-container"></span>AccessModifier    ::=  (‘private’ | ‘protected’) [AccessQualifier]
</span><span line-number="16" class=""><span class="tooltip-container"></span>AccessQualifier   ::=  ‘[’ id ‘]’
</span><span line-number="17" class=""><span class="tooltip-container"></span>
</span><span line-number="18" class=""><span class="tooltip-container"></span>Annotation        ::=  ‘@’ SimpleType1 {ParArgumentExprs}
</span><span line-number="19" class=""><span class="tooltip-container"></span>
</span><span line-number="20" class=""><span class="tooltip-container"></span>Import            ::=  ‘import’ ImportExpr {‘,’ ImportExpr}
</span><span line-number="21" class=""><span class="tooltip-container"></span>Export            ::=  ‘export’ ImportExpr {‘,’ ImportExpr}
</span><span line-number="22" class=""><span class="tooltip-container"></span>ImportExpr        ::=  SimpleRef {‘.’ id} ‘.’ ImportSpec
</span><span line-number="23" class=""><span class="tooltip-container"></span>                    |  SimpleRef ‘as’ id
</span><span line-number="24" class=""><span class="tooltip-container"></span>ImportSpec        ::=  NamedSelector
</span><span line-number="25" class=""><span class="tooltip-container"></span>                    |  WildcardSelector
</span><span line-number="26" class=""><span class="tooltip-container"></span>                    | ‘{’ ImportSelectors) ‘}’
</span><span line-number="27" class=""><span class="tooltip-container"></span>NamedSelector     ::=  id [‘as’ (id | ‘_’)]
</span><span line-number="28" class=""><span class="tooltip-container"></span>WildCardSelector  ::=  ‘*' | ‘given’ [InfixType]
</span><span line-number="29" class=""><span class="tooltip-container"></span>ImportSelectors   ::=  NamedSelector [‘,’ ImportSelectors]
</span><span line-number="30" class=""><span class="tooltip-container"></span>                    |  WildCardSelector {‘,’ WildCardSelector}
</span><span line-number="31" class=""><span class="tooltip-container"></span>
</span><span line-number="32" class=""><span class="tooltip-container"></span>EndMarker         ::=  ‘end’ EndMarkerTag    -- when followed by EOL
</span><span line-number="33" class=""><span class="tooltip-container"></span>EndMarkerTag      ::=  id | ‘if’ | ‘while’ | ‘for’ | ‘match’ | ‘try’
</span><span line-number="34" class=""><span class="tooltip-container"></span>                    |  ‘new’ | ‘this’ | ‘given’ | ‘extension’ | ‘val’
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="declarations-and-definitions-1"> 
    <h3 class="h400"><a href="#declarations-and-definitions-1" class="anchor"></a>Declarations and Definitions</h3> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>RefineDcl         ::=  ‘val’ ValDcl
</span><span line-number="2" class=""><span class="tooltip-container"></span>                    |  ‘def’ DefDcl
</span><span line-number="3" class=""><span class="tooltip-container"></span>                    |  ‘type’ {nl} TypeDcl
</span><span line-number="4" class=""><span class="tooltip-container"></span>Dcl               ::=  RefineDcl
</span><span line-number="5" class=""><span class="tooltip-container"></span>                    |  ‘var’ VarDcl
</span><span line-number="6" class=""><span class="tooltip-container"></span>ValDcl            ::=  ids ‘:’ Type
</span><span line-number="7" class=""><span class="tooltip-container"></span>VarDcl            ::=  ids ‘:’ Type
</span><span line-number="8" class=""><span class="tooltip-container"></span>DefDcl            ::=  DefSig ‘:’ Type
</span><span line-number="9" class=""><span class="tooltip-container"></span>DefSig            ::=  id [DefTypeParamClause] [TypelessClauses] [DefImplicitClause]
</span><span line-number="10" class=""><span class="tooltip-container"></span>TypeDcl           ::=  id [TypeParamClause] {FunParamClause} TypeBounds
</span><span line-number="11" class=""><span class="tooltip-container"></span>
</span><span line-number="12" class=""><span class="tooltip-container"></span>Def               ::=  ‘val’ PatDef
</span><span line-number="13" class=""><span class="tooltip-container"></span>                    |  ‘var’ PatDef
</span><span line-number="14" class=""><span class="tooltip-container"></span>                    |  ‘def’ DefDef
</span><span line-number="15" class=""><span class="tooltip-container"></span>                    |  ‘type’ {nl} TypeDcl
</span><span line-number="16" class=""><span class="tooltip-container"></span>                    |  TmplDef
</span><span line-number="17" class=""><span class="tooltip-container"></span>PatDef            ::=  ids [‘:’ Type] ‘=’ Expr
</span><span line-number="18" class=""><span class="tooltip-container"></span>                    |  Pattern2 [‘:’ Type] ‘=’ Expr
</span><span line-number="19" class=""><span class="tooltip-container"></span>DefDef            ::=  DefSig [‘:’ Type] ‘=’ Expr
</span><span line-number="20" class=""><span class="tooltip-container"></span>                    |  ‘this’ TypelessClauses [DefImplicitClause] ‘=’ ConstrExpr
</span><span line-number="21" class=""><span class="tooltip-container"></span>
</span><span line-number="22" class=""><span class="tooltip-container"></span>TmplDef           ::=  ([‘case’] ‘class’ | ‘trait’) ClassDef
</span><span line-number="23" class=""><span class="tooltip-container"></span>                    |  [‘case’] ‘object’ ObjectDef
</span><span line-number="24" class=""><span class="tooltip-container"></span>                    |  ‘enum’ EnumDef
</span><span line-number="25" class=""><span class="tooltip-container"></span>                    |  ‘given’ GivenDef
</span><span line-number="26" class=""><span class="tooltip-container"></span>ClassDef          ::=  id ClassConstr [Template]
</span><span line-number="27" class=""><span class="tooltip-container"></span>ClassConstr       ::=  [ClsTypeParamClause] [ConstrMods] ClsParamClauses
</span><span line-number="28" class=""><span class="tooltip-container"></span>ConstrMods        ::=  {Annotation} [AccessModifier]
</span><span line-number="29" class=""><span class="tooltip-container"></span>ObjectDef         ::=  id [Template]
</span><span line-number="30" class=""><span class="tooltip-container"></span>EnumDef           ::=  id ClassConstr InheritClauses EnumBody
</span><span line-number="31" class=""><span class="tooltip-container"></span>GivenDef          ::=  [GivenSig] (AnnotType [‘=’ Expr] | StructuralInstance)
</span><span line-number="32" class=""><span class="tooltip-container"></span>GivenSig          ::=  [id] [DefTypeParamClause] {UsingParamClause} ‘:’         -- one of `id`, `DefTypeParamClause`, `UsingParamClause` must be present
</span><span line-number="33" class=""><span class="tooltip-container"></span>StructuralInstance ::=  ConstrApp {‘with’ ConstrApp} [‘with’ WithTemplateBody]
</span><span line-number="34" class=""><span class="tooltip-container"></span>Extension         ::=  ‘extension’ [DefTypeParamClause] {UsingParamClause}
</span><span line-number="35" class=""><span class="tooltip-container"></span>                       ‘(’ DefTermParam ‘)’ {UsingParamClause} ExtMethods
</span><span line-number="36" class=""><span class="tooltip-container"></span>ExtMethods        ::=  ExtMethod | [nl] &lt;&lt;&lt; ExtMethod {semi ExtMethod} &gt;&gt;&gt;
</span><span line-number="37" class=""><span class="tooltip-container"></span>ExtMethod         ::=  {Annotation [nl]} {Modifier} ‘def’ DefDef
</span><span line-number="38" class=""><span class="tooltip-container"></span>                    |  Export
</span><span line-number="39" class=""><span class="tooltip-container"></span>Template          ::=  InheritClauses [TemplateBody]
</span><span line-number="40" class=""><span class="tooltip-container"></span>InheritClauses    ::=  [‘extends’ ConstrApps] [‘derives’ QualId {‘,’ QualId}]
</span><span line-number="41" class=""><span class="tooltip-container"></span>ConstrApps        ::=  ConstrApp ({‘,’ ConstrApp} | {‘with’ ConstrApp})
</span><span line-number="42" class=""><span class="tooltip-container"></span>ConstrApp         ::=  SimpleType1 {Annotation} {ParArgumentExprs}
</span><span line-number="43" class=""><span class="tooltip-container"></span>ConstrExpr        ::=  SelfInvocation
</span><span line-number="44" class=""><span class="tooltip-container"></span>                    |  &lt;&lt;&lt; SelfInvocation {semi BlockStat} &gt;&gt;&gt;
</span><span line-number="45" class=""><span class="tooltip-container"></span>SelfInvocation    ::=  ‘this’ ArgumentExprs {ArgumentExprs}
</span><span line-number="46" class=""><span class="tooltip-container"></span>
</span><span line-number="47" class=""><span class="tooltip-container"></span>WithTemplateBody  ::=  &lt;&lt;&lt; [SelfType] TemplateStat {semi TemplateStat} &gt;&gt;&gt;
</span><span line-number="48" class=""><span class="tooltip-container"></span>TemplateBody      ::=  :&lt;&lt;&lt; [SelfType] TemplateStat {semi TemplateStat} &gt;&gt;&gt;
</span><span line-number="49" class=""><span class="tooltip-container"></span>TemplateStat      ::=  Import
</span><span line-number="50" class=""><span class="tooltip-container"></span>                    |  Export
</span><span line-number="51" class=""><span class="tooltip-container"></span>                    |  {Annotation [nl]} {Modifier} Def
</span><span line-number="52" class=""><span class="tooltip-container"></span>                    |  {Annotation [nl]} {Modifier} Dcl
</span><span line-number="53" class=""><span class="tooltip-container"></span>                    |  Extension
</span><span line-number="54" class=""><span class="tooltip-container"></span>                    |  Expr1
</span><span line-number="55" class=""><span class="tooltip-container"></span>                    |  EndMarker
</span><span line-number="56" class=""><span class="tooltip-container"></span>                    |
</span><span line-number="57" class=""><span class="tooltip-container"></span>SelfType          ::=  id [‘:’ InfixType] ‘=&gt;’
</span><span line-number="58" class=""><span class="tooltip-container"></span>                    |  ‘this’ ‘:’ InfixType ‘=&gt;’
</span><span line-number="59" class=""><span class="tooltip-container"></span>
</span><span line-number="60" class=""><span class="tooltip-container"></span>EnumBody          ::=  :&lt;&lt;&lt; [SelfType] EnumStat {semi EnumStat} &gt;&gt;&gt;
</span><span line-number="61" class=""><span class="tooltip-container"></span>EnumStat          ::=  TemplateStat
</span><span line-number="62" class=""><span class="tooltip-container"></span>                    |  {Annotation [nl]} {Modifier} EnumCase
</span><span line-number="63" class=""><span class="tooltip-container"></span>EnumCase          ::=  ‘case’ (id ClassConstr [‘extends’ ConstrApps]] | ids)
</span><span line-number="64" class=""><span class="tooltip-container"></span>
</span><span line-number="65" class=""><span class="tooltip-container"></span>TopStats          ::=  TopStat {semi TopStat}
</span><span line-number="66" class=""><span class="tooltip-container"></span>TopStat           ::=  Import
</span><span line-number="67" class=""><span class="tooltip-container"></span>                    |  Export
</span><span line-number="68" class=""><span class="tooltip-container"></span>                    |  {Annotation [nl]} {Modifier} Def
</span><span line-number="69" class=""><span class="tooltip-container"></span>                    |  Extension
</span><span line-number="70" class=""><span class="tooltip-container"></span>                    |  Packaging
</span><span line-number="71" class=""><span class="tooltip-container"></span>                    |  PackageObject
</span><span line-number="72" class=""><span class="tooltip-container"></span>                    |  EndMarker
</span><span line-number="73" class=""><span class="tooltip-container"></span>                    |
</span><span line-number="74" class=""><span class="tooltip-container"></span>Packaging         ::=  ‘package’ QualId :&lt;&lt;&lt; TopStats &gt;&gt;&gt;
</span><span line-number="75" class=""><span class="tooltip-container"></span>PackageObject     ::=  ‘package’ ‘object’ ObjectDef
</span><span line-number="76" class=""><span class="tooltip-container"></span>
</span><span line-number="77" class=""><span class="tooltip-container"></span>CompilationUnit   ::=  {‘package’ QualId semi} TopStats
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
  </main> 
  <div class="divider"></div> 
  <nav class="arrow-navigation" aria-label="Page navigation"> 
   <div> <span class="body-small">Previous</span> <a rel="prev" href="experimental/tupled-function.html" aria-keyshortcuts="Left" class="body-medium"> <span class="body-medium">Tupled Function</span> </a> 
   </div> 
   <div> <span class="body-small">Next</span> <a rel="next" href="language-versions/index.html" aria-keyshortcuts="Right" class="body-medium"> <span class="body-medium">Language Versions</span> </a> 
   </div> 
  </nav> 
 </div> 
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#lexical-syntax-1">Lexical Syntax</a></li><li><a href="#optional-braces-3">Optional Braces</a></li><li><a href="#keywords-1">Keywords</a><ul><li><a href="#regular-keywords-1">Regular keywords</a></li><li><a href="#soft-keywords-1">Soft keywords</a></li></ul></li><li><a href="#context-free-syntax-1">Context-free Syntax</a><ul><li><a href="#literals-and-paths-1">Literals and Paths</a></li><li><a href="#types-1">Types</a></li><li><a href="#expressions-1">Expressions</a></li><li><a href="#type-and-value-parameters-1">Type and Value Parameters</a></li><li><a href="#bindings-and-imports-1">Bindings and Imports</a></li><li><a href="#declarations-and-definitions-1">Declarations and Definitions</a></li></ul></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://gitter.im/scala/scala"><button class="icon-button gitter"></button></a><div class="text">Copyright (c) 2002-2023, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2023, LAMP/EPFL</div></div></div></div></body></html>