<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Scala 3 Syntax Summary</title><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></link><script type="text/javascript" src="scripts/theme.js"></script><link rel="stylesheet" href="css/bootstrap.min.css"></link><link rel="stylesheet" href="css/dottydoc.css"></link><link rel="stylesheet" href="css/color-brewer.css"></link><script type="text/javascript" src="js/jquery.min.js" defer="true"></script><script type="text/javascript" src="js/bootstrap.min.js" defer="true"></script><link rel="stylesheet" href="css/content-contributors.css"></link><script type="text/javascript" src="js/contributors.js" defer="true"></script><script type="text/javascript" src="scripts/searchData.js" defer="true"></script><script type="text/javascript" src="scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="styles/nord-light.css"></link><link rel="stylesheet" href="styles/scalastyle.css"></link><link rel="stylesheet" href="styles/colors.css"></link><link rel="stylesheet" href="styles/dotty-icons.css"></link><link rel="stylesheet" href="styles/diagram.css"></link><link rel="stylesheet" href="styles/filter-bar.css"></link><link rel="stylesheet" href="styles/code-snippets.css"></link><link rel="stylesheet" href="styles/searchbar.css"></link><link rel="stylesheet" href="styles/social-links.css"></link><link rel="stylesheet" href="styles/ux.css"></link><link rel="stylesheet" href="styles/versions-dropdown.css"></link><link rel="stylesheet" href="styles/fontawesome.css"></link><script type="text/javascript" src="hljs/highlight.min.js" defer="true"></script><script type="text/javascript" src="scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="scripts/ux.js" defer="true"></script><script type="text/javascript" src="scripts/common/component.js" defer="true"></script><script type="text/javascript" src="scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="scripts/data.js" defer="true"></script><script>var pathToRoot = "";</script><script>var githubContributorsUrl = "https://api.github.com/repos/lampepfl/dotty";</script><script>var githubContributorsFilename = "docs/_docs/reference/syntax.md";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"><span><img src="project-logo/logo.svg"></img></span><span><div class="projectName">Scala 3 Reference</div></span><div id="version"><div class="versions-dropdown"><div onclick="dropdownHandler()" id="dropdown-button" class="dropdownbtn dropdownbtnactive"><div class="projectVersion">3.2.0</div><div id="dropdown-content" class="dropdown-content"><input type="text" placeholder="Search..." id="dropdown-input" onkeyup="filterFunction()"></input></div></div></div></div><div class="socials"><a href="https://github.com/lampepfl/dotty"><span class="social-icon" data-icon-path="github-icon-white.png"></span></a><a href="https://discord.com/invite/scala"><span class="social-icon" data-icon-path="discord-icon-white.png"></span></a><a href="https://twitter.com/scala_lang"><span class="social-icon" data-icon-path="twitter-icon-white.png"></span></a></div></div><div id="paneSearch"></div><nav id="sideMenu2"><div class="ni expanded"><span class="nh expanded"><span class="ar"></span><a href="index.html"><span>Scala 3 Reference</span></a></span><div class="ni"><span class="nh "><span class="ar"></span><a href="new-types/index.html"><span>New Types</span></a></span><div class="ni "><span class="nh "><a href="new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni "><span class="nh "><a href="new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni "><span class="nh "><a href="new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni "><span class="nh "><a href="new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni "><span class="nh "><a href="new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni "><span class="nh "><a href="new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="enums/index.html"><span>Enums</span></a></span><div class="ni "><span class="nh "><a href="enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni "><span class="nh "><a href="enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni "><span class="nh "><a href="enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni "><span class="nh "><a href="contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni "><span class="nh "><a href="contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni "><span class="nh "><a href="metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni "><span class="nh "><a href="metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni "><span class="nh "><a href="metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni "><span class="nh "><a href="metaprogramming/staging.html"><span>Runtime Multi-Stage Programming</span></a></span></div><div class="ni "><span class="nh "><a href="metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni "><span class="nh "><a href="metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni "><span class="nh "><a href="metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni "><span class="nh "><a href="other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/transparent-traits.html"><span>Transparent Traits</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni "><span class="nh "><a href="other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni "><span class="nh "><a href="changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/type-checking.html"><span>Changes in Type Checking</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni "><span class="nh "><a href="changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni "><span class="nh "><a href="dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni "><span class="nh "><a href="dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="experimental/index.html"><span>Experimental</span></a></span><div class="ni "><span class="nh "><a href="experimental/fewer-braces.html"><span>Fewer Braces</span></a></span></div><div class="ni "><span class="nh "><a href="experimental/canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni "><span class="nh "><a href="experimental/erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni "><span class="nh "><a href="experimental/named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni "><span class="nh "><a href="experimental/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni "><span class="nh "><a href="experimental/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni "><span class="nh "><a href="experimental/main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni "><span class="nh "><a href="experimental/cc.html"><span>Capture Checking</span></a></span></div><div class="ni "><span class="nh "><a href="experimental/tupled-function.html"><span>Tupled Function</span></a></span></div></div><div class="ni expanded"><span class="nh selected"><a href="syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni"><span class="nh "><span class="ar"></span><a href="language-versions/index.html"><span>Language Versions</span></a></span><div class="ni "><span class="nh "><a href="language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni "><span class="nh "><a href="language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni "><span class="nh "><a href="soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni "><span class="nh "><a href="features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></div></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="scaladoc-searchBar"></div><main id="main-content"><div class="breadcrumbs container"><a href="index.html">Scala 3 Reference</a>/<a href="syntax.html">Scala 3 Syntax Summary</a></div><div id="content"><html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <div class="container"> 
    <div id="site-header"> 
     <div class="wrap"> 
      <nav class="navigation" role="menu"> 
       <ul class="navigation-menu"> 
        <li class="navigation-menu-item"> <a href="https://docs.scala-lang.org/" class="active">Learn</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/download/">Install</a> </li> 
        <li class="navigation-menu-item"> <a href="https://scastie.scala-lang.org">Playground</a> </li> 
        <li class="navigation-menu-item"> <a href="https://index.scala-lang.org">Find A Library</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/community/">Community</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/blog/">Blog</a> </li> 
       </ul> 
      </nav> 
     </div> 
    </div> 
    <main> 
     <header> 
      <h1>Scala 3 Syntax Summary</h1> 
      <div class="byline"> <a href="https://github.com/lampepfl/dotty/edit/language-reference-stable/docs/_docs/reference/syntax.md"> <i class="far fa-edit"></i> Edit this page on GitHub </a> 
      </div> 
     </header> 
     <p>The following description of Scala tokens uses literal characters <code>‘c’</code> when referring to the ASCII fragment <code>\u0000</code> – <code>\u007F</code>.</p> 
     <p><em>Unicode escapes</em> are used to represent the <a href="https://www.w3.org/International/articles/definitions-characters/">Unicode character</a> with the given hexadecimal code:</p> 
     <div class="snippet"> 
      <pre><code class="language-ebnf">UnicodeEscape ::= ‘\’ ‘u’ {‘u’} hexDigit hexDigit hexDigit hexDigit ;
hexDigit      ::= ‘0’ | … | ‘9’ | ‘A’ | … | ‘F’ | ‘a’ | … | ‘f’ ;
</code></pre> 
     </div> 
     <p>Informal descriptions are typeset as <code>“some comment”</code>.</p> 
     <section id="lexical-syntax"> 
      <h3><a href="#lexical-syntax" class="anchor"></a>Lexical Syntax</h3> 
      <p>The lexical syntax of Scala is given by the following grammar in EBNF form.</p> 
      <div class="snippet"> 
       <pre><code class="language-ebnf">whiteSpace       ::=  ‘\u0020’ | ‘\u0009’ | ‘\u000D’ | ‘\u000A’ ;
upper            ::=  ‘A’ | … | ‘Z’ | ‘\$’ | ‘_’  “… and Unicode category Lu” ;
lower            ::=  ‘a’ | … | ‘z’ “… and Unicode category Ll” ;
letter           ::=  upper | lower “… and Unicode categories Lo, Lt, Nl” ;
digit            ::=  ‘0’ | … | ‘9’ ;
paren            ::=  ‘(’ | ‘)’ | ‘[’ | ‘]’ | ‘{’ | ‘}’ | ‘'(’ | ‘'[’ | ‘'{’ ;
delim            ::=  ‘`’ | ‘'’ | ‘"’ | ‘.’ | ‘;’ | ‘,’ ;
opchar           ::=  “printableChar not matched by (whiteSpace | upper |
                       lower | letter | digit | paren | delim | opchar |
                       Unicode_Sm | Unicode_So)” ;
printableChar    ::=  “all characters in [\u0020, \u007F] inclusive” ;
charEscapeSeq    ::=  ‘\’ (‘b’ | ‘t’ | ‘n’ | ‘f’ | ‘r’ | ‘"’ | ‘'’ | ‘\’) ;

op               ::=  opchar {opchar} ;
varid            ::=  lower idrest ;
alphaid          ::=  upper idrest
                   |  varid ;
plainid          ::=  alphaid
                   |  op ;
id               ::=  plainid
                   |  ‘`’ { charNoBackQuoteOrNewline | UnicodeEscape | charEscapeSeq } ‘`’ ;
idrest           ::=  {letter | digit} [‘_’ op] ;
quoteId          ::=  ‘'’ alphaid ;

integerLiteral   ::=  (decimalNumeral | hexNumeral) [‘L’ | ‘l’] ;
decimalNumeral   ::=  ‘0’ | nonZeroDigit [{digit | ‘_’} digit] ;
hexNumeral       ::=  ‘0’ (‘x’ | ‘X’) hexDigit [{hexDigit | ‘_’} hexDigit] ;
nonZeroDigit     ::=  ‘1’ | … | ‘9’ ;

floatingPointLiteral
                 ::=  [decimalNumeral] ‘.’ digit [{digit | ‘_’} digit] [exponentPart] [floatType]
                   |  decimalNumeral exponentPart [floatType]
                   |  decimalNumeral floatType ;
exponentPart     ::=  (‘E’ | ‘e’) [‘+’ | ‘-’] digit [{digit | ‘_’} digit] ;
floatType        ::=  ‘F’ | ‘f’ | ‘D’ | ‘d’ ;

booleanLiteral   ::=  ‘true’ | ‘false’ ;

characterLiteral ::=  ‘'’ (printableChar | charEscapeSeq) ‘'’ ;

stringLiteral    ::=  ‘"’ {stringElement} ‘"’
                   |  ‘"""’ multiLineChars ‘"""’ ;
stringElement    ::=  printableChar \ (‘"’ | ‘\’)
                   |  UnicodeEscape
                   |  charEscapeSeq ;
multiLineChars   ::=  {[‘"’] [‘"’] char \ ‘"’} {‘"’} ;
processedStringLiteral
                 ::=  alphaid ‘"’ {[‘\’] processedStringPart | ‘\\’ | ‘\"’} ‘"’
                   |  alphaid ‘"""’ {[‘"’] [‘"’] char \ (‘"’ | ‘$’) | escape} {‘"’} ‘"""’ ;
processedStringPart
                 ::= printableChar \ (‘"’ | ‘$’ | ‘\’) | escape ;
escape           ::=  ‘$$’
                   |  ‘$’ letter { letter | digit }
                   |  ‘{’ Block  [‘;’ whiteSpace stringFormat whiteSpace] ‘}’ ;
stringFormat     ::=  {printableChar \ (‘"’ | ‘}’ | ‘ ’ | ‘\t’ | ‘\n’)} ;

symbolLiteral    ::=  ‘'’ plainid // until 2.13 ;

comment          ::=  ‘/*’ “any sequence of characters; nested comments are allowed” ‘*/’
                   |  ‘//’ “any sequence of characters up to end of line” ;

nl               ::=  “new line character” ;
semi             ::=  ‘;’ |  nl {nl} ;
</code></pre> 
      </div>
     </section>
     <section id="optional-braces"> 
      <h2><a href="#optional-braces" class="anchor"></a>Optional Braces</h2> 
      <p>The lexical analyzer also inserts <code>indent</code> and <code>outdent</code> tokens that represent regions of indented code <a href="other-new-features/indentation.html">at certain points</a>.</p> 
      <p>In the context-free productions below we use the notation <code>&lt;&lt;&lt; ts &gt;&gt;&gt;</code> to indicate a token sequence <code>ts</code> that is either enclosed in a pair of braces <code>{ ts }</code> or that constitutes an indented region <code>indent ts outdent</code>. Analogously, the notation <code>:&lt;&lt;&lt; ts &gt;&gt;&gt;</code> indicates a token sequence <code>ts</code> that is either enclosed in a pair of braces <code>{ ts }</code> or that constitutes an indented region <code>indent ts outdent</code> that follows a <code>:</code> at the end of a line.</p> 
      <div class="snippet"> 
       <pre><code class="language-ebnf"> &lt;&lt;&lt; ts &gt;&gt;&gt;   ::=  ‘{’ ts ‘}’
                |  indent ts outdent ;
:&lt;&lt;&lt; ts &gt;&gt;&gt;   ::=  [nl] ‘{’ ts ‘}’
                |  `:` indent ts outdent ;
</code></pre> 
      </div>
     </section>
     <section id="keywords"> 
      <h2><a href="#keywords" class="anchor"></a>Keywords</h2> 
     </section>
     <section id="regular-keywords"> 
      <h3><a href="#regular-keywords" class="anchor"></a>Regular keywords</h3> 
      <div class="snippet"> 
       <pre><code class="language-ebnf">abstract  case      catch     class     def       do        else
enum      export    extends   false     final     finally   for
given     if        implicit  import    lazy      match     new
null      object    override  package   private   protected return
sealed    super     then      throw     trait     true      try
type      val       var       while     with      yield
:         =         &lt;-        =&gt;        &lt;:        &gt;:        #
@         =&gt;&gt;       ?=&gt;
</code></pre> 
      </div>
     </section>
     <section id="soft-keywords"> 
      <h3><a href="#soft-keywords" class="anchor"></a>Soft keywords</h3> 
      <div class="snippet"> 
       <pre><code class="language-ebnf">as  derives  end  extension  infix  inline  opaque  open  throws
transparent  using  |  *  +  -
</code></pre> 
      </div> 
      <p>See the <a href="soft-modifier.html">separate section on soft keywords</a> for additional details on where a soft keyword is recognized.</p> 
     </section>
     <section id="context-free-syntax"> 
      <h2><a href="#context-free-syntax" class="anchor"></a>Context-free Syntax</h2> 
      <p>The context-free syntax of Scala is given by the following EBNF grammar:</p> 
     </section>
     <section id="literals-and-paths"> 
      <h3><a href="#literals-and-paths" class="anchor"></a>Literals and Paths</h3> 
      <div class="snippet"> 
       <pre><code class="language-ebnf">SimpleLiteral     ::=  [‘-’] integerLiteral
                    |  [‘-’] floatingPointLiteral
                    |  booleanLiteral
                    |  characterLiteral
                    |  stringLiteral ;
Literal           ::=  SimpleLiteral
                    |  processedStringLiteral
                    |  symbolLiteral
                    |  ‘null’ ;

QualId            ::=  id {‘.’ id} ;
ids               ::=  id {‘,’ id} ;

SimpleRef         ::=  id
                    |  [id ‘.’] ‘this’
                    |  [id ‘.’] ‘super’ [ClassQualifier] ‘.’ id ;

ClassQualifier    ::=  ‘[’ id ‘]’ ;
</code></pre> 
      </div>
     </section>
     <section id="types"> 
      <h3><a href="#types" class="anchor"></a>Types</h3> 
      <div class="snippet"> 
       <pre><code class="language-ebnf">Type              ::=  FunType
                    |  HkTypeParamClause ‘=&gt;&gt;’ Type
                    |  FunParamClause ‘=&gt;&gt;’ Type
                    |  MatchType
                    |  InfixType ;
FunType           ::=  FunTypeArgs (‘=&gt;’ | ‘?=&gt;’) Type
                    |  HKTypeParamClause '=&gt;' Type ;
FunTypeArgs       ::=  InfixType
                    |  ‘(’ [ FunArgTypes ] ‘)’
                    |  FunParamClause ;
FunParamClause    ::=  ‘(’ TypedFunParam {‘,’ TypedFunParam } ‘)’ ;
TypedFunParam     ::=  id ‘:’ Type ;
MatchType         ::=  InfixType `match` &lt;&lt;&lt; TypeCaseClauses &gt;&gt;&gt; ;
InfixType         ::=  RefinedType {id [nl] RefinedType} ;
RefinedType       ::=  AnnotType {[nl] Refinement} ;
AnnotType         ::=  SimpleType {Annotation} ;

SimpleType        ::=  SimpleLiteral
                    |  ‘?’ TypeBounds
                    |  id
                    |  Singleton ‘.’ id
                    |  Singleton ‘.’ ‘type’
                    |  ‘(’ Types ‘)’
                    |  Refinement
                    |  ‘$’ ‘{’ Block ‘}’                                        -- unless inside quoted pattern
                    |  ‘$’ ‘{’ Pattern ‘}’                                      -- only inside quoted pattern
                    |  SimpleType1 TypeArgs
                    |  SimpleType1 ‘#’ id ;
Singleton         ::=  SimpleRef
                    |  SimpleLiteral
                    |  Singleton ‘.’ id ;

FunArgType        ::=  Type
                    |  ‘=&gt;’ Type ;
FunArgTypes       ::=  FunArgType { ‘,’ FunArgType } ;
ParamType         ::=  [‘=&gt;’] ParamValueType ;
ParamValueType    ::=  Type [‘*’] ;
TypeArgs          ::=  ‘[’ Types ‘]’ ;
Refinement        ::=  ‘{’ [RefineDcl] {semi [RefineDcl]} ‘}’ ;
TypeBounds        ::=  [‘&gt;:’ Type] [‘&lt;:’ Type] ;
TypeParamBounds   ::=  TypeBounds {‘:’ Type} ;
Types             ::=  Type {‘,’ Type} ;
</code></pre> 
      </div>
     </section>
     <section id="expressions"> 
      <h3><a href="#expressions" class="anchor"></a>Expressions</h3> 
      <div class="snippet"> 
       <pre><code class="language-ebnf">Expr              ::=  FunParams (‘=&gt;’ | ‘?=&gt;’) Expr
                    |  HkTypeParamClause ‘=&gt;’ Expr
                    |  Expr1 ;
BlockResult       ::=  FunParams (‘=&gt;’ | ‘?=&gt;’) Block
                    |  HkTypeParamClause ‘=&gt;’ Block
                    |  Expr1 ;
FunParams         ::=  Bindings
                    |  id
                    |  ‘_’ ;
Expr1             ::=  [‘inline’] ‘if’ ‘(’ Expr ‘)’ {nl} Expr [[semi] ‘else’ Expr]
                    |  [‘inline’] ‘if’  Expr ‘then’ Expr [[semi] ‘else’ Expr]
                    |  ‘while’ ‘(’ Expr ‘)’ {nl} Expr
                    |  ‘while’ Expr ‘do’ Expr
                    |  ‘try’ Expr Catches [‘finally’ Expr]
                    |  ‘try’ Expr [‘finally’ Expr]
                    |  ‘throw’ Expr
                    |  ‘return’ [Expr]
                    |  ForExpr
                    |  [SimpleExpr ‘.’] id ‘=’ Expr
                    |  PrefixOperator SimpleExpr ‘=’ Expr
                    |  SimpleExpr ArgumentExprs ‘=’ Expr
                    |  PostfixExpr [Ascription]
                    |  ‘inline’ InfixExpr MatchClause ;
Ascription        ::=  ‘:’ InfixType
                    |  ‘:’ Annotation {Annotation} ;
Catches           ::=  ‘catch’ (Expr | ExprCaseClause) ;
PostfixExpr       ::=  InfixExpr [id]                                          -- only if language.postfixOperators is enabled ;
InfixExpr         ::=  PrefixExpr
                    |  InfixExpr id [nl] InfixExpr
                    |  InfixExpr MatchClause ;
MatchClause       ::=  ‘match’ &lt;&lt;&lt; CaseClauses &gt;&gt;&gt; ;
PrefixExpr        ::=  [PrefixOperator] SimpleExpr ;
PrefixOperator    ::=  ‘-’ | ‘+’ | ‘~’ | ‘!’ ;
SimpleExpr        ::=  SimpleRef
                    |  Literal
                    |  ‘_’
                    |  BlockExpr
                    |  ‘$’ ‘{’ Block ‘}’                                        -- unless inside quoted pattern
                    |  ‘$’ ‘{’ Pattern ‘}’                                      -- only inside quoted pattern
                    |  Quoted
                    |  quoteId                                                  -- only inside splices
                    |  ‘new’ ConstrApp {‘with’ ConstrApp} [TemplateBody]
                    |  ‘new’ TemplateBody
                    |  ‘(’ ExprsInParens ‘)’
                    |  SimpleExpr ‘.’ id
                    |  SimpleExpr ‘.’ MatchClause
                    |  SimpleExpr TypeArgs
                    |  SimpleExpr ArgumentExprs ;
Quoted            ::=  ‘'’ ‘{’ Block ‘}’
                    |  ‘'’ ‘[’ Type ‘]’ ;
ExprsInParens     ::=  ExprInParens {‘,’ ExprInParens} ;
ExprInParens      ::=  PostfixExpr ‘:’ Type
                    |  Expr ;
ParArgumentExprs  ::=  ‘(’ [‘using’] ExprsInParens ‘)’
                    |  ‘(’ [ExprsInParens ‘,’] PostfixExpr ‘*’ ‘)’ ;
ArgumentExprs     ::=  ParArgumentExprs
                    |  BlockExpr ;
BlockExpr         ::=  &lt;&lt;&lt; (CaseClauses | Block) &gt;&gt;&gt; ;
Block             ::=  {BlockStat semi} [BlockResult] ;
BlockStat         ::=  Import
                    |  {Annotation {nl}} {LocalModifier} Def
                    |  Extension
                    |  Expr1
                    |  EndMarker ;

ForExpr           ::=  ‘for’ ‘(’ Enumerators0 ‘)’ {nl} [‘do‘ | ‘yield’] Expr
                    |  ‘for’ ‘{’ Enumerators0 ‘}’ {nl} [‘do‘ | ‘yield’] Expr
                    |  ‘for’     Enumerators0          (‘do‘ | ‘yield’) Expr ;
Enumerators0      ::=  {nl} Enumerators [semi] ;
Enumerators       ::=  Generator {semi Enumerator | Guard} ;
Enumerator        ::=  Generator
                    |  Guard {Guard}
                    |  Pattern1 ‘=’ Expr ;
Generator         ::=  [‘case’] Pattern1 ‘&lt;-’ Expr ;
Guard             ::=  ‘if’ PostfixExpr ;

CaseClauses       ::=  CaseClause { CaseClause } ;
CaseClause        ::=  ‘case’ Pattern [Guard] ‘=&gt;’ Block ;
ExprCaseClause    ::=  ‘case’ Pattern [Guard] ‘=&gt;’ Expr ;
TypeCaseClauses   ::=  TypeCaseClause { TypeCaseClause } ;
TypeCaseClause    ::=  ‘case’ InfixType ‘=&gt;’ Type [semi] ;

Pattern           ::=  Pattern1 { ‘|’ Pattern1 } ;
Pattern1          ::=  Pattern2 [‘:’ RefinedType] ;
Pattern2          ::=  [id ‘@’] InfixPattern [‘*’] ;
InfixPattern      ::=  SimplePattern { id [nl] SimplePattern } ;
SimplePattern     ::=  PatVar
                    |  Literal
                    |  ‘(’ [Patterns] ‘)’
                    |  Quoted
                    |  SimplePattern1 [TypeArgs] [ArgumentPatterns]
                    |  ‘given’ RefinedType ;
SimplePattern1    ::=  SimpleRef
                    |  SimplePattern1 ‘.’ id ;
PatVar            ::=  varid
                    |  ‘_’ ;
Patterns          ::=  Pattern {‘,’ Pattern} ;
ArgumentPatterns  ::=  ‘(’ [Patterns] ‘)’
                    |  ‘(’ [Patterns ‘,’] PatVar ‘*’ ‘)’ ;
</code></pre> 
      </div>
     </section>
     <section id="type-and-value-parameters"> 
      <h3><a href="#type-and-value-parameters" class="anchor"></a>Type and Value Parameters</h3> 
      <div class="snippet"> 
       <pre><code class="language-ebnf">ClsTypeParamClause::=  ‘[’ ClsTypeParam {‘,’ ClsTypeParam} ‘]’ ;
ClsTypeParam      ::=  {Annotation} [‘+’ | ‘-’] id [HkTypeParamClause] TypeParamBounds ;

DefTypeParamClause::=  ‘[’ DefTypeParam {‘,’ DefTypeParam} ‘]’ ;
DefTypeParam      ::=  {Annotation} id [HkTypeParamClause] TypeParamBounds ;

TypTypeParamClause::=  ‘[’ TypTypeParam {‘,’ TypTypeParam} ‘]’ ;
TypTypeParam      ::=  {Annotation} id [HkTypeParamClause] TypeBounds ;

HkTypeParamClause ::=  ‘[’ HkTypeParam {‘,’ HkTypeParam} ‘]’ ;
HkTypeParam       ::=  {Annotation} [‘+’ | ‘-’] (id [HkTypeParamClause] | ‘_’) TypeBounds ;

ClsParamClauses   ::=  {ClsParamClause} [[nl] ‘(’ [‘implicit’] ClsParams ‘)’] ;
ClsParamClause    ::=  [nl] ‘(’ ClsParams ‘)’
                    |  [nl] ‘(’ ‘using’ (ClsParams | FunArgTypes) ‘)’ ;
ClsParams         ::=  ClsParam {‘,’ ClsParam} ;
ClsParam          ::=  {Annotation} [{Modifier} (‘val’ | ‘var’) | ‘inline’] Param ;
Param             ::=  id ‘:’ ParamType [‘=’ Expr] ;

DefParamClauses   ::=  {DefParamClause} [[nl] ‘(’ [‘implicit’] DefParams ‘)’] ;
DefParamClause    ::=  [nl] ‘(’ DefParams ‘)’ | UsingParamClause ;
UsingParamClause  ::=  [nl] ‘(’ ‘using’ (DefParams | FunArgTypes) ‘)’ ;
DefParams         ::=  DefParam {‘,’ DefParam} ;
DefParam          ::=  {Annotation} [‘inline’] Param ;
</code></pre> 
      </div>
     </section>
     <section id="bindings-and-imports"> 
      <h3><a href="#bindings-and-imports" class="anchor"></a>Bindings and Imports</h3> 
      <div class="snippet"> 
       <pre><code class="language-ebnf">Bindings          ::=  ‘(’ [Binding {‘,’ Binding}] ‘)’ ;
Binding           ::=  (id | ‘_’) [‘:’ Type] ;

Modifier          ::=  LocalModifier
                    |  AccessModifier
                    |  ‘override’
                    |  ‘opaque’ ;
LocalModifier     ::=  ‘abstract’
                    |  ‘final’
                    |  ‘sealed’
                    |  ‘open’
                    |  ‘implicit’
                    |  ‘lazy’
                    |  ‘inline’ ;
AccessModifier    ::=  (‘private’ | ‘protected’) [AccessQualifier] ;
AccessQualifier   ::=  ‘[’ id ‘]’ ;

Annotation        ::=  ‘@’ SimpleType1 {ParArgumentExprs} ;

Import            ::=  ‘import’ ImportExpr {‘,’ ImportExpr} ;
Export            ::=  ‘export’ ImportExpr {‘,’ ImportExpr} ;
ImportExpr        ::=  SimpleRef {‘.’ id} ‘.’ ImportSpec
                    |  SimpleRef ‘as’ id ;
ImportSpec        ::=  NamedSelector
                    |  WildcardSelector
                    | ‘{’ ImportSelectors) ‘}’ ;
NamedSelector     ::=  id [‘as’ (id | ‘_’)] ;
WildCardSelector  ::=  ‘*' | ‘given’ [InfixType] ;
ImportSelectors   ::=  NamedSelector [‘,’ ImportSelectors]
                    |  WildCardSelector {‘,’ WildCardSelector} ;

EndMarker         ::=  ‘end’ EndMarkerTag    -- when followed by EOL ;
EndMarkerTag      ::=  id | ‘if’ | ‘while’ | ‘for’ | ‘match’ | ‘try’
                    |  ‘new’ | ‘this’ | ‘given’ | ‘extension’ | ‘val’ ;
</code></pre> 
      </div>
     </section>
     <section id="declarations-and-definitions"> 
      <h3><a href="#declarations-and-definitions" class="anchor"></a>Declarations and Definitions</h3> 
      <div class="snippet"> 
       <pre><code class="language-ebnf">RefineDcl         ::=  ‘val’ ValDcl
                    |  ‘def’ DefDcl
                    |  ‘type’ {nl} TypeDcl ;
Dcl               ::=  RefineDcl
                    |  ‘var’ VarDcl ;
ValDcl            ::=  ids ‘:’ Type ;
VarDcl            ::=  ids ‘:’ Type ;
DefDcl            ::=  DefSig ‘:’ Type ;
DefSig            ::=  id [DefTypeParamClause] DefParamClauses ;
TypeDcl           ::=  id [TypeParamClause] {FunParamClause} TypeBounds [‘=’ Type] ;

Def               ::=  ‘val’ PatDef
                    |  ‘var’ PatDef
                    |  ‘def’ DefDef
                    |  ‘type’ {nl} TypeDcl
                    |  TmplDef ;
PatDef            ::=  ids [‘:’ Type] ‘=’ Expr
                    |  Pattern2 [‘:’ Type] ‘=’ Expr ;
DefDef            ::=  DefSig [‘:’ Type] ‘=’ Expr
                    |  ‘this’ DefParamClause DefParamClauses ‘=’ ConstrExpr ;

TmplDef           ::=  ([‘case’] ‘class’ | ‘trait’) ClassDef
                    |  [‘case’] ‘object’ ObjectDef
                    |  ‘enum’ EnumDef
                    |  ‘given’ GivenDef ;
ClassDef          ::=  id ClassConstr [Template] ;
ClassConstr       ::=  [ClsTypeParamClause] [ConstrMods] ClsParamClauses ;
ConstrMods        ::=  {Annotation} [AccessModifier] ;
ObjectDef         ::=  id [Template] ;
EnumDef           ::=  id ClassConstr InheritClauses EnumBody ;
GivenDef          ::=  [GivenSig] (AnnotType [‘=’ Expr] | StructuralInstance) ;
GivenSig          ::=  [id] [DefTypeParamClause] {UsingParamClause} ‘:’         -- one of `id`, `DefParamClause`, `UsingParamClause` must be present ;
StructuralInstance ::=  ConstrApp {‘with’ ConstrApp} [‘with’ TemplateBody] ;
Extension         ::=  ‘extension’ [DefTypeParamClause] {UsingParamClause}
                       ‘(’ DefParam ‘)’ {UsingParamClause} ExtMethods ;
ExtMethods        ::=  ExtMethod | [nl] &lt;&lt;&lt; ExtMethod {semi ExtMethod} &gt;&gt;&gt; ;
ExtMethod         ::=  {Annotation [nl]} {Modifier} ‘def’ DefDef ;
Template          ::=  InheritClauses [TemplateBody] ;
InheritClauses    ::=  [‘extends’ ConstrApps] [‘derives’ QualId {‘,’ QualId}] ;
ConstrApps        ::=  ConstrApp ({‘,’ ConstrApp} | {‘with’ ConstrApp}) ;
ConstrApp         ::=  SimpleType1 {Annotation} {ParArgumentExprs} ;
ConstrExpr        ::=  SelfInvocation
                    |  &lt;&lt;&lt; SelfInvocation {semi BlockStat} &gt;&gt;&gt; ;
SelfInvocation    ::=  ‘this’ ArgumentExprs {ArgumentExprs} ;

TemplateBody      ::=  :&lt;&lt;&lt; [SelfType] TemplateStat {semi TemplateStat} &gt;&gt;&gt; ;
TemplateStat      ::=  Import
                    |  Export
                    |  {Annotation [nl]} {Modifier} Def
                    |  {Annotation [nl]} {Modifier} Dcl
                    |  Extension
                    |  Expr1
                    |  EndMarker
                    | ;
SelfType          ::=  id [‘:’ InfixType] ‘=&gt;’
                    |  ‘this’ ‘:’ InfixType ‘=&gt;’ ;

EnumBody          ::=  :&lt;&lt;&lt; [SelfType] EnumStat {semi EnumStat} &gt;&gt;&gt; ;
EnumStat          ::=  TemplateStat
                    |  {Annotation [nl]} {Modifier} EnumCase ;
EnumCase          ::=  ‘case’ (id ClassConstr [‘extends’ ConstrApps]] | ids) ;

TopStats          ::=  TopStat {semi TopStat} ;
TopStat           ::=  Import
                    |  Export
                    |  {Annotation [nl]} {Modifier} Def
                    |  Extension
                    |  Packaging
                    |  PackageObject
                    |  EndMarker
                    | ;
Packaging         ::=  ‘package’ QualId :&lt;&lt;&lt; TopStats &gt;&gt;&gt; ;
PackageObject     ::=  ‘package’ ‘object’ ObjectDef ;

CompilationUnit   ::=  {‘package’ QualId semi} TopStats ;
</code></pre> 
      </div>
     </section> 
    </main> 
    <nav class="arrows-wrapper" aria-label="Page navigation"> <a rel="prev" href="experimental/tupled-function.html" class="arrows previous" aria-keyshortcuts="Left"> <span>Tupled Function</span> <i class="fa fa-angle-left"></i> </a> <a rel="next" href="language-versions/index.html" class="arrows next" aria-keyshortcuts="Right"> <span>Language Versions</span> <i class="fa fa-angle-right"></i> </a> 
    </nav> 
    <div class="content-contributors hidden"> <span><b>Contributors to this page</b></span> 
     <div id="documentation-contributors" class="contributors-container"></div> 
    </div> 
   </div> 
  </div>
 </body>
</html></div></main><footer><div id="generated-by"><span class="footer-text">Generated by</span><a href="https://github.com/lampepfl/dotty/tree/main/scaladoc"><img src="images/scaladoc_logo.svg" alt="scaladoc" class="scaladoc_logo"></img><img src="images/scaladoc_logo_dark.svg" alt="scaladoc" class="scaladoc_logo_dark"></img></a></div><span id="footer-text">Copyright (c) 2002-2022, LAMP/EPFL</span><div class="socials"><span class="footer-text">Social links</span><a href="https://github.com/lampepfl/dotty"><span class="social-icon" data-icon-path="github-icon-black.png"></span></a><a href="https://discord.com/invite/scala"><span class="social-icon" data-icon-path="discord-icon-black.png"></span></a><a href="https://twitter.com/scala_lang"><span class="social-icon" data-icon-path="twitter-icon-black.png"></span></a></div><div class="mode"><span class="footer-text">Mode</span><label id="theme-toggle" class="switch"><input type="checkbox"></input><span class="slider"></span></label></div><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span><span class="footer-text">Back to top</span></a></span></footer></div><div id="toc"><span class="toc-title">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><ul><li><ul><li><a href="#lexical-syntax">Lexical Syntax</a></li></ul></li><li><a href="#optional-braces">Optional Braces</a></li><li><a href="#keywords">Keywords</a><ul><li><a href="#regular-keywords">Regular keywords</a></li><li><a href="#soft-keywords">Soft keywords</a></li></ul></li><li><a href="#context-free-syntax">Context-free Syntax</a><ul><li><a href="#literals-and-paths">Literals and Paths</a></li><li><a href="#types">Types</a></li><li><a href="#expressions">Expressions</a></li><li><a href="#type-and-value-parameters">Type and Value Parameters</a></li><li><a href="#bindings-and-imports">Bindings and Imports</a></li><li><a href="#declarations-and-definitions">Declarations and Definitions</a></li></ul></li></ul></li></ul></nav></div></div></body></html>