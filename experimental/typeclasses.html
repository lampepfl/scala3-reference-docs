<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/scala/scala3" data-githubContributorsFilename="docs/_docs/reference/experimental/typeclasses.md" data-pathToRoot="../" data-rawLocation="experimental/typeclasses" data-dynamicSideMenu="false"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Better Support for Type Classes</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="/css/dottydoc.css"></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.7.0</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../index.html">Docs</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni n1 "><span class="nh de"><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni n1 "><span class="nh de"><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/deferred-givens.html"><span>Deferred Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/more-givens.html"><span>Other Forms Of Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/previous-givens.html"><span>Previous Given Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/staging.html"><span>Run-Time Multi-Stage Programming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits and Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/named-tuples.html"><span>Named Tuples</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/preview-defs.html"><span>Preview Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/binary-literals.html"><span>Binary Integer Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/toplevel-definitions.html"><span>Toplevel Definitions</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../preview/index.html"><span>Preview</span></a></span><div class="ni n1 "><span class="nh de"><a href="../preview/better-fors.html"><span>Better fors</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>Experimental</span></a></span><div class="ni n1 "><span class="nh de"><a href="canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="into-modifier.html"><span>The `into` Type Modifier</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="cc.html"><span>Capture Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="purefuns.html"><span>Pure Function Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="tupled-function.html"><span>Tupled Function</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="modularity.html"><span>Modularity Improvements</span></a></span></div><div class="ni n1 expanded"><span class="nh h100 selected de"><a href="#"><span>Better Support for Type Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="runtimeChecked.html"><span>The runtimeChecked method</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="unrolled-defs.html"><span>Automatic Parameter Unrolling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="package-object-values.html"><span>Reference-able Package Objects</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Experimental</a>/<a href="typeclasses.html">Better Support for Type Classes</a></div><div id="content" class="body-medium"><div><div id="content-wrapper">
 <div class="site-container">
  <div id="site-header"></div>
  <main>
   <header>
    <a class="text-button with-link body-small" href="https://github.com/scala/scala3/edit/language-reference-stable/docs/_docs/reference/experimental/typeclasses.md">Edit this page on GitHub</a>
    <h1 class="h600">Better Support for Type Classes</h1>
   </header>
   <p class="body-large first-p">Martin Odersky, 8.1.2024, edited 5.4.2024 and 30.9.2024</p>
   <p>A type class in Scala is a pattern where we define</p>
   <ul>
    <li>a trait with one type parameter (the <em>type class</em>)</li>
    <li>given instances at specific instantiations of that trait,</li>
    <li>using clauses or context bounds abstracting over that trait.</li>
   </ul>
   <p>Type classes as a pattern work overall OK, but if we compare them to native implementations in Haskell, or protocols in Swift, or traits in Rust, then there are some idiosyncrasies and rough corners which in the end make them a bit cumbersome and limiting for standard generic programming patterns. Much has improved since Scala 2's implicits, but there is still some gap to bridge to get to parity with these languages.</p>
   <p>This note shows that with some fairly small and reasonable tweaks to Scala's syntax and typing rules we can obtain a much better scheme for working with type classes, or do generic programming in general.</p>
   <p>The bulk of the suggested improvements has been implemented and is available in source version <code>future</code> if the additional experimental language import <code>modularity</code> is present. For instance, using the following command:</p>
   <div class="snippet mono-small-block">
    <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>scala compile -source:future -language:experimental.modularity
</span></code></pre>
    <div class="buttons"></div>
   </div>
   <p>It is intended to turn features described here into proposals under the Scala improvement process. A first installment is SIP 64, which covers some syntactic changes, names for context bounds, multiple context bounds and deferred givens. This SIP has been accepted for inclusion in the language and will be released in Scala 3.6. The remaining elements that concern type classes are described in the following. There is also a separate <a href="../modularity.md">page on modularity improvements</a> that describes proposed additions not directly related to type classes.</p>
   <section id="generalizing-context-bounds-1">
    <h2 class="h500"><a href="#generalizing-context-bounds-1" class="anchor"></a>Generalizing Context Bounds</h2>
    <p>The only place in Scala's syntax where the type class pattern is relevant is in context bounds. A context bound such as</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">   </span>def min[A: Ordering](x: List[A]): A
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>requires that <code>Ordering</code> is a trait or class with a single type parameter (which makes it a type class) and expands to a <code>using</code> clause that instantiates that parameter. Here is the expansion of <code>min</code>:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">   </span>def min[A](x: List[A])(using Ordering[A]): A
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><strong>Proposal</strong> Allow type classes to define an abstract type member named <code>Self</code> instead of a type parameter.</p>
    <p><strong>Example</strong></p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  trait Ord:
</span><span line-number="2" class=""><span class="tooltip-container"></span>    type Self
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>  trait SemiGroup:
</span><span line-number="5" class=""><span class="tooltip-container"></span>    type Self
</span><span line-number="6" class=""><span class="tooltip-container"></span>    extension (x: Self) def combine(y: Self): Self
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>  trait Monoid extends SemiGroup:
</span><span line-number="9" class=""><span class="tooltip-container"></span>    def unit: Self
</span><span line-number="10" class=""><span class="tooltip-container"></span>  object Monoid:
</span><span line-number="11" class=""><span class="tooltip-container"></span>    def unit[M](using m: Monoid { type Self = M}): M
</span><span line-number="12" class=""><span class="tooltip-container"></span>
</span><span line-number="13" class=""><span class="tooltip-container"></span>  trait Functor:
</span><span line-number="14" class=""><span class="tooltip-container"></span>    type Self[A]
</span><span line-number="15" class=""><span class="tooltip-container"></span>    extension [A](x: Self[A]) def map[B](f: A =&gt; B): Self[B]
</span><span line-number="16" class=""><span class="tooltip-container"></span>
</span><span line-number="17" class=""><span class="tooltip-container"></span>  trait Monad extends Functor:
</span><span line-number="18" class=""><span class="tooltip-container"></span>    def pure[A](x: A): Self[A]
</span><span line-number="19" class=""><span class="tooltip-container"></span>    extension [A](x: Self[A])
</span><span line-number="20" class=""><span class="tooltip-container"></span>      def flatMap[B](f: A =&gt; Self[B]): Self[B]
</span><span line-number="21" class=""><span class="tooltip-container"></span>      def map[B](f: A =&gt; B) = x.flatMap(f `andThen` pure)
</span><span line-number="22" class=""><span class="tooltip-container"></span>
</span><span line-number="23" class=""><span class="tooltip-container"></span>  def reduce[A: Monoid](xs: List[A]): A =
</span><span line-number="24" class=""><span class="tooltip-container"></span>    xs.foldLeft(Monoid.unit)(_ `combine` _)
</span><span line-number="25" class=""><span class="tooltip-container"></span>
</span><span line-number="26" class=""><span class="tooltip-container"></span>  trait ParserCombinator:
</span><span line-number="27" class=""><span class="tooltip-container"></span>    type Self
</span><span line-number="28" class=""><span class="tooltip-container"></span>    type Input
</span><span line-number="29" class=""><span class="tooltip-container"></span>    type Result
</span><span line-number="30" class=""><span class="tooltip-container"></span>    extension (self: Self)
</span><span line-number="31" class=""><span class="tooltip-container"></span>      def parse(input: Input): Option[Result] = ...
</span><span line-number="32" class=""><span class="tooltip-container"></span>
</span><span line-number="33" class=""><span class="tooltip-container"></span>  def combine[A: ParserCombinator, B: ParserCombinator { type Input = A.Input }] = ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><strong>Advantages</strong></p>
    <ul>
     <li>Avoids repetitive type parameters, concentrates on what's essential, namely the type class hierarchy.</li>
     <li>Gives a clear indication of traits intended as type classes. A trait is a type class if it has type <code>Self</code> as a member</li>
     <li>Allows to create aggregate type classes that combine givens via intersection types.</li>
     <li>Allows to use refinements in context bounds (the <code>combine</code> example above would be very awkward to express using the old way of context bounds expanding to type constructors).</li>
    </ul>
    <p><code>Self</code>-based context bounds are a better fit for a dependently typed language like Scala than parameter-based ones. The main reason is that we are dealing with proper types, not type constructors. Proper types can be parameterized, intersected, or refined. This makes <code>Self</code>-based designs inherently more compositional than parameterized ones.</p>
    <p><strong>Details</strong></p>
    <p>When a trait has both a type parameter and an abstract <code>Self</code> type, we resolve a context bound to the <code>Self</code> type. This allows type classes that carry type parameters, as in</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait Sequential[E]:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  type Self
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Here,</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>[S: Sequential[Int]]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>should resolve to:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>[S](using Sequential[Int] { type Self = S })
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>and not to:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>[S](using Sequential[S])
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><strong>Discussion</strong></p>
    <p>Why not use <code>This</code> for the self type? The name <code>This</code> suggests that it is the type of <code>this</code>. But this is not true for type class traits. <code>Self</code> is the name of the type implementing a distinguished <em>member type</em> of the trait in a <code>given</code> definition. <code>Self</code> is an established term in both Rust and Swift with the meaning used here.</p>
    <p>One possible objection to the <code>Self</code> based design is that it does not cover "multi-parameter" type classes. But neither do context bounds! "Multi-parameter" type classes in Scala are simply givens that can be synthesized with the standard mechanisms. Type classes in the strict sense abstract only over a single type, namely the implementation type of a trait.</p>
   </section>
   <section id="auxiliary-type-alias-is-1">
    <h2 class="h500"><a href="#auxiliary-type-alias-is-1" class="anchor"></a>Auxiliary Type Alias <code>is</code></h2>
    <p>We introduce a standard type alias <code>is</code> in the Scala package or in <code>Predef</code>, defined like this:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>infix type is[A &lt;: AnyKind, B &lt;: {type Self &lt;: AnyKind}] = B { type Self = A }
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This makes writing instance definitions and using clauses quite pleasant. Examples:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  given Int is Ord ...
</span><span line-number="2" class=""><span class="tooltip-container"></span>  given Int is Monoid ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>  type Reader = [X] =&gt;&gt; Env =&gt; X
</span><span line-number="5" class=""><span class="tooltip-container"></span>  given Reader is Monad ...
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>  object Monoid:
</span><span line-number="8" class=""><span class="tooltip-container"></span>    def unit[M](using m: M is Monoid): M
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>(more examples will follow below)</p>
   </section>
   <section id="better-default-names-for-context-bounds-1">
    <h3 class="h400"><a href="#better-default-names-for-context-bounds-1" class="anchor"></a>Better Default Names for Context Bounds</h3>
    <p>So far, an unnamed context bound for a type parameter gets a synthesized fresh name. It would be much more useful if it got the name of the constrained type parameter instead, translated to be a term name. This means our <code>reduce</code> method over monoids would not even need an <code>as</code> binding. We could simply formulate it as follows:</p>
    <div class="snippet mono-small-block">
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable"> </span>def reduce[A : Monoid](xs: List[A]) =
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable"> </span>   xs.foldLeft(A.unit)(_ `combine` _)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>In Scala we are already familiar with using one name for two related things where one version names a type and the other an associated value. For instance, we use that convention for classes and companion objects. In retrospect, the idea of generalizing this to also cover type parameters is obvious. It is surprising that it was not brought up before.</p>
    <p><strong>Proposed Rules</strong></p>
    <ol>
     <li>The generated evidence parameter for a context bound <code>A : C as a</code> has name <code>a</code></li>
     <li>The generated evidence for a context bound <code>A : C</code> without an <code>as</code> binding has name <code>A</code> (seen as a term name). So, <code>A : C</code> is equivalent to <code>A : C as A</code>.</li>
     <li>If there are multiple context bounds for a type parameter, as in <code>A : {C_1, ..., C_n}</code>, the generated evidence parameter for every context bound <code>C_i</code> has a fresh synthesized name, unless the context bound carries an <code>as</code> clause, in which case rule (1) applies.</li>
    </ol>
    <p>TODO: Present context bound proxy concept.</p>
    <p>The default naming convention reduces the need for named context bounds. But named context bounds are still essential, for at least two reasons:</p>
    <ul>
     <li>They are needed to give names to multiple context bounds.</li>
     <li>They give an explanation what a single unnamed context bound expands to.</li>
    </ul>
   </section>
   <section id="fixing-singleton-1">
    <h2 class="h500"><a href="#fixing-singleton-1" class="anchor"></a>Fixing Singleton</h2>
    <p>We know the current treatment of <code>Singleton</code> as a type bound is broken since <code>x.type | y.type &lt;: Singleton</code> holds by the subtyping rules for union types, even though <code>x.type | y.type</code> is clearly not a singleton.</p>
    <p>A better approach is to treat <code>Singleton</code> as a type class that is interpreted specially by the compiler.</p>
    <p>We can do this in a backwards-compatible way by defining <code>Singleton</code> like this:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait Singleton:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  type Self
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Then, instead of using an unsound upper bound we can use a context bound:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def f[X: Singleton](x: X) = ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The context bound is treated specially by the compiler so that no using clause is generated at runtime (this is straightforward, using the erased definitions mechanism).</p>
    <p>##: Precise Typing</p>
    <p>This approach also presents a solution to the problem how to express precise type variables. We can introduce another special type class <code>Precise</code> and use it like this:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def f[X: Precise](x: X) = ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Like a <code>Singleton</code> bound, a <code>Precise</code> bound disables automatic widening of singleton types or union types in inferred instances of type variable <code>X</code>. But there is no requirement that the type argument <em>must</em> be a singleton.</p>
   </section>
   <section id="examples-13">
    <h2 class="h500"><a href="#examples-13" class="anchor"></a>Examples</h2>
   </section>
   <section id="example-1-1">
    <h3 class="h400"><a href="#example-1-1" class="anchor"></a>Example 1</h3>
    <p>Here are some standard type classes, which were mostly already introduced at the start of this note, now with associated instance givens and some test code:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  // Type classes
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  trait Ord:
</span><span line-number="4" class=""><span class="tooltip-container"></span>    type Self
</span><span line-number="5" class=""><span class="tooltip-container"></span>    extension (x: Self)
</span><span line-number="6" class=""><span class="tooltip-container"></span>      def compareTo(y: Self): Int
</span><span line-number="7" class=""><span class="tooltip-container"></span>      def &lt; (y: Self): Boolean = compareTo(y) &lt; 0
</span><span line-number="8" class=""><span class="tooltip-container"></span>      def &gt; (y: Self): Boolean = compareTo(y) &gt; 0
</span><span line-number="9" class=""><span class="tooltip-container"></span>      def &lt;= (y: Self): Boolean = compareTo(y) &lt;= 0
</span><span line-number="10" class=""><span class="tooltip-container"></span>      def &gt;= (y: Self): Boolean = compareTo(y) &gt;= 0
</span><span line-number="11" class=""><span class="tooltip-container"></span>      def max(y: Self): Self = if x &lt; y then y else x
</span><span line-number="12" class=""><span class="tooltip-container"></span>
</span><span line-number="13" class=""><span class="tooltip-container"></span>  trait Show:
</span><span line-number="14" class=""><span class="tooltip-container"></span>    type Self
</span><span line-number="15" class=""><span class="tooltip-container"></span>    extension (x: Self) def show: String
</span><span line-number="16" class=""><span class="tooltip-container"></span>
</span><span line-number="17" class=""><span class="tooltip-container"></span>  trait SemiGroup:
</span><span line-number="18" class=""><span class="tooltip-container"></span>    type Self
</span><span line-number="19" class=""><span class="tooltip-container"></span>    extension (x: Self) def combine(y: Self): Self
</span><span line-number="20" class=""><span class="tooltip-container"></span>
</span><span line-number="21" class=""><span class="tooltip-container"></span>  trait Monoid extends SemiGroup:
</span><span line-number="22" class=""><span class="tooltip-container"></span>    def unit: Self
</span><span line-number="23" class=""><span class="tooltip-container"></span>
</span><span line-number="24" class=""><span class="tooltip-container"></span>  trait Functor:
</span><span line-number="25" class=""><span class="tooltip-container"></span>    type Self[A] // Here, Self is a type constructor with parameter A
</span><span line-number="26" class=""><span class="tooltip-container"></span>    extension [A](x: Self[A]) def map[B](f: A =&gt; B): Self[B]
</span><span line-number="27" class=""><span class="tooltip-container"></span>
</span><span line-number="28" class=""><span class="tooltip-container"></span>  trait Monad extends Functor:
</span><span line-number="29" class=""><span class="tooltip-container"></span>    def pure[A](x: A): Self[A]
</span><span line-number="30" class=""><span class="tooltip-container"></span>    extension [A](x: Self[A])
</span><span line-number="31" class=""><span class="tooltip-container"></span>      def flatMap[B](f: A =&gt; Self[B]): Self[B]
</span><span line-number="32" class=""><span class="tooltip-container"></span>      def map[B](f: A =&gt; B) = x.flatMap(f `andThen` pure)
</span><span line-number="33" class=""><span class="tooltip-container"></span>
</span><span line-number="34" class=""><span class="tooltip-container"></span>  // Instances
</span><span line-number="35" class=""><span class="tooltip-container"></span>
</span><span line-number="36" class=""><span class="tooltip-container"></span>  given Int is Ord:
</span><span line-number="37" class=""><span class="tooltip-container"></span>    extension (x: Int)
</span><span line-number="38" class=""><span class="tooltip-container"></span>      def compareTo(y: Int) =
</span><span line-number="39" class=""><span class="tooltip-container"></span>        if x &lt; y then -1
</span><span line-number="40" class=""><span class="tooltip-container"></span>        else if x &gt; y then +1
</span><span line-number="41" class=""><span class="tooltip-container"></span>        else 0
</span><span line-number="42" class=""><span class="tooltip-container"></span>
</span><span line-number="43" class=""><span class="tooltip-container"></span>  given [T: Ord] =&gt; List[T] is Ord:
</span><span line-number="44" class=""><span class="tooltip-container"></span>    extension (xs: List[T]) def compareTo(ys: List[T]): Int =
</span><span line-number="45" class=""><span class="tooltip-container"></span>      (xs, ys) match
</span><span line-number="46" class=""><span class="tooltip-container"></span>      case (Nil, Nil) =&gt; 0
</span><span line-number="47" class=""><span class="tooltip-container"></span>      case (Nil, _) =&gt; -1
</span><span line-number="48" class=""><span class="tooltip-container"></span>      case (_, Nil) =&gt; +1
</span><span line-number="49" class=""><span class="tooltip-container"></span>      case (x :: xs1, y :: ys1) =&gt;
</span><span line-number="50" class=""><span class="tooltip-container"></span>        val fst = x.compareTo(y)
</span><span line-number="51" class=""><span class="tooltip-container"></span>        if (fst != 0) fst else xs1.compareTo(ys1)
</span><span line-number="52" class=""><span class="tooltip-container"></span>
</span><span line-number="53" class=""><span class="tooltip-container"></span>  given List is Monad:
</span><span line-number="54" class=""><span class="tooltip-container"></span>    extension [A](xs: List[A])
</span><span line-number="55" class=""><span class="tooltip-container"></span>      def flatMap[B](f: A =&gt; List[B]): List[B] =
</span><span line-number="56" class=""><span class="tooltip-container"></span>        xs.flatMap(f)
</span><span line-number="57" class=""><span class="tooltip-container"></span>    def pure[A](x: A): List[A] =
</span><span line-number="58" class=""><span class="tooltip-container"></span>      List(x)
</span><span line-number="59" class=""><span class="tooltip-container"></span>
</span><span line-number="60" class=""><span class="tooltip-container"></span>  type Reader[Ctx] = [X] =&gt;&gt; Ctx =&gt; X
</span><span line-number="61" class=""><span class="tooltip-container"></span>
</span><span line-number="62" class=""><span class="tooltip-container"></span>  given [Ctx] =&gt; Reader[Ctx] is Monad:
</span><span line-number="63" class=""><span class="tooltip-container"></span>    extension [A](r: Ctx =&gt; A)
</span><span line-number="64" class=""><span class="tooltip-container"></span>      def flatMap[B](f: A =&gt; Ctx =&gt; B): Ctx =&gt; B =
</span><span line-number="65" class=""><span class="tooltip-container"></span>        ctx =&gt; f(r(ctx))(ctx)
</span><span line-number="66" class=""><span class="tooltip-container"></span>    def pure[A](x: A): Ctx =&gt; A =
</span><span line-number="67" class=""><span class="tooltip-container"></span>      ctx =&gt; x
</span><span line-number="68" class=""><span class="tooltip-container"></span>
</span><span line-number="69" class=""><span class="tooltip-container"></span>  // Usages
</span><span line-number="70" class=""><span class="tooltip-container"></span>
</span><span line-number="71" class=""><span class="tooltip-container"></span>  extension (xs: Seq[String])
</span><span line-number="72" class=""><span class="tooltip-container"></span>    def longestStrings: Seq[String] =
</span><span line-number="73" class=""><span class="tooltip-container"></span>      val maxLength = xs.map(_.length).max
</span><span line-number="74" class=""><span class="tooltip-container"></span>      xs.filter(_.length == maxLength)
</span><span line-number="75" class=""><span class="tooltip-container"></span>
</span><span line-number="76" class=""><span class="tooltip-container"></span>  extension [M[_]: Monad, A](xss: M[M[A]])
</span><span line-number="77" class=""><span class="tooltip-container"></span>    def flatten: M[A] =
</span><span line-number="78" class=""><span class="tooltip-container"></span>      xss.flatMap(identity)
</span><span line-number="79" class=""><span class="tooltip-container"></span>
</span><span line-number="80" class=""><span class="tooltip-container"></span>  def maximum[T: Ord](xs: List[T]): T =
</span><span line-number="81" class=""><span class="tooltip-container"></span>    xs.reduce(_ `max` _)
</span><span line-number="82" class=""><span class="tooltip-container"></span>
</span><span line-number="83" class=""><span class="tooltip-container"></span>  given descending: [T: Ord] =&gt; T is Ord:
</span><span line-number="84" class=""><span class="tooltip-container"></span>    extension (x: T) def compareTo(y: T) = T.compareTo(y)(x)
</span><span line-number="85" class=""><span class="tooltip-container"></span>
</span><span line-number="86" class=""><span class="tooltip-container"></span>  def minimum[T: Ord](xs: List[T]) =
</span><span line-number="87" class=""><span class="tooltip-container"></span>    maximum(xs)(using descending)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The <code>Reader</code> type is a bit hairy. It is a type class (written in the parameterized syntax) where we fix a context <code>Ctx</code> and then let <code>Reader</code> be the polymorphic function type over <code>X</code> that takes a context <code>Ctx</code> and returns an <code>X</code>. Type classes like this are commonly used in monadic effect systems.</p>
   </section>
   <section id="example-2-1">
    <h3 class="h400"><a href="#example-2-1" class="anchor"></a>Example 2</h3>
    <p>The following contributed code by @LPTK (issue #10929) did <em>not</em> work at first since references were not tracked correctly. The version below adds explicit tracked parameters which makes the code compile.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>infix abstract class TupleOf[T, +A]:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  type Mapped[+A] &lt;: Tuple
</span><span line-number="3" class=""><span class="tooltip-container"></span>  def map[B](x: T)(f: A =&gt; B): Mapped[B]
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>object TupleOf:
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>  given TupleOf[EmptyTuple, Nothing] with
</span><span line-number="8" class=""><span class="tooltip-container"></span>    type Mapped[+A] = EmptyTuple
</span><span line-number="9" class=""><span class="tooltip-container"></span>    def map[B](x: EmptyTuple)(f: Nothing =&gt; B): Mapped[B] = x
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>  given [A, Rest &lt;: Tuple](using tracked val tup: Rest TupleOf A): TupleOf[A *: Rest, A] with
</span><span line-number="12" class=""><span class="tooltip-container"></span>    type Mapped[+A] = A *: tup.Mapped[A]
</span><span line-number="13" class=""><span class="tooltip-container"></span>    def map[B](x: A *: Rest)(f: A =&gt; B): Mapped[B] =
</span><span line-number="14" class=""><span class="tooltip-container"></span>      f(x.head) *: tup.map(x.tail)(f)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Note the quite convoluted syntax, which makes the code hard to understand. Here is the same example in the new type class syntax, which also compiles correctly:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>//&gt; using options -language:experimental.modularity -source future
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>trait TupleOf[+A]:
</span><span line-number="4" class=""><span class="tooltip-container"></span>  type Self
</span><span line-number="5" class=""><span class="tooltip-container"></span>  type Mapped[+A] &lt;: Tuple
</span><span line-number="6" class=""><span class="tooltip-container"></span>  def map[B](x: Self)(f: A =&gt; B): Mapped[B]
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>object TupleOf:
</span><span line-number="9" class=""><span class="tooltip-container"></span>
</span><span line-number="10" class=""><span class="tooltip-container"></span>  given EmptyTuple is TupleOf[Nothing]:
</span><span line-number="11" class=""><span class="tooltip-container"></span>    type Mapped[+A] = EmptyTuple
</span><span line-number="12" class=""><span class="tooltip-container"></span>    def map[B](x: EmptyTuple)(f: Nothing =&gt; B): Mapped[B] = x
</span><span line-number="13" class=""><span class="tooltip-container"></span>
</span><span line-number="14" class=""><span class="tooltip-container"></span>  given [A, Rest &lt;: Tuple : TupleOf[A]] =&gt; A *: Rest is TupleOf[A]:
</span><span line-number="15" class=""><span class="tooltip-container"></span>    type Mapped[+A] = A *: Rest.Mapped[A]
</span><span line-number="16" class=""><span class="tooltip-container"></span>    def map[B](x: A *: Rest)(f: A =&gt; B): Mapped[B] =
</span><span line-number="17" class=""><span class="tooltip-container"></span>      f(x.head) *: Rest.map(x.tail)(f)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Note in particular the following points:</p>
    <ul>
     <li>
      <p>In the original code, it was not clear that <code>TupleOf</code> is a type class, since it contained two type parameters, one of which played the role of the instance type <code>Self</code>. The new version is much clearer: <code>TupleOf</code> is a type class over <code>Self</code> with one additional parameter, the common type of all tuple elements.</p></li>
     <li>
      <p>The two given definitions are obfuscated in the old code. Their version in the new code makes it clear what kind of instances they define:</p>
      <ul>
       <li><code>EmptyTuple</code> is a tuple of <code>Nothing</code>.</li>
       <li>if <code>Rest</code> is a tuple of <code>A</code>, then <code>A *: Rest</code> is also a tuple of <code>A</code>.</li>
      </ul></li>
     <li>
      <p>There's no need to introduce names for parameter instances in using clauses; the default naming scheme for context bound evidences works fine, and is more concise.</p></li>
     <li>
      <p>There's no need to manually declare implicit parameters as <code>tracked</code>, context bounds provide that automatically.</p></li>
     <li>
      <p>Everything in the new code feels like idiomatic Scala 3, whereas the original code exhibits the awkward corner case that requires a <code>with</code> in front of given definitions.</p></li>
    </ul>
   </section>
   <section id="example-3-1">
    <h3 class="h400"><a href="#example-3-1" class="anchor"></a>Example 3</h3>
    <p>Dimi Racordon tried to <a href="https://users.scala-lang.org/t/create-an-instance-of-a-type-class-with-methods-depending-on-type-members/9613">define parser combinators</a> in Scala that use dependent type members for inputs and results. It was intended as a basic example of type class constraints, but it did not work in current Scala.</p>
    <p>Here is the problem solved with the new syntax. Note how much clearer that syntax is compared to Dimi's original version, which did not work out in the end.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>/** A parser combinator */
</span><span line-number="2" class=""><span class="tooltip-container"></span>trait Combinator:
</span><span line-number="3" class=""><span class="tooltip-container"></span>  type Self
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>  type Input
</span><span line-number="6" class=""><span class="tooltip-container"></span>  type Result
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>  extension (self: Self)
</span><span line-number="9" class=""><span class="tooltip-container"></span>    /** Parses and returns an element from input `in` */
</span><span line-number="10" class=""><span class="tooltip-container"></span>    def parse(in: Input): Option[Result]
</span><span line-number="11" class=""><span class="tooltip-container"></span>end Combinator
</span><span line-number="12" class=""><span class="tooltip-container"></span>
</span><span line-number="13" class=""><span class="tooltip-container"></span>case class Apply[I, R](action: I =&gt; Option[R])
</span><span line-number="14" class=""><span class="tooltip-container"></span>case class Combine[A, B](a: A, b: B)
</span><span line-number="15" class=""><span class="tooltip-container"></span>
</span><span line-number="16" class=""><span class="tooltip-container"></span>given [I, R] =&gt; Apply[I, R] is Combinator:
</span><span line-number="17" class=""><span class="tooltip-container"></span>  type Input = I
</span><span line-number="18" class=""><span class="tooltip-container"></span>  type Result = R
</span><span line-number="19" class=""><span class="tooltip-container"></span>  extension (self: Apply[I, R])
</span><span line-number="20" class=""><span class="tooltip-container"></span>    def parse(in: I): Option[R] = self.action(in)
</span><span line-number="21" class=""><span class="tooltip-container"></span>
</span><span line-number="22" class=""><span class="tooltip-container"></span>given [A: Combinator, B: Combinator { type Input = A.Input }]
</span><span line-number="23" class=""><span class="tooltip-container"></span>    =&gt; Combine[A, B] is Combinator:
</span><span line-number="24" class=""><span class="tooltip-container"></span>  type Input = A.Input
</span><span line-number="25" class=""><span class="tooltip-container"></span>  type Result = (A.Result, B.Result)
</span><span line-number="26" class=""><span class="tooltip-container"></span>  extension (self: Combine[A, B])
</span><span line-number="27" class=""><span class="tooltip-container"></span>    def parse(in: Input): Option[Result] =
</span><span line-number="28" class=""><span class="tooltip-container"></span>      for
</span><span line-number="29" class=""><span class="tooltip-container"></span>        x &lt;- self.a.parse(in)
</span><span line-number="30" class=""><span class="tooltip-container"></span>        y &lt;- self.b.parse(in)
</span><span line-number="31" class=""><span class="tooltip-container"></span>      yield (x, y)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The example is now as expressed as straightforwardly as it should be:</p>
    <ul>
     <li><code>Combinator</code> is a type class with two associated types, <code>Input</code> and <code>Result</code>, and a <code>parse</code> method.</li>
     <li><code>Apply</code> and <code>Combine</code> are two data constructors representing parser combinators. They are declared to be <code>Combinators</code> in the two subsequent <code>given</code> declarations.</li>
     <li><code>Apply</code>'s parse method applies the <code>action</code> function to the input.</li>
     <li><code>Combine[A, B]</code> is a parser combinator provided <code>A</code> and <code>B</code> are parser combinators that process the same type of <code>Input</code>, which is also the input type of <code>Combine[A, B]</code>. Its <code>Result</code> type is a pair of the <code>Result</code> types of <code>A</code> and <code>B</code>. Results are produced by a simple for-expression.</li>
    </ul>
    <p>Compared to the original example, which required serious contortions, this is now all completely straightforward.</p>
    <p><em>Note 1:</em> One could also explore improvements, for instance making this purely functional. But that's not the point of the demonstration here, where I wanted to take the original example and show how it can be made to work with the new constructs, and be expressed more clearly as well.</p>
    <p><em>Note 2:</em> One could improve the notation even further by adding equality constraints in the style of Swift, which in turn resemble the <em>sharing constraints</em> of SML. A hypothetical syntax applied to the second given would be:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given [A: Combinator, B: Combinator with A.Input == B.Input]
</span><span line-number="2" class=""><span class="tooltip-container"></span>    =&gt; Combine[A, B] is Combinator:
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This variant is aesthetically pleasing since it makes the equality constraint symmetric. The original version had to use an asymmetric refinement on the second type parameter bound instead. For now, such constraints are neither implemented nor proposed. This is left as a possibility for future work. Note also the analogy with the work of @mbovel and @Sporarum on refinement types, where similar <code>with</code> clauses can appear for term parameters. If that work goes ahead, we could possibly revisit the issue of <code>with</code> clauses also for type parameters.</p>
   </section>
   <section id="example-4-1">
    <h3 class="h400"><a href="#example-4-1" class="anchor"></a>Example 4</h3>
    <p>Dimi Racordon tried to <a href="https://github.com/kyouko-taiga/scala-hylolib">port some core elements</a> of the type class based <a href="https://github.com/hylo-lang/hylo/tree/main/StandardLibrary/Sources">Hylo standard library to Scala</a>. It worked to some degree, but there were some things that could not be expressed, and more things that could be expressed only awkwardly.</p>
    <p>With the improvements proposed here, the library can now be expressed quite clearly and straightforwardly. See tests/pos/hylolib in this PR for details.</p>
   </section>
   <section id="suggested-improvement-unrelated-to-type-classes-1">
    <h2 class="h500"><a href="#suggested-improvement-unrelated-to-type-classes-1" class="anchor"></a>Suggested Improvement unrelated to Type Classes</h2>
    <p>The following improvement would make sense alongside the suggested changes to type classes. But it does not form part of this proposal and is not yet implemented.</p>
   </section>
   <section id="using-as-also-in-patterns-1">
    <h3 class="h400"><a href="#using-as-also-in-patterns-1" class="anchor"></a>Using <code>as</code> also in Patterns</h3>
    <p>Since we have now more precedents of <code>as</code> as a postfix binder, I want to come back to the proposal to use it in patterns as well, in favor of <code>@</code>, which should be deprecated.</p>
    <p>Examples:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  xs match
</span><span line-number="2" class=""><span class="tooltip-container"></span>    case (Person(name, age) as p) :: rest =&gt; ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>  tp match
</span><span line-number="5" class=""><span class="tooltip-container"></span>    case Param(tl, _) :: _ as tparams =&gt; ...
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>  val x :: xs1 as xs = ys.checkedCast
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>These would replace the previous syntax using <code>@</code>:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>  xs match
</span><span line-number="2" class=""><span class="tooltip-container"></span>    case p @ Person(name, age) :: rest =&gt; ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>  tp match
</span><span line-number="5" class=""><span class="tooltip-container"></span>    case tparams @ (Param(tl, _) :: _) =&gt; ...
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>  val xs @ (x :: xs1) = ys.checkedCast
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><strong>Advantages:</strong> No unpronounceable and non-standard symbol like <code>@</code>. More regularity.</p>
    <p>Generally, we want to use <code>as name</code> to attach a name for some entity that could also have been used stand-alone.</p>
    <p><strong>Proposed Syntax Change</strong></p>
    <div class="snippet mono-small-block">
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>Pattern2          ::=  InfixPattern ['as' id]
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="summary-5">
    <h2 class="h500"><a href="#summary-5" class="anchor"></a>Summary</h2>
    <p>I have proposed some tweaks to Scala 3, which would increase its usability for modular, type class based, generic programming. The proposed changes are:</p>
    <ol>
     <li>Allow context bounds over classes that define a <code>Self</code> member type.</li>
     <li>Add a predefined type alias <code>is</code>.</li>
     <li>If a type parameter or member <code>T</code> has context bound <code>CB</code>, use <code>T</code> as the default name for the witness of <code>CB</code>.</li>
     <li>Cleanup <code>Singleton</code> and add a new trait <code>Precise</code> for non-widening instantiation of type variables.,</li>
    </ol>
   </section>
   <section id="conclusion-1">
    <h2 class="h500"><a href="#conclusion-1" class="anchor"></a>Conclusion</h2>
    <p>Generic programming can be expressed in a number of languages. For instance, with type classes in Haskell, or with traits in Rust, or with protocols in Swift, or with concepts in C++. Each of these is constructed from a fairly heavyweight set of new constructs, different from expressions and types. By contrast, equivalent solutions in Scala rely on regular types. Type classes are simply traits that define a <code>Self</code> type member.</p>
    <p>The proposed scheme has similar expressiveness to Protocols in Swift or Traits in Rust. Both of these were largely influenced by Jeremy Siek's PdD thesis "<a href="https://scholarworks.iu.edu/dspace/handle/2022/7067">A language for generic programming</a>", which was first proposed as a way to implement concepts in C++. C++ did not follow Siek's approach, but Swift and Rust did.</p>
    <p>In Siek's thesis and in the formal treatments of Rust and Swift, type class concepts are explained by mapping them to a lower level language of explicit dictionaries with representations for terms and types. Crucially, that lower level is not expressible without loss of granularity in the source language itself, since type representations are mapped to term dictionaries. By contrast, the current proposal expands type class concepts into other well-typed Scala constructs, which ultimately map into well-typed DOT programs. Type classes are simply a convenient notation for something that can already be expressed in Scala. In that sense, we stay true to the philosophy of a <em>scalable language</em>, where a small core can support a large range of advanced use cases.</p>
   </section>
  </main>
  <div class="divider"></div>
  <nav class="arrow-navigation" aria-label="Page navigation">
   <div>
    <span class="body-small">Previous</span> <a rel="prev" href="modularity.html" aria-keyshortcuts="Left" class="body-medium"> <span class="body-medium">Modularity Improvements</span> </a>
   </div>
   <div>
    <span class="body-small">Next</span> <a rel="next" href="runtimeChecked.html" aria-keyshortcuts="Right" class="body-medium"> <span class="body-medium">The runtimeChecked method</span> </a>
   </div>
  </nav>
 </div>
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#generalizing-context-bounds-1">Generalizing Context Bounds</a></li><li><a href="#auxiliary-type-alias-is-1">Auxiliary Type Alias is</a><ul><li><a href="#better-default-names-for-context-bounds-1">Better Default Names for Context Bounds</a></li></ul></li><li><a href="#fixing-singleton-1">Fixing Singleton</a></li><li><a href="#examples-13">Examples</a><ul><li><a href="#example-1-1">Example 1</a></li><li><a href="#example-2-1">Example 2</a></li><li><a href="#example-3-1">Example 3</a></li><li><a href="#example-4-1">Example 4</a></li></ul></li><li><a href="#suggested-improvement-unrelated-to-type-classes-1">Suggested Improvement unrelated to Type Classes</a><ul><li><a href="#using-as-also-in-patterns-1">Using as also in Patterns</a></li></ul></li><li><a href="#summary-5">Summary</a></li><li><a href="#conclusion-1">Conclusion</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div></div></div></body></html>