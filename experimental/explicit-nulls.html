<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/scala/scala3" data-githubContributorsFilename="docs/_docs/reference/experimental/explicit-nulls.md" data-pathToRoot="../" data-rawLocation="experimental/explicit-nulls" data-dynamicSideMenu="false"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Explicit Nulls</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="/css/dottydoc.css"></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.6.4</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../index.html">Docs</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni n1 "><span class="nh de"><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni n1 "><span class="nh de"><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/deferred-givens.html"><span>Deferred Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/more-givens.html"><span>Other Forms Of Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/previous-givens.html"><span>Previous Given Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/staging.html"><span>Run-Time Multi-Stage Programming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits and Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/binary-literals.html"><span>Binary Integer Literals</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>Experimental</span></a></span><div class="ni n1 "><span class="nh de"><a href="canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 expanded"><span class="nh h100 selected de"><a href="#"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="cc.html"><span>Capture Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="tupled-function.html"><span>Tupled Function</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Experimental</a>/<a href="explicit-nulls.html">Explicit Nulls</a></div><div id="content" class="body-medium"><div><div id="content-wrapper">
 <div class="site-container">
  <div id="site-header"></div>
  <main>
   <header>
    <a class="text-button with-link body-small" href="https://github.com/scala/scala3/edit/language-reference-stable/docs/_docs/reference/experimental/explicit-nulls.md">Edit this page on GitHub</a>
    <h1 class="h600">Explicit Nulls</h1>
   </header>
   <p class="body-large first-p">Explicit nulls is an opt-in feature that modifies the Scala type system, which makes reference types (anything that extends <a href="https://scala-lang.org/api/3.x/scala/AnyRef.html"><code>AnyRef</code></a>) <em>non-nullable</em>.</p>
   <p>This means the following code will no longer typecheck:</p>
   <div class="snippet mono-small-block" scala-snippet="">
    <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val x: String = null // error: found `Null`, but required `String`
</span></code></pre>
    <div class="buttons"></div>
   </div>
   <p>Instead, to mark a type as nullable we use a <a href="../new-types/union-types.html">union type</a></p>
   <div class="snippet mono-small-block" scala-snippet="">
    <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val x: String | Null = null // ok
</span></code></pre>
    <div class="buttons"></div>
   </div>
   <p>A nullable type could have null value during runtime; hence, it is not safe to select a member without checking its nullity.</p>
   <div class="snippet mono-small-block" scala-snippet="">
    <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>x.trim // error: trim is not member of String | Null
</span></code></pre>
    <div class="buttons"></div>
   </div>
   <p>Explicit nulls are enabled via a <code>-Yexplicit-nulls</code> flag.</p>
   <p>Read on for details.</p>
   <section id="new-type-hierarchy-1">
    <h2 class="h500"><a href="#new-type-hierarchy-1" class="anchor"></a>New Type Hierarchy</h2>
    <p>Originally, <code>Null</code> is a subtype of all reference types.</p>
    <p><img src="../images/explicit-nulls/scalaHierarchyWithMatchable.png" alt="&quot;Original Type Hierarchy&quot;"></p>
    <p>When explicit nulls is enabled, the type hierarchy changes so that <code>Null</code> is only a subtype of <code>Any</code> and <code>Matchable</code>, as opposed to every reference type, which means <code>null</code> is no longer a value of <code>AnyRef</code> and its subtypes.</p>
    <p>This is the new type hierarchy:</p>
    <p><img src="../images/explicit-nulls/scalaHierarchyWithMatchableAndSafeNull.png" alt="&quot;Type Hierarchy for Explicit Nulls&quot;"></p>
    <p>After erasure, <code>Null</code> remains a subtype of all reference types (as forced by the JVM).</p>
   </section>
   <section id="working-with-null-1">
    <h2 class="h500"><a href="#working-with-null-1" class="anchor"></a>Working with <code>Null</code></h2>
    <p>To make working with nullable values easier, we propose adding a few utilities to the standard library. So far, we have found the following useful:</p>
    <ul>
     <li>
      <p>An extension method <code>.nn</code> to "cast away" nullability</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable"> </span>extension [T](x: T | Null)
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable"> </span>  inline def nn: T =
</span><span line-number="3" class=""><span class="tooltip-container"></span><span class="hideable"> </span>    assert(x != null)
</span><span line-number="4" class=""><span class="tooltip-container"></span><span class="hideable"> </span>    x.asInstanceOf[T]
</span></code></pre>
       <div class="buttons"></div>
      </div>
      <p>This means that given <code>x: String | Null</code>, <code>x.nn</code> has type <code>String</code>, so we can call all the usual methods on it. Of course, <code>x.nn</code> will throw a NPE if <code>x</code> is <code>null</code>.</p>
      <p>Don't use <code>.nn</code> on mutable variables directly, because it may introduce an unknown type into the type of the variable.</p></li>
     <li>
      <p>An <a href="https://scala-lang.org/api/3.x/scala/runtime/stdLibPatches/language$$unsafeNulls$.html"><code>unsafeNulls</code></a> language feature.</p>
      <p>When imported, <code>T | Null</code> can be used as <code>T</code>, similar to regular Scala (without explicit nulls).</p>
      <p>See <a href="#unsafenulls">UnsafeNulls</a> section for more details.</p></li>
    </ul>
   </section>
   <section id="unsoundness-1">
    <h2 class="h500"><a href="#unsoundness-1" class="anchor"></a>Unsoundness</h2>
    <p>The new type system is unsound with respect to <code>null</code>. This means there are still instances where an expression has a non-nullable type like <code>String</code>, but its value is actually <code>null</code>.</p>
    <p>The unsoundness happens because uninitialized fields in a class start out as <code>null</code>:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class C:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val f: String = foo(f)
</span><span line-number="3" class=""><span class="tooltip-container"></span>  def foo(f2: String): String = f2
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>val c = new C()
</span><span line-number="6" class=""><span class="tooltip-container"></span>// c.f == "field is null"
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The unsoundness above can be caught by the compiler with the option <code>-Wsafe-init</code>. More details can be found in <a href="../other-new-features/safe-initialization.html">safe initialization</a>.</p>
   </section>
   <section id="equality-1">
    <h2 class="h500"><a href="#equality-1" class="anchor"></a>Equality</h2>
    <p>We don't allow the double-equal (<code>==</code> and <code>!=</code>) and reference (<code>eq</code> and <code>ne</code>) comparison between <code>AnyRef</code> and <code>Null</code> anymore, since a variable with a non-nullable type cannot have <code>null</code> as value. <code>null</code> can only be compared with <code>Null</code>, nullable union (<code>T | Null</code>), or <code>Any</code> type.</p>
    <p>For some reason, if we really want to compare <code>null</code> with non-null values, we have to provide a type hint (e.g. <code>: Any</code>).</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val x: String = ???
</span><span line-number="2" class=""><span class="tooltip-container"></span>val y: String | Null = ???
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>x == null       // error: Values of types String and Null cannot be compared with == or !=
</span><span line-number="5" class=""><span class="tooltip-container"></span>x eq null       // error
</span><span line-number="6" class=""><span class="tooltip-container"></span>"hello" == null // error
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>y == null       // ok
</span><span line-number="9" class=""><span class="tooltip-container"></span>y == x          // ok
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>(x: String | Null) == null  // ok
</span><span line-number="12" class=""><span class="tooltip-container"></span>(x: Any) == null            // ok
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="java-interoperability-and-flexible-types-1">
    <h2 class="h500"><a href="#java-interoperability-and-flexible-types-1" class="anchor"></a>Java Interoperability and Flexible Types</h2>
    <p>When dealing with reference types from Java, it's essential to address the implicit nullability of these types. The most accurate way to represent them in Scala is to use nullable types, though working with lots of nullable types directly can be annoying. To streamline interactions with Java libraries, we introduce the concept of flexible types.</p>
    <p>The flexible type, denoted by <code>T?</code>, functions as an abstract type with unique bounds: <code>T | Null ... T</code>, ensuring that <code>T | Null &lt;: T? &lt;: T</code>. The subtyping rule treats a reference type coming from Java as either nullable or non-nullable depending on the context. This concept draws inspiration from Kotlin's <a href="https://kotlinlang.org/docs/java-interop.html#null-safety-and-platform-types">platform types</a>. By relaxing null checks for such types, Scala aligns its safety guarantees with those of Java. Notably, flexible types are non-denotable, meaning users cannot explicitly write them in the code; only the compiler can construct or infer these types.</p>
    <p>Consequently, a value with a flexible type can serve as both a nullable and non-nullable value. Additionally, both nullable and non-nullable values can be passed as parameters with flexible types during function calls. Invoking the member functions of a flexible type is allowed, but it can trigger a <code>NullPointerException</code> if the value is indeed <code>null</code> during runtime.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// Considering class J is from Java
</span><span line-number="2" class=""><span class="tooltip-container"></span>class J {
</span><span line-number="3" class=""><span class="tooltip-container"></span>  // Translates to def f(s: String?): Unit
</span><span line-number="4" class=""><span class="tooltip-container"></span>  public void f(String s) {
</span><span line-number="5" class=""><span class="tooltip-container"></span>  }
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>  // Translates to def g(): String?
</span><span line-number="8" class=""><span class="tooltip-container"></span>  public String g() {
</span><span line-number="9" class=""><span class="tooltip-container"></span>    return "";
</span><span line-number="10" class=""><span class="tooltip-container"></span>  }
</span><span line-number="11" class=""><span class="tooltip-container"></span>}
</span><span line-number="12" class=""><span class="tooltip-container"></span>
</span><span line-number="13" class=""><span class="tooltip-container"></span>// Use J in Scala
</span><span line-number="14" class=""><span class="tooltip-container"></span>def useJ(j: J) =
</span><span line-number="15" class=""><span class="tooltip-container"></span>  val x1: String = ""
</span><span line-number="16" class=""><span class="tooltip-container"></span>  val x2: String | Null = null
</span><span line-number="17" class=""><span class="tooltip-container"></span>  j.f(x1) // Passing String to String?
</span><span line-number="18" class=""><span class="tooltip-container"></span>  j.f(x2) // Passing String | Null to String?
</span><span line-number="19" class=""><span class="tooltip-container"></span>  j.f(null) // Passing Null to String?
</span><span line-number="20" class=""><span class="tooltip-container"></span>
</span><span line-number="21" class=""><span class="tooltip-container"></span>  // Assign String? to String
</span><span line-number="22" class=""><span class="tooltip-container"></span>  val y1: String = j.g()
</span><span line-number="23" class=""><span class="tooltip-container"></span>  // Assign String? to String | Null
</span><span line-number="24" class=""><span class="tooltip-container"></span>  val y2: String | Null = j.g()
</span><span line-number="25" class=""><span class="tooltip-container"></span>
</span><span line-number="26" class=""><span class="tooltip-container"></span>  // Calling member functions on flexible types
</span><span line-number="27" class=""><span class="tooltip-container"></span>  j.g().trim().length()
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Upon loading a Java class, whether from source or bytecode, the Scala compiler dynamically adjusts the type of its members to reflect nullability. This adjustment involves adding flexible types to the reference types of fields, as well as the argument types and return types of methods</p>
    <p>We illustrate the rules with following examples:</p>
    <ul>
     <li>
      <p>The first two rules are easy: we nullify reference types but not value types.</p>
      <div class="snippet mono-small-block">
       <pre><code class="language-java"><span line-number="1" class=""><span class="tooltip-container"></span>class C {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  String s;
</span><span line-number="3" class=""><span class="tooltip-container"></span>  int x;
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
       <div class="buttons"></div>
      </div>
      <p>==&gt;</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class C:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val s: String?
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val x: Int
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
     <li>
      <p>We nullify type parameters because in Java a type parameter is always nullable, so the following code compiles.</p>
      <div class="snippet mono-small-block">
       <pre><code class="language-java"><span line-number="1" class=""><span class="tooltip-container"></span>class C&lt;T&gt; { T foo() { return null; } }
</span></code></pre>
       <div class="buttons"></div>
      </div>
      <p>==&gt;</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class C[T] { def foo(): T? }
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
     <li>
      <p>We can reduce the number of redundant nullable types we need to add. Consider</p>
      <div class="snippet mono-small-block">
       <pre><code class="language-java"><span line-number="1" class=""><span class="tooltip-container"></span>class Box&lt;T&gt; { T get(); }
</span><span line-number="2" class=""><span class="tooltip-container"></span>class BoxFactory&lt;T&gt; { Box&lt;T&gt; makeBox(); }
</span></code></pre>
       <div class="buttons"></div>
      </div>
      <p>==&gt;</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class Box[T] { def get(): T? }
</span><span line-number="2" class=""><span class="tooltip-container"></span>class BoxFactory[T] { def makeBox(): Box[T]? }
</span></code></pre>
       <div class="buttons"></div>
      </div>
      <p>Suppose we have a <code>BoxFactory[String]</code>. Notice that calling <code>makeBox()</code> on it returns a <code>Box[T]?</code>, not a <code>Box[T?]?</code>. This seems at first glance unsound ("What if the box itself has <code>null</code> inside?"), but is sound because calling <code>get()</code> on a <code>Box[String]</code> returns a <code>String?</code>.</p>
      <p>Notice that we need to patch <em>all</em> Java-defined classes that transitively appear in the argument or return type of a field or method accessible from the Scala code being compiled. Absent crazy reflection magic, we think that all such Java classes <em>must</em> be visible to the Typer in the first place, so they will be patched.</p></li>
     <li>
      <p>We will patch the type arguments if the generic class is defined in Scala.</p>
      <div class="snippet mono-small-block">
       <pre><code class="language-java"><span line-number="1" class=""><span class="tooltip-container"></span>class BoxFactory&lt;T&gt; {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  Box&lt;T&gt; makeBox(); // Box is Scala-defined
</span><span line-number="3" class=""><span class="tooltip-container"></span>  List&lt;Box&lt;List&lt;T&gt;&gt;&gt; makeCrazyBoxes(); // List is Java-defined
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
       <div class="buttons"></div>
      </div>
      <p>==&gt;</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class BoxFactory[T]:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def makeBox(): Box[T?]?
</span><span line-number="3" class=""><span class="tooltip-container"></span>  def makeCrazyBoxes(): java.util.List[Box[java.util.List[T]?]]?
</span></code></pre>
       <div class="buttons"></div>
      </div>
      <p>In this case, since <code>Box</code> is Scala-defined, we will get <code>Box[T?]?</code>. This is needed because our nullability function is only applied (modularly) to the Java classes, but not to the Scala ones, so we need a way to tell <code>Box</code> that it contains a nullable value.</p>
      <p>The <code>List</code> is Java-defined, so we don't patch its type argument. But we still need to nullify its inside.</p></li>
     <li>
      <p>We don't nullify <em>simple</em> literal constant (<code>final</code>) fields, since they are known to be non-null</p>
      <div class="snippet mono-small-block">
       <pre><code class="language-java"><span line-number="1" class=""><span class="tooltip-container"></span>class Constants {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  final String NAME = "name";
</span><span line-number="3" class=""><span class="tooltip-container"></span>  final int AGE = 0;
</span><span line-number="4" class=""><span class="tooltip-container"></span>  final char CHAR = 'a';
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  final String NAME_GENERATED = getNewName();
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre>
       <div class="buttons"></div>
      </div>
      <p>==&gt;</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class Constants:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val NAME: String("name") = "name"
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val AGE: Int(0) = 0
</span><span line-number="4" class=""><span class="tooltip-container"></span>  val CHAR: Char('a') = 'a'
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  val NAME_GENERATED: String | Null = getNewName()
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
     <li>
      <p>We don't patch a field nor to a return type of a method which is annotated with a <code>NotNull</code> annotation.</p>
      <div class="snippet mono-small-block">
       <pre><code class="language-java"><span line-number="1" class=""><span class="tooltip-container"></span>class C {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  @NotNull String name;
</span><span line-number="3" class=""><span class="tooltip-container"></span>  @NotNull List&lt;String&gt; getNames(String prefix); // List is Java-defined
</span><span line-number="4" class=""><span class="tooltip-container"></span>  @NotNull Box&lt;String&gt; getBoxedName(); // Box is Scala-defined
</span><span line-number="5" class=""><span class="tooltip-container"></span>}
</span></code></pre>
       <div class="buttons"></div>
      </div>
      <p>==&gt;</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class C:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val name: String
</span><span line-number="3" class=""><span class="tooltip-container"></span>  def getNames(prefix: String?): java.util.List[String] // we still need to nullify the paramter types
</span><span line-number="4" class=""><span class="tooltip-container"></span>  def getBoxedName(): Box[String?] // we don't append `Null` to the outmost level, but we still need to nullify inside
</span></code></pre>
       <div class="buttons"></div>
      </div>
      <p>The annotation must be from the list below to be recognized as <code>NotNull</code> by the compiler. Check <code>Definitions.scala</code> for an updated list.</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// A list of annotations that are commonly used to indicate
</span><span line-number="2" class=""><span class="tooltip-container"></span>// that a field/method argument or return type is not null.
</span><span line-number="3" class=""><span class="tooltip-container"></span>// These annotations are used by the nullification logic in
</span><span line-number="4" class=""><span class="tooltip-container"></span>// JavaNullInterop to improve the precision of type nullification.
</span><span line-number="5" class=""><span class="tooltip-container"></span>// We don't require that any of these annotations be present
</span><span line-number="6" class=""><span class="tooltip-container"></span>// in the class path, but we want to create Symbols for the
</span><span line-number="7" class=""><span class="tooltip-container"></span>// ones that are present, so they can be checked during nullification.
</span><span line-number="8" class=""><span class="tooltip-container"></span>@tu lazy val NotNullAnnots: List[ClassSymbol] = ctx.getClassesIfDefined(
</span><span line-number="9" class=""><span class="tooltip-container"></span>  "javax.annotation.Nonnull" ::
</span><span line-number="10" class=""><span class="tooltip-container"></span>  "edu.umd.cs.findbugs.annotations.NonNull" ::
</span><span line-number="11" class=""><span class="tooltip-container"></span>  "androidx.annotation.NonNull" ::
</span><span line-number="12" class=""><span class="tooltip-container"></span>  "android.support.annotation.NonNull" ::
</span><span line-number="13" class=""><span class="tooltip-container"></span>  "android.annotation.NonNull" ::
</span><span line-number="14" class=""><span class="tooltip-container"></span>  "com.android.annotations.NonNull" ::
</span><span line-number="15" class=""><span class="tooltip-container"></span>  "org.eclipse.jdt.annotation.NonNull" ::
</span><span line-number="16" class=""><span class="tooltip-container"></span>  "org.checkerframework.checker.nullness.qual.NonNull" ::
</span><span line-number="17" class=""><span class="tooltip-container"></span>  "org.checkerframework.checker.nullness.compatqual.NonNullDecl" ::
</span><span line-number="18" class=""><span class="tooltip-container"></span>  "org.jetbrains.annotations.NotNull" ::
</span><span line-number="19" class=""><span class="tooltip-container"></span>  "lombok.NonNull" ::
</span><span line-number="20" class=""><span class="tooltip-container"></span>  "io.reactivex.annotations.NonNull" :: Nil map PreNamedString)
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
    </ul>
    <p>Flexible types can be disabled by using <code>-Yno-flexible-types</code> flag. The ordinary union type <code>| Null</code> will be used instead.</p>
   </section>
   <section id="override-check-1">
    <h3 class="h400"><a href="#override-check-1" class="anchor"></a>Override check</h3>
    <p>When we check overriding between Scala classes and Java classes, the rules are relaxed for <a href="https://scala-lang.org/api/3.x/scala/Null.html"><code>Null</code></a> type with this feature, in order to help users to working with Java libraries.</p>
    <p>Suppose we have Java method <code>String f(String x)</code>, we can override this method in Scala in any of the following forms:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def f(x: String | Null): String | Null
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>def f(x: String): String | Null
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>def f(x: String | Null): String
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>def f(x: String): String
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Note that some of the definitions could cause unsoundness. For example, the return type is not nullable, but a <code>null</code> value is actually returned.</p>
   </section>
   <section id="flow-typing-1">
    <h2 class="h500"><a href="#flow-typing-1" class="anchor"></a>Flow Typing</h2>
    <p>We added a simple form of flow-sensitive type inference. The idea is that if <code>p</code> is a stable path or a trackable variable, then we can know that <code>p</code> is non-null if it's compared with <code>null</code>. This information can then be propagated to the <code>then</code> and <code>else</code> branches of an if-statement (among other places).</p>
    <p>Example:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val s: String | Null = ???
</span><span line-number="2" class=""><span class="tooltip-container"></span>if s != null then
</span><span line-number="3" class=""><span class="tooltip-container"></span>  // s: String
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>// s: String | Null
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>assert(s != null)
</span><span line-number="8" class=""><span class="tooltip-container"></span>// s: String
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>A similar inference can be made for the <code>else</code> case if the test is <code>p == null</code></p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>if s == null then
</span><span line-number="2" class=""><span class="tooltip-container"></span>  // s: String | Null
</span><span line-number="3" class=""><span class="tooltip-container"></span>else
</span><span line-number="4" class=""><span class="tooltip-container"></span>  // s: String
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><code>==</code> and <code>!=</code> is considered a comparison for the purposes of the flow inference.</p>
   </section>
   <section id="logical-operators-1">
    <h3 class="h400"><a href="#logical-operators-1" class="anchor"></a>Logical Operators</h3>
    <p>We also support logical operators (<code>&amp;&amp;</code>, <code>||</code>, and <code>!</code>):</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val s: String | Null = ???
</span><span line-number="2" class=""><span class="tooltip-container"></span>val s2: String | Null = ???
</span><span line-number="3" class=""><span class="tooltip-container"></span>if s != null &amp;&amp; s2 != null then
</span><span line-number="4" class=""><span class="tooltip-container"></span>  // s: String
</span><span line-number="5" class=""><span class="tooltip-container"></span>  // s2: String
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>if s == null || s2 == null then
</span><span line-number="8" class=""><span class="tooltip-container"></span>  // s: String | Null
</span><span line-number="9" class=""><span class="tooltip-container"></span>  // s2: String | Null
</span><span line-number="10" class=""><span class="tooltip-container"></span>else
</span><span line-number="11" class=""><span class="tooltip-container"></span>  // s: String
</span><span line-number="12" class=""><span class="tooltip-container"></span>  // s2: String
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="inside-conditions-1">
    <h3 class="h400"><a href="#inside-conditions-1" class="anchor"></a>Inside Conditions</h3>
    <p>We also support type specialization <em>within</em> the condition, taking into account that <code>&amp;&amp;</code> and <code>||</code> are short-circuiting:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val s: String | Null = ???
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>if s != null &amp;&amp; s.length &gt; 0 then // s: String in `s.length &gt; 0`
</span><span line-number="4" class=""><span class="tooltip-container"></span>  // s: String
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>if s == null || s.length &gt; 0 then // s: String in `s.length &gt; 0`
</span><span line-number="7" class=""><span class="tooltip-container"></span>  // s: String | Null
</span><span line-number="8" class=""><span class="tooltip-container"></span>else
</span><span line-number="9" class=""><span class="tooltip-container"></span>  // s: String
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="match-case-1">
    <h3 class="h400"><a href="#match-case-1" class="anchor"></a>Match Case</h3>
    <p>The non-null cases can be detected in match statements.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val s: String | Null = ???
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>s match
</span><span line-number="4" class=""><span class="tooltip-container"></span>  case _: String =&gt; // s: String
</span><span line-number="5" class=""><span class="tooltip-container"></span>  case _ =&gt;
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="mutable-variable-1">
    <h3 class="h400"><a href="#mutable-variable-1" class="anchor"></a>Mutable Variable</h3>
    <p>We are able to detect the nullability of some local mutable variables. A simple example is:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class C(val x: Int, val next: C | Null)
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>var xs: C | Null = C(1, C(2, null))
</span><span line-number="4" class=""><span class="tooltip-container"></span>// xs is trackable, since all assignments are in the same method
</span><span line-number="5" class=""><span class="tooltip-container"></span>while xs != null do
</span><span line-number="6" class=""><span class="tooltip-container"></span>  // xs: C
</span><span line-number="7" class=""><span class="tooltip-container"></span>  val xsx: Int = xs.x
</span><span line-number="8" class=""><span class="tooltip-container"></span>  val xscpy: C = xs
</span><span line-number="9" class=""><span class="tooltip-container"></span>  xs = xscpy // since xscpy is non-null, xs still has type C after this line
</span><span line-number="10" class=""><span class="tooltip-container"></span>  // xs: C
</span><span line-number="11" class=""><span class="tooltip-container"></span>  xs = xs.next // after this assignment, xs can be null again
</span><span line-number="12" class=""><span class="tooltip-container"></span>  // xs: C | Null
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>When dealing with local mutable variables, there are two questions:</p>
    <ol>
     <li>
      <p>Whether to track a local mutable variable during flow typing. We track a local mutable variable if the variable is not assigned in a closure. For example, in the following code <code>x</code> is assigned to by the closure <code>y</code>, so we do not do flow typing on <code>x</code>.</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>var x: String | Null = ???
</span><span line-number="2" class=""><span class="tooltip-container"></span>def y =
</span><span line-number="3" class=""><span class="tooltip-container"></span>  x = null
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>if x != null then
</span><span line-number="6" class=""><span class="tooltip-container"></span>   // y can be called here, which would break the fact
</span><span line-number="7" class=""><span class="tooltip-container"></span>   val a: String = x // error: x is captured and mutated by the closure, not trackable
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
     <li>
      <p>Whether to generate and use flow typing on a specific <em>use</em> of a local mutable variable. We only want to do flow typing on a use that belongs to the same method as the definition of the local variable. For example, in the following code, even <code>x</code> is not assigned to by a closure, we can only use flow typing in one of the occurrences (because the other occurrence happens within a nested closure).</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>var x: String | Null = ???
</span><span line-number="2" class=""><span class="tooltip-container"></span>def y =
</span><span line-number="3" class=""><span class="tooltip-container"></span>  if x != null then
</span><span line-number="4" class=""><span class="tooltip-container"></span>    // not safe to use the fact (x != null) here
</span><span line-number="5" class=""><span class="tooltip-container"></span>    // since y can be executed at the same time as the outer block
</span><span line-number="6" class=""><span class="tooltip-container"></span>    val _: String = x
</span><span line-number="7" class=""><span class="tooltip-container"></span>if x != null then
</span><span line-number="8" class=""><span class="tooltip-container"></span>  val a: String = x // ok to use the fact here
</span><span line-number="9" class=""><span class="tooltip-container"></span>  x = null
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
    </ol>
    <p>See <a href="https://github.com/scala/scala3/blob/main/tests/explicit-nulls/neg/flow-varref-in-closure.scala">more examples</a>.</p>
    <p>Currently, we are unable to track paths with a mutable variable prefix. For example, <code>x.a</code> if <code>x</code> is mutable.</p>
   </section>
   <section id="unsupported-idioms-1">
    <h3 class="h400"><a href="#unsupported-idioms-1" class="anchor"></a>Unsupported Idioms</h3>
    <p>We don't support:</p>
    <ul>
     <li>
      <p>flow facts not related to nullability (<code>if x == 0 then { // x: 0.type not inferred }</code>)</p></li>
     <li>
      <p>tracking aliasing between non-nullable paths</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val s: String | Null = ???
</span><span line-number="2" class=""><span class="tooltip-container"></span>val s2: String | Null = ???
</span><span line-number="3" class=""><span class="tooltip-container"></span>if s != null &amp;&amp; s == s2 then
</span><span line-number="4" class=""><span class="tooltip-container"></span>  // s:  String inferred
</span><span line-number="5" class=""><span class="tooltip-container"></span>  // s2: String not inferred
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
    </ul>
   </section>
   <section id="unsafenulls-1">
    <h3 class="h400"><a href="#unsafenulls-1" class="anchor"></a>UnsafeNulls</h3>
    <p>It is difficult to work with many nullable values, we introduce a language feature <a href="https://scala-lang.org/api/3.x/scala/runtime/stdLibPatches/language$$unsafeNulls$.html"><code>unsafeNulls</code></a>. Inside this "unsafe" scope, all <code>T | Null</code> values can be used as <code>T</code>.</p>
    <p>Users can import <a href="https://scala-lang.org/api/3.x/scala/runtime/stdLibPatches/language$$unsafeNulls$.html"><code>scala.language.unsafeNulls</code></a> to create such scopes, or use <code>-language:unsafeNulls</code> to enable this feature globally (for migration purpose only).</p>
    <p>Assume <code>T</code> is a reference type (a subtype of <code>AnyRef</code>), the following unsafe operation rules are applied in this unsafe-nulls scope:</p>
    <ol>
     <li>
      <p>the members of <code>T</code> can be found on <code>T | Null</code></p></li>
     <li>
      <p>a value with type <code>T</code> can be compared with <code>T | Null</code> and <code>Null</code></p></li>
     <li>
      <p>suppose <code>T1</code> is not a subtype of <code>T2</code> using explicit-nulls subtyping (where <code>Null</code> is a direct subtype of Any), extension methods and implicit conversions designed for <code>T2</code> can be used for <code>T1</code> if <code>T1</code> is a subtype of <code>T2</code> using regular subtyping rules (where <code>Null</code> is a subtype of every reference type)</p></li>
     <li>
      <p>suppose <code>T1</code> is not a subtype of <code>T2</code> using explicit-nulls subtyping, a value with type <code>T1</code> can be used as <code>T2</code> if <code>T1</code> is a subtype of <code>T2</code> using regular subtyping rules</p></li>
    </ol>
    <p>Addtionally, <code>null</code> can be used as <code>AnyRef</code> (<code>Object</code>), which means you can select <code>.eq</code> or <code>.toString</code> on it.</p>
    <p>The program in <a href="https://scala-lang.org/api/3.x/scala/runtime/stdLibPatches/language$$unsafeNulls$.html"><code>unsafeNulls</code></a> will have a <strong>similar</strong> semantic as regular Scala, but not <strong>equivalent</strong>.</p>
    <p>For example, the following code cannot be compiled even using unsafe nulls. Because of the Java interoperation, the type of the get method becomes <code>T | Null</code>.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def head[T](xs: java.util.List[T]): T = xs.get(0) // error
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Since the compiler doesn’t know whether <code>T</code> is a reference type, it is unable to cast <code>T | Null</code> to <code>T</code>. A <code>.nn</code> need to be inserted after <code>xs.get(0)</code> by user manually to fix the error, which strips the <code>Null</code> from its type.</p>
    <p>The intention of this <a href="https://scala-lang.org/api/3.x/scala/runtime/stdLibPatches/language$$unsafeNulls$.html"><code>unsafeNulls</code></a> is to give users a better migration path for explicit nulls. Projects for Scala 2 or regular Scala 3 can try this by adding <code>-Yexplicit-nulls -language:unsafeNulls</code> to the compile options. A small number of manual modifications are expected. To migrate to the full explicit nulls feature in the future, <code>-language:unsafeNulls</code> can be dropped and add <code>import scala.language.unsafeNulls</code> only when needed.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def f(x: String): String = ???
</span><span line-number="2" class=""><span class="tooltip-container"></span>def nullOf[T &gt;: Null]: T = null
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>import scala.language.unsafeNulls
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>val s: String | Null = ???
</span><span line-number="7" class=""><span class="tooltip-container"></span>val a: String = s // unsafely convert String | Null to String
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>val b1 = s.trim // call .trim on String | Null unsafely
</span><span line-number="10" class=""><span class="tooltip-container"></span>val b2 = b1.length
</span><span line-number="11" class=""><span class="tooltip-container"></span>
</span><span line-number="12" class=""><span class="tooltip-container"></span>f(s).trim // pass String | Null as an argument of type String unsafely
</span><span line-number="13" class=""><span class="tooltip-container"></span>
</span><span line-number="14" class=""><span class="tooltip-container"></span>val c: String = null // Null to String
</span><span line-number="15" class=""><span class="tooltip-container"></span>
</span><span line-number="16" class=""><span class="tooltip-container"></span>val d1: Array[String] = ???
</span><span line-number="17" class=""><span class="tooltip-container"></span>val d2: Array[String | Null] = d1 // unsafely convert Array[String] to Array[String | Null]
</span><span line-number="18" class=""><span class="tooltip-container"></span>val d3: Array[String] = Array(null) // unsafe
</span><span line-number="19" class=""><span class="tooltip-container"></span>
</span><span line-number="20" class=""><span class="tooltip-container"></span>class C[T &gt;: Null &lt;: String] // define a type bound with unsafe conflict bound
</span><span line-number="21" class=""><span class="tooltip-container"></span>
</span><span line-number="22" class=""><span class="tooltip-container"></span>val n = nullOf[String] // apply a type bound unsafely
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Without the <a href="https://scala-lang.org/api/3.x/scala/runtime/stdLibPatches/language$$unsafeNulls$.html"><code>unsafeNulls</code></a>, all these unsafe operations will not be type-checked.</p>
    <p><a href="https://scala-lang.org/api/3.x/scala/runtime/stdLibPatches/language$$unsafeNulls$.html"><code>unsafeNulls</code></a> also works for extension methods and implicit search.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.language.unsafeNulls
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>val x = "hello, world!".split(" ").map(_.length)
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>given Conversion[String, Array[String]] = _ =&gt; ???
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>val y: String | Null = ???
</span><span line-number="8" class=""><span class="tooltip-container"></span>val z: Array[String | Null] = y
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="binary-compatibility-1">
    <h2 class="h500"><a href="#binary-compatibility-1" class="anchor"></a>Binary Compatibility</h2>
    <p>Our strategy for binary compatibility with Scala binaries that predate explicit nulls and new libraries compiled without <code>-Yexplicit-nulls</code> is to leave the types unchanged and be compatible but unsound.</p>
    <p><a href="https://dotty.epfl.ch/docs/internals/explicit-nulls.html">Implementation details</a></p>
   </section>
  </main>
  <div class="divider"></div>
  <nav class="arrow-navigation" aria-label="Page navigation">
   <div>
    <span class="body-small">Previous</span> <a rel="prev" href="numeric-literals.html" aria-keyshortcuts="Left" class="body-medium"> <span class="body-medium">Numeric Literals</span> </a>
   </div>
   <div>
    <span class="body-small">Next</span> <a rel="next" href="main-annotation.html" aria-keyshortcuts="Right" class="body-medium"> <span class="body-medium">MainAnnotation</span> </a>
   </div>
  </nav>
 </div>
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#new-type-hierarchy-1">New Type Hierarchy</a></li><li><a href="#working-with-null-1">Working with Null</a></li><li><a href="#unsoundness-1">Unsoundness</a></li><li><a href="#equality-1">Equality</a></li><li><a href="#java-interoperability-and-flexible-types-1">Java Interoperability and Flexible Types</a><ul><li><a href="#override-check-1">Override check</a></li></ul></li><li><a href="#flow-typing-1">Flow Typing</a><ul><li><a href="#logical-operators-1">Logical Operators</a></li><li><a href="#inside-conditions-1">Inside Conditions</a></li><li><a href="#match-case-1">Match Case</a></li><li><a href="#mutable-variable-1">Mutable Variable</a></li><li><a href="#unsupported-idioms-1">Unsupported Idioms</a></li><li><a href="#unsafenulls-1">UnsafeNulls</a></li></ul></li><li><a href="#binary-compatibility-1">Binary Compatibility</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div></div></div></body></html>