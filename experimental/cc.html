<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Capture Checking</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><link rel="stylesheet" href="../css/bootstrap.min.css"></link><link rel="stylesheet" href="../css/dottydoc.css"></link><link rel="stylesheet" href="../css/color-brewer.css"></link><script type="text/javascript" src="../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../js/bootstrap.min.js" defer="true"></script><link rel="stylesheet" href="../css/content-contributors.css"></link><script type="text/javascript" src="../js/contributors.js" defer="true"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/scalastyle.css"></link><link rel="stylesheet" href="../styles/colors.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/diagram.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/ux.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.min.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><script>var pathToRoot = "../";</script><script>var githubContributorsUrl = "https://api.github.com/repos/lampepfl/dotty";</script><script>var githubContributorsFilename = "docs/_docs/reference/experimental/cc.md";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"><span><img src="../project-logo/logo.svg"></img></span><span><div class="projectName">Scala 3 Reference</div></span><div id="version"><div class="versions-dropdown"><div onclick="dropdownHandler()" id="dropdown-button" class="dropdownbtn dropdownbtnactive"><div class="projectVersion">3.1.2</div><div id="dropdown-content" class="dropdown-content"><input type="text" placeholder="Search..." id="dropdown-input" onkeyup="filterFunction()"></input></div></div></div></div><div class="socials"><a href="https://github.com/lampepfl/dotty"><span class="social-icon" data-icon-path="github-icon-white.png"></span></a><a href="https://discord.com/invite/scala"><span class="social-icon" data-icon-path="discord-icon-white.png"></span></a><a href="https://twitter.com/scala_lang"><span class="social-icon" data-icon-path="twitter-icon-white.png"></span></a></div></div><div id="paneSearch"></div><nav id="sideMenu2"><div class="ni expanded"><span class="nh expanded"><span class="ar"></span><a href="../index.html"><span>Scala 3 Reference</span></a></span><div class="ni"><span class="nh "><span class="ar"></span><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni "><span class="nh "><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/intersection-types-spec.html"><span>Intersection Types - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/union-types-spec.html"><span>Union Types - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/type-lambdas-spec.html"><span>Type Lambdas - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/dependent-function-types-spec.html"><span>Dependent Function Types - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni "><span class="nh "><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni "><span class="nh "><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni "><span class="nh "><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni "><span class="nh "><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/context-functions-spec.html"><span>Context Functions - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni "><span class="nh "><a href="../metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/macros-spec.html"><span>Macros Spec</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/staging.html"><span>Runtime Multi-Stage Programming</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni "><span class="nh "><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/parameter-untupling-spec.html"><span>Parameter Untupling - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni "><span class="nh "><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/structural-types-spec.html"><span>Programmatic Structural Types - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/type-checking.html"><span>Changes in Type Checking</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/implicit-conversions-spec.html"><span>Implicit Conversions - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/eta-expansion-spec.html"><span>Automatic Eta Expansion - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni "><span class="nh "><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/class-shadowing-spec.html"><span>Dropped: Class Shadowing - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/weak-conformance-spec.html"><span>Dropped: Weak Conformance - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni expanded"><span class="nh expanded"><span class="ar"></span><a href="index.html"><span>Experimental</span></a></span><div class="ni "><span class="nh "><a href="canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni "><span class="nh "><a href="erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni "><span class="nh "><a href="erased-defs-spec.html"><span>Erased Definitions - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni "><span class="nh "><a href="named-typeargs-spec.html"><span>Named Type Arguments - More Details</span></a></span></div><div class="ni "><span class="nh "><a href="numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni "><span class="nh "><a href="explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni "><span class="nh "><a href="main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni expanded"><span class="nh selected"><a href="cc.html"><span>Capture Checking</span></a></span></div></div><div class="ni "><span class="nh "><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni "><span class="nh "><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni "><span class="nh "><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni "><span class="nh "><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni "><span class="nh "><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></div></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="scaladoc-searchBar"></div><main id="main-content"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Experimental</a>/<a href="cc.html">Capture Checking</a></div><div id="content"><html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <div class="container"> 
    <div id="site-header"> 
     <div class="wrap"> 
      <nav class="navigation" role="menu"> 
       <ul class="navigation-menu"> 
        <li class="navigation-menu-item"> <a href="https://docs.scala-lang.org/" class="active">Learn</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/download/">Install</a> </li> 
        <li class="navigation-menu-item"> <a href="https://scastie.scala-lang.org">Playground</a> </li> 
        <li class="navigation-menu-item"> <a href="https://index.scala-lang.org">Find A Library</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/community/">Community</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/blog/">Blog</a> </li> 
       </ul> 
      </nav> 
     </div> 
    </div> 
    <main> 
     <header> 
      <h1>Capture Checking</h1> 
     </header> 
     <p>Capture checking is a research project that modifies the Scala type system to track references to capabilities in values. It is currently implemented in an experimental branch <a href="https://github.com/lampepfl/dotty/tree/cc-experiment">cc-experiment</a> in the dotty repo and can be enabled on this branch with a <code>-Ycc</code> compiler option.</p> 
     <p>To get an idea what capture checking can do, let's start with a small example:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def usingLogFile[T](op: FileOutputStream =&gt; T): T =
</span><span id="1" class=""><span class="tooltip-container"></span>  val logFile = FileOutputStream("log")
</span><span id="2" class=""><span class="tooltip-container"></span>  val result = op(logFile)
</span><span id="3" class=""><span class="tooltip-container"></span>  logFile.close()
</span><span id="4" class=""><span class="tooltip-container"></span>  result
</span></code></pre>
     </div> 
     <p>The <code>usingLogFile</code> method invokes a given operation with a fresh log file as parameter. Once the operation has ended, the log file is closed and the operation's result is returned. This is a typical <em>try-with-resources</em> pattern, similar to many other such patterns which are often supported by special language constructs in other languages.</p> 
     <p>The problem is that <code>usingLogFile</code>'s implementation is not entirely safe. One can undermine it by passing an operation that performs the logging at some later point after it has terminated. For instance:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>val later = usingLogFile { file =&gt; () =&gt; file.write(0) }
</span><span id="1" class=""><span class="tooltip-container"></span>later() // crash
</span></code></pre>
     </div> 
     <p>When <code>later</code> is executed it tries to write to a file that is already closed, which results in an uncaught <code>IOException</code>.</p> 
     <p>Capture checking gives us the mechanism to prevent such errors <em>statically</em>. To prevent unsafe usages of <code>usingLogFile</code>, we can declare it like this:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def usingLogFile[T](op: ({*} FileOutputStream) =&gt; T): T =
</span><span id="1" class=""><span class="tooltip-container"></span>  // same body as before
</span></code></pre>
     </div> 
     <p>The only thing that's changed is that the <code>FileOutputStream</code> parameter of <code>op</code> is now tagged with <code>{*}</code>. We'll see that this turns the parameter into a <em>capability</em> whose lifetime is tracked.</p> 
     <p>If we now try to define the problematic value <code>later</code>, we get a static error:</p> 
     <div class="snippet"> 
      <pre><code>   |  val later = usingLogFile { f =&gt; () =&gt; f.write(0) }
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |The expression's type {*} () -&gt; Unit is not allowed to capture the root capability `*`.
   |This usually means that a capability persists longer than its allowed lifetime.
</code></pre> 
     </div> 
     <p>In this case, it was easy to see that the <code>logFile</code> capability escapes in the closure passed to <code>usingLogFile</code>. But capture checking also works for more complex cases. For instance, capture checking is able to distinguish between the following safe code:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>val xs = usingLogFile { f =&gt;
</span><span id="1" class=""><span class="tooltip-container"></span>  List(1, 2, 3).map { x =&gt; f.write(x); x * x }
</span><span id="2" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     </div> 
     <p>and the following unsafe one:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>val xs = usingLogFile { f =&gt;
</span><span id="1" class=""><span class="tooltip-container"></span>  LazyList(1, 2, 3).map { x =&gt; f.write(x); x * x }
</span><span id="2" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     </div> 
     <p>An error would be issued in the second case, but not the first one (this assumes a capture-aware formulation of <code>LazyList</code> which we will present later in this page).</p> 
     <p>It turns out that capture checking has very broad applications. Besides the various try-with-resources patterns, it can also be a key part to the solutions of many other long standing problems in programming languages. Among them:</p> 
     <ul> 
      <li>How to have a simple and flexible system for checked exceptions. We show later how capture checking enables a clean and fully safe system for checked exceptions in Scala.</li> 
      <li>How to address the problem of effect polymorphism in general.</li> 
      <li>How to solve the "what color is your function?" problem of mixing synchronous and asynchronous computations.</li> 
      <li>How to do region-based allocation, safely,</li> 
      <li>How to reason about capabilities associated with memory locations.</li> 
     </ul> 
     <p>The following sections explain in detail how capture checking works in Scala 3.</p> 
     <section id="overview"> 
      <h2><a href="#overview" class="anchor"></a>Overview</h2> 
      <p>The capture checker extension introduces a new kind of types and it enforces some rules for working with these types.</p> 
      <p>Capture checking is enabled by the compiler option <code>-Ycc</code>. If the option is not given, the new type forms can still be written but they are not checked for consistency, because they are treated simply as certain uninterpreted annotated types.</p> 
     </section>
     <section id="capabilities-and-capturing-types"> 
      <h2><a href="#capabilities-and-capturing-types" class="anchor"></a>Capabilities and Capturing Types</h2> 
      <p>Capture checking is done in terms of <em>capturing types</em> of the form <code>{c₁, ..., cᵢ} T</code>. Here <code>T</code> is a type, and <code>{c₁, ..., cᵢ}</code> is a <em>capture set</em> consisting of references to capabilities <code>c₁, ..., cᵢ</code>.</p> 
      <p>A <em>capability</em> is syntactically a method- or class-parameter, a local variable, or the <code>this</code> of an enclosing class. The type of a capability must be a capturing type with a non-empty capture set. We also say that variables that are capabilities are <em>tracked</em>.</p> 
      <p>In a sense, every capability gets its authority from some other, more sweeping capability which it captures. The most sweeping capability, from which ultimately all others are derived is written <code>*</code>. We call it the <em>universal capability</em>.</p> 
      <p>Here is an example:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>class FileSystem
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>class Logger(fs: {*} FileSystem):
</span><span id="3" class=""><span class="tooltip-container"></span>  def log(s: String): Unit = ... // Write to a log file, using `fs`
</span><span id="4" class=""><span class="tooltip-container"></span>
</span><span id="5" class=""><span class="tooltip-container"></span>def test(fs: {*} FileSystem) =
</span><span id="6" class=""><span class="tooltip-container"></span>  val l: {fs} Logger = Logger(fs)
</span><span id="7" class=""><span class="tooltip-container"></span>  l.log("hello world!")
</span><span id="8" class=""><span class="tooltip-container"></span>  val xs: {l} LazyList[Int] =
</span><span id="9" class=""><span class="tooltip-container"></span>    LazyList.from(1)
</span><span id="10" class=""><span class="tooltip-container"></span>      .map { i =&gt;
</span><span id="11" class=""><span class="tooltip-container"></span>        l.log(s"computing elem # $i")
</span><span id="12" class=""><span class="tooltip-container"></span>        i * i
</span><span id="13" class=""><span class="tooltip-container"></span>      }
</span><span id="14" class=""><span class="tooltip-container"></span>  xs
</span></code></pre>
      </div> 
      <p>Here, the <code>test</code> method takes a <code>FileSystem</code> as a parameter. <code>fs</code> is a capability since its type has a non-empty capture set. The capability is passed to the <code>Logger</code> constructor and retained as a field in class <code>Logger</code>. Hence, the local variable <code>l</code> has type <code>{fs} Logger</code>: it is a <code>Logger</code> which retains the <code>fs</code> capability.</p> 
      <p>The second variable defined in <code>test</code> is <code>xs</code>, a lazy list that is obtained from <code>LazyList.from(1)</code> by logging and mapping consecutive numbers. Since the list is lazy, it needs to retain the reference to the logger <code>l</code> for its computations. Hence, the type of the list is <code>{l} LazyList[Int]</code>. On the other hand, since <code>xs</code> only logs but does not do other file operations, it retains the <code>fs</code> capability only indirectly. That's why <code>fs</code> does not show up in the capture set of <code>xs</code>.</p> 
      <p>Capturing types come with a subtype relation where types with "smaller" capture sets are subtypes of types with larger sets (the <em>subcapturing</em> relation is defined in more detail below). If a type <code>T</code> does not have a capture set, it is called <em>pure</em>, and is a subtype of any capturing type that adds a capture set to <code>T</code>.</p> 
     </section>
     <section id="function-types"> 
      <h2><a href="#function-types" class="anchor"></a>Function Types</h2> 
      <p>The usual function type <code>A =&gt; B</code> now stands for a function that can capture arbitrary capabilities. We call such functions <em>impure</em>. By contrast, the new single arrow function type <code>A -&gt; B</code> stands for a function that cannot capture any capabilities, or otherwise said, is <em>pure</em>. One can add a capture set in front of an otherwise pure function. For instance, <code>{c, d} A -&gt; B</code> would be a function that can capture capabilities <code>c</code> and <code>d</code>, but no others.</p> 
      <p>The impure function type <code>A =&gt; B</code> is treated as an alias for <code>{*} A -&gt; B</code>. That is, impure functions are functions that can capture anything.</p> 
      <p>Function types and captures both associate to the right, so</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>{c} A -&gt; {d} B -&gt; C
</span></code></pre>
      </div> 
      <p>is the same as</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>{c} (A -&gt; {d} (B -&gt; C))
</span></code></pre>
      </div> 
      <p>Contrast with</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>({c} A) -&gt; ({d} B) -&gt; C
</span></code></pre>
      </div> 
      <p>which is a curried pure function over argument types that can capture <code>c</code> and <code>d</code>, respectively.</p> 
      <p>Analogous conventions apply to context function types. <code>A ?=&gt; B</code> is an impure context function, with <code>A ?-&gt; B</code> as its pure complement.</p> 
      <p><strong>Note 1:</strong> The identifiers <code>-&gt;</code> and <code>?-&gt;</code> are now treated as soft keywords when used as infix type operators. They are still available as regular identifiers for terms. For instance, the mapping syntax <code>Map("x" -&gt; 1, "y" -&gt; 2)</code> is still supported since it only applies to terms.</p> 
      <p><strong>Note 2:</strong> The distinctions between pure vs impure function types do not apply to methods. In fact, since methods are not values they never capture anything directly. References to capabilities in a method are instead counted in the capture set of the enclosing object.</p> 
     </section>
     <section id="by-name-parameter-types"> 
      <h2><a href="#by-name-parameter-types" class="anchor"></a>By-Name Parameter Types</h2> 
      <p>A convention analogous to function types also extends to by-name parameters. In</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def f(x: =&gt; Int): Int
</span></code></pre>
      </div> 
      <p>the actual argument can refer to arbitrary capabilities. So the following would be OK:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>f(if p(y) then throw Ex() else 1)
</span></code></pre>
      </div> 
      <p>On the other hand, if <code>f</code> was defined like this</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def f(x: -&gt; Int): Int
</span></code></pre>
      </div> 
      <p>the actual argument to <code>f</code> could not refer to any capabilities, so the call above would be rejected. One can also allow specific capabilities like this:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def f(x: {c}-&gt; Int): Int
</span></code></pre>
      </div> 
      <p>Here, the actual argument to <code>f</code> is allowed to use the <code>c</code> capability but no others.</p> 
      <p><strong>Note</strong>: It is strongly recommended to write the capability set and the arrow <code>-&gt;</code> without intervening spaces, as otherwise the notation would look confusingly like a function type.</p> 
     </section>
     <section id="subtyping-and-subcapturing"> 
      <h2><a href="#subtyping-and-subcapturing" class="anchor"></a>Subtyping and Subcapturing</h2> 
      <p>Capturing influences subtyping. As usual we write <code>T₁ &lt;: T₂</code> to express that the type <code>T₁</code> is a subtype of the type <code>T₂</code>, or equivalently, that <code>T₁</code> conforms to <code>T₂</code>. An analogous <em>subcapturing</em> relation applies to capture sets. If <code>C₁</code> and <code>C₂</code> are capture sets, we write <code>C₁ &lt;: C₂</code> to express that <code>C₁</code> <em>is covered by</em> <code>C₂</code>, or, swapping the operands, that <code>C₂</code> <em>covers</em> <code>C₁</code>.</p> 
      <p>Subtyping extends as follows to capturing types:</p> 
      <ul> 
       <li>Pure types are subtypes of capturing types. That is, <code>T &lt;: C T</code>, for any type <code>T</code>, capturing set <code>C</code>.</li> 
       <li>For capturing types, smaller capturing sets produce subtypes: <code>C₁ T₁ &lt;: C₂ T₂</code> if <code>C₁ &lt;: C₂</code> and <code>T₁ &lt;: T₂</code>.</li> 
      </ul> 
      <p>A subcapturing relation <code>C₁ &lt;: C₂</code> holds if <code>C₂</code> <em>accounts for</em> every element <code>c</code> in <code>C₁</code>. This means one of the following three conditions must be true:</p> 
      <ul> 
       <li><code>c ∈ C₂</code>,</li> 
       <li><code>c</code> refers to a parameter of some class <code>Cls</code> and <code>C₂</code> contains <code>Cls.this</code>,</li> 
       <li><code>c</code>'s type has capturing set <code>C</code> and <code>C₂</code> accounts for every element of <code>C</code> (that is, <code>C &lt;: C₂</code>).</li> 
      </ul> 
      <p><strong>Example 1.</strong> Given</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>fs: {*} FileSystem
</span><span id="1" class=""><span class="tooltip-container"></span>ct: {*} CanThrow[Exception]
</span><span id="2" class=""><span class="tooltip-container"></span>l : {fs} Logger
</span></code></pre>
      </div> 
      <p>we have</p> 
      <div class="snippet"> 
       <pre><code>{l}  &lt;: {fs}     &lt;: {*}
{fs} &lt;: {fs, ct} &lt;: {*}
{ct} &lt;: {fs, ct} &lt;: {*}
</code></pre> 
      </div> 
      <p>The set consisting of the root capability <code>{*}</code> covers every other capture set. This is a consequence of the fact that, ultimately, every capability is created from <code>*</code>.</p> 
      <p><strong>Example 2.</strong> Consider again the FileSystem/Logger example from before. <code>LazyList[Int]</code> is a proper subtype of <code>{l} LazyList[Int]</code>. So if the <code>test</code> method in that example was declared with a result type <code>LazyList[Int]</code>, we'd get a type error. Here is the error message:</p> 
      <div class="snippet"> 
       <pre><code>11 |def test(using fs: {*} FileSystem): LazyList[Int] = {
   |                                                    ^
   |                                            Found:    {fs} LazyList[Int]
   |                                            Required: LazyList[Int]
</code></pre> 
      </div> 
      <p>Why does it say <code>{fs} LazyList[Int]</code> and not <code>{l} LazyList[Int]</code>, which is, after all, the type of the returned value <code>xs</code>? The reason is that <code>l</code> is a local variable in the body of <code>test</code>, so it cannot be referred to in a type outside that body. What happens instead is that the type is <em>widened</em> to the smallest supertype that does not mention <code>l</code>. Since <code>l</code> has capture set <code>fs</code>, we have that <code>{fs}</code> covers <code>{l}</code>, and <code>{fs}</code> is acceptable in a result type of <code>test</code>, so <code>{fs}</code> is the result of that widening. This widening is called <em>avoidance</em>; it is not specific to capture checking but applies to all variable references in Scala types.</p> 
     </section>
     <section id="capability-classes"> 
      <h2><a href="#capability-classes" class="anchor"></a>Capability Classes</h2> 
      <p>Classes like <code>CanThrow</code> or <code>FileSystem</code> have the property that their values are always intended to be capabilities. We can make this intention explicit and save boilerplate by declaring these classes with a <code>@capability</code> annotation.</p> 
      <p>The capture set of a capability class type is always <code>{*}</code>. This means we could equivalently express the <code>FileSystem</code> and <code>Logger</code> classes as follows:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>import annotation.capability
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>@capability class FileSystem
</span><span id="3" class=""><span class="tooltip-container"></span>
</span><span id="4" class=""><span class="tooltip-container"></span>class Logger(using FileSystem):
</span><span id="5" class=""><span class="tooltip-container"></span>  def log(s: String): Unit = ???
</span><span id="6" class=""><span class="tooltip-container"></span>
</span><span id="7" class=""><span class="tooltip-container"></span>def test(using fs: FileSystem) =
</span><span id="8" class=""><span class="tooltip-container"></span>  val l: {fs} Logger = Logger()
</span><span id="9" class=""><span class="tooltip-container"></span>  ...
</span></code></pre>
      </div> 
      <p>In this version, <code>FileSystem</code> is a capability class, which means that the <code>{*}</code> capture set is implied on the parameters of <code>Logger</code> and <code>test</code>. Writing the capture set explicitly produces a warning:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>class Logger(using {*} FileSystem):
</span><span id="1" class=""><span class="tooltip-container"></span>                   ^^^^^^^^^^^^^^
</span><span id="2" class=""><span class="tooltip-container"></span>             redundant capture: FileSystem already accounts for *
</span></code></pre>
      </div> 
      <p>Another, unrelated change in the version of the last example here is that the <code>FileSystem</code> capability is now passed as an implicit parameter. It is quite natural to model capabilities with implicit parameters since it greatly reduces the wiring overhead once multiple capabilities are in play.</p> 
     </section>
     <section id="capture-checking-of-closures"> 
      <h2><a href="#capture-checking-of-closures" class="anchor"></a>Capture Checking of Closures</h2> 
      <p>If a closure refers to capabilities in its body, it captures these capabilities in its type. For instance, consider:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def test(fs: FileSystem): {fs} String -&gt; Unit =
</span><span id="1" class=""><span class="tooltip-container"></span>  (x: String) =&gt; Logger(fs).log(x)
</span></code></pre>
      </div> 
      <p>Here, the body of <code>test</code> is a lambda that refers to the capability <code>fs</code>, which means that <code>fs</code> is retained in the lambda. Consequently, the type of the lambda is <code>{fs} String -&gt; Unit</code>.</p> 
      <p><strong>Note:</strong> Function values are always written with <code>=&gt;</code> (or <code>?=&gt;</code> for context functions). There is no syntactic distinction for pure <em>vs</em> impure function values. The distinction is only made in their types.</p> 
      <p>A closure also captures all capabilities that are captured by the functions it calls. For instance, in</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def test(fs: FileSystem) =
</span><span id="1" class=""><span class="tooltip-container"></span>  def f() = g()
</span><span id="2" class=""><span class="tooltip-container"></span>  def g() = (x: String) =&gt; Logger(fs).log(x)
</span><span id="3" class=""><span class="tooltip-container"></span>  f
</span></code></pre>
      </div> 
      <p>the result of <code>test</code> has type <code>{fs} String -&gt; Unit</code> even though function <code>f</code> itself does not refer to <code>fs</code>.</p> 
     </section>
     <section id="capture-checking-of-classes"> 
      <h2><a href="#capture-checking-of-classes" class="anchor"></a>Capture Checking of Classes</h2> 
      <p>The principles for capture checking closures also apply to classes. For instance, consider:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>class Logger(using fs: FileSystem):
</span><span id="1" class=""><span class="tooltip-container"></span>  def log(s: String): Unit = ... summon[FileSystem] ...
</span><span id="2" class=""><span class="tooltip-container"></span>
</span><span id="3" class=""><span class="tooltip-container"></span>def test(xfs: FileSystem): {xfs} Logger =
</span><span id="4" class=""><span class="tooltip-container"></span>  Logger(xfs)
</span></code></pre>
      </div> 
      <p>Here, class <code>Logger</code> retains the capability <code>fs</code> as a (private) field. Hence, the result of <code>test</code> is of type <code>{xfs} Logger</code></p> 
      <p>Sometimes, a tracked capability is meant to be used only in the constructor of a class, but is not intended to be retained as a field. This fact can be communicated to the capture checker by declaring the parameter as <code>@constructorOnly</code>. Example:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>import annotation.constructorOnly
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>class NullLogger(using @constructorOnly fs: FileSystem):
</span><span id="3" class=""><span class="tooltip-container"></span>  ...
</span><span id="4" class=""><span class="tooltip-container"></span>def test2(using fs: FileSystem): NullLogger = NullLogger() // OK
</span></code></pre>
      </div> 
      <p>The captured references of a class include <em>local capabilities</em> and <em>argument capabilities</em>. Local capabilities are capabilities defined outside the class and referenced from its body. Argument capabilities are passed as parameters to the primary constructor of the class. Local capabilities are inherited: the local capabilities of a superclass are also local capabilities of its subclasses. Example:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>@capability class Cap
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>def test(a: Cap, b: Cap, c: Cap) =
</span><span id="3" class=""><span class="tooltip-container"></span>  class Super(y: Cap):
</span><span id="4" class=""><span class="tooltip-container"></span>    def f = a
</span><span id="5" class=""><span class="tooltip-container"></span>  class Sub(x: Cap) extends Super(x)
</span><span id="6" class=""><span class="tooltip-container"></span>    def g = b
</span><span id="7" class=""><span class="tooltip-container"></span>  Sub(c)
</span></code></pre>
      </div> 
      <p>Here class <code>Super</code> has local capability <code>a</code>, which gets inherited by class <code>Sub</code> and is combined with <code>Sub</code>'s own local capability <code>b</code>. Class <code>Sub</code> also has an argument capability corresponding to its parameter <code>x</code>. This capability gets instantiated to <code>c</code> in the final constructor call <code>Sub(c)</code>. Hence, the capture set of that call is <code>{a, b, c}</code>.</p> 
      <p>The capture set of the type of <code>this</code> of a class is inferred by the capture checker, unless the type is explicitly declared with a self type annotation like this one:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>class C:
</span><span id="1" class=""><span class="tooltip-container"></span>  self: {a, b} D =&gt; ...
</span></code></pre>
      </div> 
      <p>The inference observes the following constraints:</p> 
      <ul> 
       <li>The type of <code>this</code> of a class <code>C</code> includes all captured references of <code>C</code>.</li> 
       <li>The type of <code>this</code> of a class <code>C</code> is a subtype of the type of <code>this</code> of each parent class of <code>C</code>.</li> 
       <li>The type of <code>this</code> must observe all constraints where <code>this</code> is used.</li> 
      </ul> 
      <p>For instance, in</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>@capability class Cap
</span><span id="1" class=""><span class="tooltip-container"></span>def test(c: Cap) =
</span><span id="2" class=""><span class="tooltip-container"></span>  class A:
</span><span id="3" class=""><span class="tooltip-container"></span>    val x: A = this
</span><span id="4" class=""><span class="tooltip-container"></span>    def f = println(c)  // error
</span></code></pre>
      </div> 
      <p>we know that the type of <code>this</code> must be pure, since <code>this</code> is the right hand side of a <code>val</code> with type <code>A</code>. However, in the last line we find that the capture set of the class, and with it the capture set of <code>this</code>, would include <code>c</code>. This leads to a contradiction, and hence to a checking error:</p> 
      <div class="snippet"> 
       <pre><code>16 |    def f = println(c)  // error
   |                    ^
   |(c : Cap) cannot be referenced here; it is not included in the allowed capture set {}
</code></pre> 
      </div>
     </section>
     <section id="capture-tunnelling"> 
      <h2><a href="#capture-tunnelling" class="anchor"></a>Capture Tunnelling</h2> 
      <p>Consider the following simple definition of a <code>Pair</code> class:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>class Pair[+A, +B](x: A, y: B):
</span><span id="1" class=""><span class="tooltip-container"></span>  def fst: A = x
</span><span id="2" class=""><span class="tooltip-container"></span>  def snd: B = y
</span></code></pre>
      </div> 
      <p>What happens if <code>Pair</code> is instantiated like this (assuming <code>ct</code> and <code>fs</code> are two capabilities in scope)?</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def x: {ct} Int -&gt; String
</span><span id="1" class=""><span class="tooltip-container"></span>def y: {fs} Logger
</span><span id="2" class=""><span class="tooltip-container"></span>def p = Pair(x, y)
</span></code></pre>
      </div> 
      <p>The last line will be typed as follows:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def p: Pair[{ct} Int -&gt; String, {fs} Logger] = Pair(x, y)
</span></code></pre>
      </div> 
      <p>This might seem surprising. The <code>Pair(x, y)</code> value does capture capabilities <code>ct</code> and <code>fs</code>. Why don't they show up in its type at the outside?</p> 
      <p>The answer is capture tunnelling. Once a type variable is instantiated to a capturing type, the capture is not propagated beyond this point. On the other hand, if the type variable is instantiated again on access, the capture information "pops out" again. For instance, even though <code>p</code> is technically pure because its capture set is empty, writing <code>p.fst</code> would record a reference to the captured capability <code>ct</code>. So if this access was put in a closure, the capability would again form part of the outer capture set. E.g.</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>() =&gt; p.fst : {ct} () -&gt; {ct} Int -&gt; String
</span></code></pre>
      </div> 
      <p>In other words, references to capabilities "tunnel through" in generic instantiations from creation to access; they do not affect the capture set of the enclosing generic data constructor applications. This principle may seem surprising at first, but it is the key to make capture checking concise and practical.</p> 
     </section>
     <section id="escape-checking"> 
      <h2><a href="#escape-checking" class="anchor"></a>Escape Checking</h2> 
      <p>The universal capability <code>*</code> should be conceptually available only as a parameter to the main program. Indeed, if it was available everywhere, capability checking would be undermined since one could mint new capabilities at will. In line with this reasoning, some capture sets are restricted so that they are not allowed to contain the universal capability.</p> 
      <p>Specifically, if a capturing type is an instance of a type variable, that capturing type is not allowed to carry the universal capability <code>{*}</code>. There's a connection to tunnelling here. The capture set of a type has to be present in the environment when a type is instantiated from a type variable. But <code>*</code> is not itself available as a global entity in the environment. Hence, an error should result.</p> 
      <p>We can now reconstruct how this principle produced the error in the introductory example, where <code>usingLogFile</code> was declared like this:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def usingLogFile[T](op: ({*} FileOutputStream) =&gt; T): T = ...
</span></code></pre>
      </div> 
      <p>The error message was:</p> 
      <div class="snippet"> 
       <pre><code>   |  val later = usingLogFile { f =&gt; () =&gt; f.write(0) }
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |The expression's type {*} () -&gt; Unit is not allowed to capture the root capability `*`.
   |This usually means that a capability persists longer than its allowed lifetime.
</code></pre> 
      </div> 
      <p>This error message was produced by the following logic:</p> 
      <ul> 
       <li>The <code>f</code> parameter has type <code>{*} FileOutputStream</code>, which makes it a capability.</li> 
       <li>Therefore, the type of the expression <code>() =&gt; f.write(0)</code> is <code>{f} () -&gt; Unit</code>.</li> 
       <li>This makes the whole type of the closure passed to <code>usingLogFile</code> the dependent function type <code>(f: {*} FileOutputStream) -&gt; {f} () -&gt; Unit</code>.</li> 
       <li>The expected type of the closure is a simple, parametric, impure function type <code>({*} FileOutputStream) =&gt; T</code>, for some instantiation of the type variable <code>T</code>.</li> 
       <li>The smallest supertype of the closure's dependent function type that is a parametric function type is <code>({*} FileOutputStream) =&gt; {*} () -&gt; Unit</code></li> 
       <li>Hence, the type variable <code>T</code> is instantiated to <code>* () -&gt; Unit</code>, which causes the error.</li> 
      </ul> 
      <p>An analogous restriction applies to the type of a mutable variable. Another way one could try to undermine capture checking would be to assign a closure with a local capability to a global variable. Maybe like this:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>var loophole: {*} () -&gt; Unit = () =&gt; ()
</span><span id="1" class=""><span class="tooltip-container"></span>usingLogFile { f =&gt;
</span><span id="2" class=""><span class="tooltip-container"></span>  loophole = () =&gt; f.write(0)
</span><span id="3" class=""><span class="tooltip-container"></span>}
</span><span id="4" class=""><span class="tooltip-container"></span>loophole()
</span></code></pre>
      </div> 
      <p>But this will not compile either, since mutable variables cannot have universal capture sets.</p> 
      <p>One also needs to prevent returning or assigning a closure with a local capability in an argument of a parametric type. For instance, here is a slightly more refined attack:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>class Cell[+A](x: A)
</span><span id="1" class=""><span class="tooltip-container"></span>val sneaky = usingLogFile { f =&gt; Cell(() =&gt; f.write(0)) }
</span><span id="2" class=""><span class="tooltip-container"></span>sneaky.x()
</span></code></pre>
      </div> 
      <p>At the point where the <code>Cell</code> is created, the capture set of the argument is <code>f</code>, which is OK. But at the point of use, it is <code>*</code> (because <code>f</code> is no longer in scope), which causes again an error:</p> 
      <div class="snippet"> 
       <pre><code>   |  sneaky.x()
   |  ^^^^^^^^
   |The expression's type {*} () -&gt; Unit is not allowed to capture the root capability `*`.
   |This usually means that a capability persists longer than its allowed lifetime.
</code></pre> 
      </div> 
      <p>Looking at object graphs, we observe a monotonicity property: The capture set of an object <code>x</code> covers the capture sets of all objects reachable through <code>x</code>. This property is reflected in the type system by the following <em>monotonicity rule</em>:</p> 
      <ul> 
       <li>In a class <code>C</code> with a field <code>f</code>, the capture set <code>{this}</code> covers the capture set <code>{this.f}</code> as well as the capture set of any application of <code>this.f</code> to pure arguments.</li> 
      </ul> 
     </section>
     <section id="checked-exceptions"> 
      <h2><a href="#checked-exceptions" class="anchor"></a>Checked Exceptions</h2> 
      <p>Scala enables checked exceptions through a language import. Here is an example, taken from the <a href="canthrow.html">safer exceptions page</a>, and also described in a <a href="https://infoscience.epfl.ch/record/290885">paper</a> presented at the 2021 Scala Symposium.</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>import language.experimental.saferExceptions
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>class LimitExceeded extends Exception
</span><span id="3" class=""><span class="tooltip-container"></span>
</span><span id="4" class=""><span class="tooltip-container"></span>val limit = 10e+10
</span><span id="5" class=""><span class="tooltip-container"></span>def f(x: Double): Double throws LimitExceeded =
</span><span id="6" class=""><span class="tooltip-container"></span>  if x &lt; limit then x * x else throw LimitExceeded()
</span></code></pre>
      </div> 
      <p>The new <code>throws</code> clause expands into an implicit parameter that provides a <code>CanThrow</code> capability. Hence, function <code>f</code> could equivalently be written like this:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def f(x: Double)(using CanThrow[LimitExceeded]): Double = ...
</span></code></pre>
      </div> 
      <p>If the implicit parameter is missing, an error is reported. For instance, the function definition</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def g(x: Double): Double =
</span><span id="1" class=""><span class="tooltip-container"></span>  if x &lt; limit then x * x else throw LimitExceeded()
</span></code></pre>
      </div> 
      <p>is rejected with this error message:</p> 
      <div class="snippet"> 
       <pre><code>  |  if x &lt; limit then x * x else throw LimitExceeded()
  |                               ^^^^^^^^^^^^^^^^^^^^^
  |The capability to throw exception LimitExceeded is missing.
  |The capability can be provided by one of the following:
  | - Adding a using clause `(using CanThrow[LimitExceeded])` to the definition of the enclosing method
  | - Adding `throws LimitExceeded` clause after the result type of the enclosing method
  | - Wrapping this piece of code with a `try` block that catches LimitExceeded
</code></pre> 
      </div> 
      <p><code>CanThrow</code> capabilities are required by <code>throw</code> expressions and are created by <code>try</code> expressions. For instance, the expression</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>try xs.map(f).sum
</span><span id="1" class=""><span class="tooltip-container"></span>catch case ex: LimitExceeded =&gt; -1
</span></code></pre>
      </div> 
      <p>would be expanded by the compiler to something like the following:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>try
</span><span id="1" class=""><span class="tooltip-container"></span>  erased given ctl: CanThrow[LimitExceeded] = compiletime.erasedValue
</span><span id="2" class=""><span class="tooltip-container"></span>  xs.map(f).sum
</span><span id="3" class=""><span class="tooltip-container"></span>catch case ex: LimitExceeded =&gt; -1
</span></code></pre>
      </div> 
      <p>(The <code>ctl</code> capability is only used for type checking but need not show up in the generated code, so it can be declared as erased.)</p> 
      <p>As with other capability based schemes, one needs to guard against capabilities that are captured in results. For instance, here is a problematic use case:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def escaped(xs: Double*): (() =&gt; Double) throws LimitExceeded =
</span><span id="1" class=""><span class="tooltip-container"></span>  try () =&gt; xs.map(f).sum
</span><span id="2" class=""><span class="tooltip-container"></span>  catch case ex: LimitExceeded =&gt; () =&gt; -1
</span><span id="3" class=""><span class="tooltip-container"></span>val crasher = escaped(1, 2, 10e+11)
</span><span id="4" class=""><span class="tooltip-container"></span>crasher()
</span></code></pre>
      </div> 
      <p>This code needs to be rejected since otherwise the call to <code>crasher()</code> would cause an unhandled <code>LimitExceeded</code> exception to be thrown.</p> 
      <p>Under <code>-Ycc</code>, the code is indeed rejected</p> 
      <div class="snippet"> 
       <pre><code>14 |  try () =&gt; xs.map(f).sum
   |  ^
   |The expression's type {*} () -&gt; Double is not allowed to capture the root capability `*`.
   |This usually means that a capability persists longer than its allowed lifetime.
15 |  catch case ex: LimitExceeded =&gt; () =&gt; -1
</code></pre> 
      </div> 
      <p>To integrate exception and capture checking, only two changes are needed:</p> 
      <ul> 
       <li><code>CanThrow</code> is declared as a <code>@capability</code> class, so all references to <code>CanThrow</code> instances are tracked.</li> 
       <li>Escape checking is extended to <code>try</code> expressions. The result type of a <code>try</code> is not allowed to capture the universal capability.</li> 
      </ul> 
     </section>
     <section id="a-larger-example"> 
      <h2><a href="#a-larger-example" class="anchor"></a>A Larger Example</h2> 
      <p>As a larger example, we present an implementation of lazy lists and some use cases. For simplicity, our lists are lazy only in their tail part. This corresponds to what the Scala-2 type <code>Stream</code> did, whereas Scala 3's <code>LazyList</code> type computes strictly less since it is also lazy in the first argument.</p> 
      <p>Here is the base trait <code>LzyList</code> for our version of lazy lists:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>trait LzyList[+A]:
</span><span id="1" class=""><span class="tooltip-container"></span>  def isEmpty: Boolean
</span><span id="2" class=""><span class="tooltip-container"></span>  def head: A
</span><span id="3" class=""><span class="tooltip-container"></span>  def tail: {this} LzyList[A]
</span></code></pre>
      </div> 
      <p>Note that <code>tail</code> carries a capture annotation. It says that the tail of a lazy list can potentially capture the same references as the lazy list as a whole.</p> 
      <p>The empty case of a <code>LzyList</code> is written as usual:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>object LzyNil extends LzyList[Nothing]:
</span><span id="1" class=""><span class="tooltip-container"></span>  def isEmpty = true
</span><span id="2" class=""><span class="tooltip-container"></span>  def head = ???
</span><span id="3" class=""><span class="tooltip-container"></span>  def tail = ???
</span></code></pre>
      </div> 
      <p>Here is a formulation of the class for lazy cons nodes:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>import scala.compiletime.uninitialized
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>final class LzyCons[+A](hd: A, tl: () =&gt; {*} LzyList[A]) extends LzyList[A]:
</span><span id="3" class=""><span class="tooltip-container"></span>  private var forced = false
</span><span id="4" class=""><span class="tooltip-container"></span>  private var cache: {this} LzyList[A] = uninitialized
</span><span id="5" class=""><span class="tooltip-container"></span>  private def force =
</span><span id="6" class=""><span class="tooltip-container"></span>    if !forced then { cache = tl(); forced = true }
</span><span id="7" class=""><span class="tooltip-container"></span>    cache
</span><span id="8" class=""><span class="tooltip-container"></span>
</span><span id="9" class=""><span class="tooltip-container"></span>  def isEmpty = false
</span><span id="10" class=""><span class="tooltip-container"></span>  def head = hd
</span><span id="11" class=""><span class="tooltip-container"></span>  def tail: {this} LzyList[A] = force
</span><span id="12" class=""><span class="tooltip-container"></span>end LzyCons
</span></code></pre>
      </div> 
      <p>The <code>LzyCons</code> class takes two parameters: A head <code>hd</code> and a tail <code>tl</code>, which is a function returning a <code>LzyList</code>. Both the function and its result can capture arbitrary capabilities. The result of applying the function is memoized after the first dereference of <code>tail</code> in the private mutable field <code>cache</code>. Note that the typing of the assignment <code>cache = tl()</code> relies on the monotonicity rule for <code>{this}</code> capture sets.</p> 
      <p>Here is an extension method to define an infix cons operator <code>#:</code> for lazy lists. It is analogous to <code>::</code> but instead of a strict list it produces a lazy list without evaluating its right operand.</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>extension [A](x: A)
</span><span id="1" class=""><span class="tooltip-container"></span>  def #:(xs1: =&gt; {*} LzyList[A]): {xs1} LzyList[A] =
</span><span id="2" class=""><span class="tooltip-container"></span>    LzyCons(x, () =&gt; xs1)
</span></code></pre>
      </div> 
      <p>Note that <code>#:</code> takes an impure call-by-name parameter <code>xs1</code> as its right argument. The result of <code>#:</code> is a lazy list that captures that argument.</p> 
      <p>As an example usage of <code>#:</code>, here is a method <code>tabulate</code> that creates a lazy list of given length with a generator function <code>gen</code>. The generator function is allowed to have side effects.</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def tabulate[A](n: Int)(gen: Int =&gt; A) =
</span><span id="1" class=""><span class="tooltip-container"></span>  def recur(i: Int): {gen} LzyList[A] =
</span><span id="2" class=""><span class="tooltip-container"></span>    if i == n then LzyNil
</span><span id="3" class=""><span class="tooltip-container"></span>    else gen(i) #: recur(i + 1)
</span><span id="4" class=""><span class="tooltip-container"></span>  recur(0)
</span></code></pre>
      </div> 
      <p>Here is a use of <code>tabulate</code>:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>class LimitExceeded extends Exception
</span><span id="1" class=""><span class="tooltip-container"></span>def squares(n: Int)(using ct: CanThrow[LimitExceeded]) =
</span><span id="2" class=""><span class="tooltip-container"></span>  tabulate(10) { i =&gt;
</span><span id="3" class=""><span class="tooltip-container"></span>    if i &gt; 9 then throw LimitExceeded()
</span><span id="4" class=""><span class="tooltip-container"></span>    i * i
</span><span id="5" class=""><span class="tooltip-container"></span>  }
</span></code></pre>
      </div> 
      <p>The inferred result type of <code>squares</code> is <code>{ct} LzyList[Int]</code>, i.e it is a lazy list of <code>Int</code>s that can throw the <code>LimitExceeded</code> exception when it is elaborated by calling <code>tail</code> one or more times.</p> 
      <p>Here are some further extension methods for mapping, filtering, and concatenating lazy lists:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>extension [A](xs: {*} LzyList[A])
</span><span id="1" class=""><span class="tooltip-container"></span>  def map[B](f: A =&gt; B): {xs, f} LzyList[B] =
</span><span id="2" class=""><span class="tooltip-container"></span>    if xs.isEmpty then LzyNil
</span><span id="3" class=""><span class="tooltip-container"></span>    else f(xs.head) #: xs.tail.map(f)
</span><span id="4" class=""><span class="tooltip-container"></span>
</span><span id="5" class=""><span class="tooltip-container"></span>  def filter(p: A =&gt; Boolean): {xs, p} LzyList[A] =
</span><span id="6" class=""><span class="tooltip-container"></span>    if xs.isEmpty then LzyNil
</span><span id="7" class=""><span class="tooltip-container"></span>    else if p(xs.head) then xs.head #: xs.tail.filter(p)
</span><span id="8" class=""><span class="tooltip-container"></span>    else xs.tail.filter(p)
</span><span id="9" class=""><span class="tooltip-container"></span>
</span><span id="10" class=""><span class="tooltip-container"></span>  def concat(ys: {*} LzyList[A]): {xs, ys} LzyList[A] =
</span><span id="11" class=""><span class="tooltip-container"></span>    if xs.isEmpty then ys
</span><span id="12" class=""><span class="tooltip-container"></span>    else xs.head #: xs.tail.concat(ys)
</span><span id="13" class=""><span class="tooltip-container"></span>
</span><span id="14" class=""><span class="tooltip-container"></span>  def drop(n: Int): {xs} LzyList[A] =
</span><span id="15" class=""><span class="tooltip-container"></span>    if n == 0 then xs else xs.tail.drop(n - 1)
</span></code></pre>
      </div> 
      <p>Their capture annotations are all as one would expect:</p> 
      <ul> 
       <li>Mapping a lazy list produces a lazy list that captures the original list as well as the (possibly impure) mapping function.</li> 
       <li>Filtering a lazy list produces a lazy list that captures the original list as well as the (possibly impure) filtering predicate.</li> 
       <li>Concatenating two lazy lists produces a lazy list that captures both arguments.</li> 
       <li>Dropping elements from a lazy list gives a safe approximation where the original list is captured in the result. In fact, it's only some suffix of the list that is retained at run time, but our modelling identifies lazy lists and their suffixes, so this additional knowledge would not be useful.</li> 
      </ul> 
      <p>Of course the function passed to <code>map</code> or <code>filter</code> could also be pure. After all, <code>A -&gt; B</code> is a subtype of <code>{*} A -&gt; B</code> which is the same as <code>A =&gt; B</code>. In that case, the pure function argument will <em>not</em> show up in the result type of <code>map</code> or <code>filter</code>. For instance:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>val xs = squares(10)
</span><span id="1" class=""><span class="tooltip-container"></span>val ys: {xs} LzyList[Int] = xs.map(_ + 1)
</span></code></pre>
      </div> 
      <p>The type of the mapped list <code>ys</code> has only <code>xs</code> in its capture set. The actual function argument does not show up since it is pure. Likewise, if the lazy list <code>xs</code> was pure, it would not show up in any of the method results. This demonstrates that capability-based effect systems with capture checking are naturally <em>effect polymorphic</em>.</p> 
      <p>This concludes our example. It's worth mentioning that an equivalent program defining and using standard, strict lists would require no capture annotations whatsoever. It would compile exactly as written now in standard Scala 3, yet one gets the capture checking for free. Essentially, <code>=&gt;</code> already means "can capture anything" and since in a strict list side effecting operations are not retained in the result, there are no additional captures to record. A strict list could of course capture side-effecting closures in its elements but then tunnelling applies, since these elements are represented by a type variable. This means we don't need to annotate anything there either.</p> 
      <p>Another possibility would be a variant of lazy lists that requires all functions passed to <code>map</code>, <code>filter</code> and other operations like it to be pure. E.g. <code>map</code> on such a list would be defined like this:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>extension [A](xs: LzyList[A])
</span><span id="1" class=""><span class="tooltip-container"></span>  def map[B](f: A -&gt; B): LzyList[B] = ...
</span></code></pre>
      </div> 
      <p>That variant would not require any capture annotations either.</p> 
      <p>To summarize, there are two "sweet spots" of data structure design: strict lists in side-effecting or resource-aware code and lazy lists in purely functional code. Both are already correctly capture-typed without requiring any explicit annotations. Capture annotations only come into play where the semantics gets more complicated because we deal with delayed effects such as in impure lazy lists or side-effecting iterators over strict lists. This property is probably one of the greatest plus points of our approach to capture checking compared to previous techniques which tend to be more noisy.</p> 
     </section>
     <section id="function-type-shorthands"> 
      <h2><a href="#function-type-shorthands" class="anchor"></a>Function Type Shorthands</h2> 
      <p>TBD</p> 
     </section>
     <section id="compilation-options"> 
      <h2><a href="#compilation-options" class="anchor"></a>Compilation Options</h2> 
      <p>The following options are relevant for capture checking.</p> 
      <ul> 
       <li><strong>-Ycc</strong> Enables capture checking.</li> 
       <li><strong>-Xprint:cc</strong> Prints the program with capturing types as inferred by capture checking.</li> 
       <li><strong>-Ycc-debug</strong> Gives more detailed, implementation-oriented information about capture checking, as described in the next section.</li> 
      </ul> 
      <p>The implementation supporting capture checking with these options is currently in branch <code>cc-experiment</code> on dotty.epfl.ch.</p> 
     </section>
     <section id="capture-checking-internals"> 
      <h2><a href="#capture-checking-internals" class="anchor"></a>Capture Checking Internals</h2> 
      <p>The capture checker is architected as a propagation constraint solver, which runs as a separate phase after type-checking and some initial transformations.</p> 
      <p>Constraint variables stand for unknown capture sets. A constraint variable is introduced</p> 
      <ul> 
       <li>for every part of a previously inferred type,</li> 
       <li>for the accessed references of every method, class, anonymous function, or by-name argument,</li> 
       <li>for the parameters passed in a class constructor call.</li> 
      </ul> 
      <p>Capture sets in explicitly written types are treated as constants (before capture checking, such sets are simply ignored).</p> 
      <p>The capture checker essentially rechecks the program with the usual typing rules. Every time a subtype requirement between capturing types is checked, this translates to a subcapturing test on capture sets. If the two sets are constant, this is simply a yes/no question, where a no will produce an error message.</p> 
      <p>If the lower set <code>C₁</code> of a comparison <code>C₁ &lt;: C₂</code> is a variable, the set <code>C₂</code> is recorded as a <em>superset</em> of <code>C₁</code>. If the upper set <code>C₂</code> is a variable, the elements of <code>C₁</code> are <em>propagated</em> to <code>C₂</code>. Propagation of an element <code>x</code> to a set <code>C</code> means that <code>x</code> is included as an element in <code>C</code>, and it is also propagated to all known supersets of <code>C</code>. If such a superset is a constant, it is checked that <code>x</code> is included in it. If that's not the case, the original comparison <code>C₁ &lt;: C₂</code> has no solution and an error is reported.</p> 
      <p>The type checker also performs various maps on types, for instance when substituting actual argument types for formal parameter types in dependent functions, or mapping member types with "as-seen-from" in a selection. Maps keep track of the variance of positions in a type. The variance is initially covariant, it flips to contravariant in function parameter positions, and can be either covariant, contravariant, or nonvariant in type arguments, depending on the variance of the type parameter.</p> 
      <p>When capture checking, the same maps are also performed on capture sets. If a capture set is a constant, its elements (which are capabilities) are mapped as regular types. If the result of such a map is not a capability, the result is approximated according to the variance of the type. A covariant approximation replaces a type by its capture set. A contravariant approximation replaces it with the empty capture set. A nonvariant approximation replaces the enclosing capturing type with a range of possible types that gets propagated and resolved further out.</p> 
      <p>When a mapping <code>m</code> is performed on a capture set variable <code>C</code>, a new variable <code>Cm</code> is created that contains the mapped elements and that is linked with <code>C</code>. If <code>C</code> subsequently acquires further elements through propagation, these are also propagated to <code>Cm</code> after being transformed by the <code>m</code> mapping. <code>Cm</code> also gets the same supersets as <code>C</code>, mapped again using <code>m</code>.</p> 
      <p>One interesting aspect of the capture checker concerns the implementation of capture tunnelling. The <a href="https://infoscience.epfl.ch/record/290885">foundational theory</a> on which capture checking is based makes tunnelling explicit through so-called <em>box</em> and <em>unbox</em> operations. Boxing hides a capture set and unboxing recovers it. The capture checker inserts virtual box and unbox operations based on actual and expected types similar to the way the type checker inserts implicit conversions. When capture set variables are first introduced, any capture set in a capturing type that is an instance of a type parameter instance is marked as "boxed". A boxing operation is inserted if the expected type of an expression is a capturing type with a boxed capture set variable. The effect of the insertion is that any references to capabilities in the boxed expression are forgotten, which means that capture propagation is stopped. Dually, if the actual type of an expression has a boxed variable as capture set, an unbox operation is inserted, which adds all elements of the capture set to the environment.</p> 
      <p>Boxing and unboxing has no runtime effect, so the insertion of these operations is only simulated; the only visible effect is the retraction and insertion of variables in the capture sets representing the environment of the currently checked expression.</p> 
      <p>The <code>-Ycc-debug</code> option provides some insight into the workings of the capture checker. When it is turned on, boxed sets are marked explicitly and capture set variables are printed with an ID and some information about their provenance. For instance, the string <code>{f, xs}33M5V</code> indicates a capture set variable that is known to hold elements <code>f</code> and <code>xs</code>. The variable's ID is <code>33</code>. The <code>M</code> indicates that the variable was created through a mapping from a variable with ID <code>5</code>. The latter is a regular variable, as indicated by <code>V</code>.</p> 
      <p>Generally, the string following the capture set consists of alternating numbers and letters where each number gives a variable ID and each letter gives the provenance of the variable. Possible letters are</p> 
      <ul> 
       <li><code>V</code> : a regular variable,</li> 
       <li><code>M</code> : a variable resulting from a <em>mapping</em> of the variable indicated by the string to the right,</li> 
       <li><code>B</code> : similar to <code>M</code> but where the mapping is a <em>bijection</em>,</li> 
       <li><code>F</code> : a variable resulting from <em>filtering</em> the elements of the variable indicated by the string to the right,</li> 
       <li><code>I</code> : a variable resulting from an <em>intersection</em> of two capture sets,</li> 
       <li><code>D</code> : a variable resulting from the set <em>difference</em> of two capture sets.</li> 
      </ul> 
      <p>At the end of a compilation run, <code>-Ycc-debug</code> will print all variable dependencies of variables referred to in previous output. Here is an example:</p> 
      <div class="snippet"> 
       <pre><code>Capture set dependencies:
  {}2V                 ::
  {}3V                 ::
  {}4V                 ::
  {f, xs}5V            :: {f, xs}31M5V, {f, xs}32M5V
  {f, xs}31M5V         :: {xs, f}
  {f, xs}32M5V         ::
</code></pre> 
      </div> 
      <p>This section lists all variables that appeared in previous diagnostics and their dependencies, recursively. For instance, we learn that</p> 
      <ul> 
       <li>variables 2, 3, 4 are empty and have no dependencies,</li> 
       <li>variable <code>5</code> has two dependencies: variables <code>31</code> and <code>32</code> which both result from mapping variable <code>5</code>,</li> 
       <li>variable <code>31</code> has a constant fixed superset <code>{xs, f}</code></li> 
       <li>variable <code>32</code> has no dependencies.</li> 
      </ul> 
     </section> 
    </main> 
    <nav class="arrows-wrapper" aria-label="Page navigation"> <a rel="prev" href="main-annotation.html" class="arrows previous" aria-keyshortcuts="Left"> <span>MainAnnotation</span> <i class="fa fa-angle-left"></i> </a> <a rel="next" href="../syntax.html" class="arrows next" aria-keyshortcuts="Right"> <span>Scala 3 Syntax Summary</span> <i class="fa fa-angle-right"></i> </a> 
    </nav> 
    <div class="content-contributors hidden"> <span><b>Contributors to this page</b></span> 
     <div id="documentation-contributors" class="contributors-container"></div> 
    </div> 
   </div> 
  </div>
 </body>
</html></div></main><footer><div id="generated-by"><span class="footer-text">Generated by</span><a href="https://github.com/lampepfl/dotty/tree/master/scaladoc"><img src="../images/scaladoc_logo.svg" alt="scaladoc" class="scaladoc_logo"></img><img src="../images/scaladoc_logo_dark.svg" alt="scaladoc" class="scaladoc_logo_dark"></img></a></div><span id="footer-text">Copyright (c) 2002-2022, LAMP/EPFL</span><div class="socials"><span class="footer-text">Social links</span><a href="https://github.com/lampepfl/dotty"><span class="social-icon" data-icon-path="github-icon-black.png"></span></a><a href="https://discord.com/invite/scala"><span class="social-icon" data-icon-path="discord-icon-black.png"></span></a><a href="https://twitter.com/scala_lang"><span class="social-icon" data-icon-path="twitter-icon-black.png"></span></a></div><div class="mode"><span class="footer-text">Mode</span><label id="theme-toggle" class="switch"><input type="checkbox"></input><span class="slider"></span></label></div><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span><span class="footer-text">Back to top</span></a></span></footer></div><div id="toc"><span class="toc-title">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><ul><li><a href="#overview">Overview</a></li><li><a href="#capabilities-and-capturing-types">Capabilities and Capturing Types</a></li><li><a href="#function-types">Function Types</a></li><li><a href="#by-name-parameter-types">By-Name Parameter Types</a></li><li><a href="#subtyping-and-subcapturing">Subtyping and Subcapturing</a></li><li><a href="#capability-classes">Capability Classes</a></li><li><a href="#capture-checking-of-closures">Capture Checking of Closures</a></li><li><a href="#capture-checking-of-classes">Capture Checking of Classes</a></li><li><a href="#capture-tunnelling">Capture Tunnelling</a></li><li><a href="#escape-checking">Escape Checking</a></li><li><a href="#checked-exceptions">Checked Exceptions</a></li><li><a href="#a-larger-example">A Larger Example</a></li><li><a href="#function-type-shorthands">Function Type Shorthands</a></li><li><a href="#compilation-options">Compilation Options</a></li><li><a href="#capture-checking-internals">Capture Checking Internals</a></li></ul></li></ul></nav></div></div></body></html>