<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/lampepfl/dotty" data-githubContributorsFilename="docs/_docs/reference/experimental/canthrow.md" data-pathToRoot="../"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>CanThrow Capabilities</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><link rel="dns-prefetch" href="//fonts.googleapis.com"> 
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
<link rel="stylesheet" href="/css/dottydoc.css"></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.3.1-RC1</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../index.html">Docs</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni n1 "><span class="nh de"><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni n1 "><span class="nh de"><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/staging.html"><span>Run-Time Multi-Stage Programming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits and Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-checking.html"><span>Changes in Type Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>Experimental</span></a></span><div class="ni n1 expanded"><span class="nh h100 selected de"><a href="#"><span>CanThrow Capabilities</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="cc.html"><span>Capture Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="tupled-function.html"><span>Tupled Function</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2023, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2023, LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Experimental</a>/<a href="canthrow.html">CanThrow Capabilities</a></div><div id="content" class="body-medium"><div><div id="content-wrapper"> 
 <div class="site-container"> 
  <div id="site-header"></div> 
  <main> 
   <header> <a class="text-button with-link body-small" href="https://github.com/lampepfl/dotty/edit/language-reference-stable/docs/_docs/reference/experimental/canthrow.md">Edit this page on GitHub</a> 
    <h1 class="h600">CanThrow Capabilities</h1> 
   </header> 
   <p class="body-large first-p">This page describes experimental support for exception checking in Scala 3. It is enabled by the language import</p> 
   <div class="snippet mono-small-block" scala-snippet=""> 
    <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import language.experimental.saferExceptions
</span></code></pre> 
    <div class="buttons"></div> 
   </div> 
   <p>The reason for publishing this extension now is to get feedback on its usability. We are working on more advanced type systems that build on the general ideas put forward in the extension. Those type systems have application areas beyond checked exceptions. Exception checking is a useful starting point since exceptions are familiar to all Scala programmers and their current treatment leaves room for improvement.</p> 
   <section id="why-exceptions-1"> 
    <h2 class="h500"><a href="#why-exceptions-1" class="anchor"></a>Why Exceptions?</h2> 
    <p>Exceptions are an ideal mechanism for error handling in many situations. They serve the intended purpose of propagating error conditions with a minimum of boilerplate. They cause zero overhead for the "happy path", which means they are very efficient as long as errors arise infrequently. Exceptions are also debug friendly, since they produce stack traces that can be inspected at the handler site. So one never has to guess where an erroneous condition originated.</p> 
   </section> 
   <section id="why-not-exceptions-1"> 
    <h2 class="h500"><a href="#why-not-exceptions-1" class="anchor"></a>Why Not Exceptions?</h2> 
    <p>However, exceptions in current Scala and many other languages are not reflected in the type system. This means that an essential part of the contract of a function - i.e. what exceptions can it produce? - is not statically checked. Most people acknowledge that this is a problem, but that so far the alternative of checked exceptions was just too painful to be considered. A good example are Java checked exceptions, which do the right thing in principle, but are widely regarded as a mistake since they are so difficult to deal with. So far, none of the successor languages that are modeled after Java or that build on the JVM has copied this feature. See for example Anders Hejlsberg's <a href="https://www.artima.com/articles/the-trouble-with-checked-exceptions">statement on why C# does not have checked exceptions</a>.</p> 
   </section> 
   <section id="the-problem-with-javas-checked-exceptions-1"> 
    <h2 class="h500"><a href="#the-problem-with-javas-checked-exceptions-1" class="anchor"></a>The Problem With Java's Checked Exceptions</h2> 
    <p>The main problem with <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-11.html#jls-11.2">Java's checked exception model</a> is its inflexibility, which is due to lack of polymorphism. Consider for instance the <code>map</code> function which is declared on <code>List[A]</code> like this:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def map[B](f: A =&gt; B): List[B]
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>In the Java model, function <code>f</code> is not allowed to throw a checked exception. So the following call would be invalid:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>xs.map(x =&gt; if x &lt; limit then x * x else throw LimitExceeded())
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>The only way around this would be to wrap the checked exception <code>LimitExceeded</code> in an unchecked <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/RuntimeException.html"><code>java.lang.RuntimeException</code></a> that is caught at the callsite and unwrapped again. Something like this:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>try
</span><span line-number="2" class=""><span class="tooltip-container"></span>    xs.map(x =&gt; if x &lt; limit then x * x else throw Wrapper(LimitExceeded()))
</span><span line-number="3" class=""><span class="tooltip-container"></span>  catch case Wrapper(ex) =&gt; throw ex
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Ugh! No wonder checked exceptions in Java are not very popular.</p> 
   </section> 
   <section id="monadic-effects-1"> 
    <h2 class="h500"><a href="#monadic-effects-1" class="anchor"></a>Monadic Effects</h2> 
    <p>So the dilemma is that exceptions are easy to use only as long as we forget static type checking. This has caused many people working with Scala to abandon exceptions altogether and to use an error monad like <a href="https://scala-lang.org/api/3.x/scala/util/Either.html"><code>Either</code></a> instead. This can work in many situations but is not without its downsides either. It makes code a lot more complicated and harder to refactor. It means one is quickly confronted with the problem how to work with several monads. In general, dealing with one monad at a time in Scala is straightforward but dealing with several monads together is much less pleasant since monads don't compose. A great number of techniques have been proposed, implemented, and promoted to deal with this, from monad transformers, to free monads, to tagless final. But none of these techniques is universally liked; each introduces a complicated DSL that's hard to understand for non-experts, introduces runtime overheads, and makes debugging difficult. In the end, quite a few developers prefer to work instead with a single "super-monad" like <a href="https://zio.dev/version-1.x/datatypes/core/zio"><code>ZIO</code></a> that has error propagation built in alongside other aspects. This one-size fits all approach can work very nicely, even though (or is it because?) it represents an all-encompassing framework.</p> 
    <p>However, a programming language is not a framework; it has to cater also for those applications that do not fit the framework's use cases. So there's still a strong motivation for getting exception checking right.</p> 
   </section> 
   <section id="from-effects-to-capabilities-1"> 
    <h2 class="h500"><a href="#from-effects-to-capabilities-1" class="anchor"></a>From Effects To Capabilities</h2> 
    <p>Why does <code>map</code> work so poorly with Java's checked exception model? It's because <code>map</code>'s signature limits function arguments to not throw checked exceptions. We could try to come up with a more polymorphic formulation of <code>map</code>. For instance, it could look like this:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def map[B, E](f: A =&gt; B throws E): List[B] throws E
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>This assumes a type <code>A throws E</code> to indicate computations of type <code>A</code> that can throw an exception of type <code>E</code>. But in practice the overhead of the additional type parameters makes this approach unappealing as well. Note in particular that we'd have to parameterize <em>every method</em> that takes a function argument that way, so the added overhead of declaring all these exception types looks just like a sort of ceremony we would like to avoid.</p> 
    <p>But there is a way to avoid the ceremony. Instead of concentrating on possible <em>effects</em> such as "this code might throw an exception", concentrate on <em>capabilities</em> such as "this code needs the capability to throw an exception". From a standpoint of expressiveness this is quite similar. But capabilities can be expressed as parameters whereas traditionally effects are expressed as some addition to result values. It turns out that this can make a big difference!</p> 
   </section> 
   <section id="the-canthrow-capability-1"> 
    <h2 class="h500"><a href="#the-canthrow-capability-1" class="anchor"></a>The <code>CanThrow</code> Capability</h2> 
    <p>In the <em>effects as capabilities</em> model, an effect is expressed as an (implicit) parameter of a certain type. For exceptions we would expect parameters of type <a href="https://scala-lang.org/api/3.x/scala/CanThrow.html"><code>CanThrow[E]</code></a> where <code>E</code> stands for the exception that can be thrown. Here is the definition of <code>CanThrow</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>erased class CanThrow[-E &lt;: Exception]
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>This shows another experimental Scala feature: <a href="erased-defs.html">erased definitions</a>. Roughly speaking, values of an erased class do not generate runtime code; they are erased before code generation. This means that all <code>CanThrow</code> capabilities are compile-time only artifacts; they do not have a runtime footprint.</p> 
    <p>Now, if the compiler sees a <code>throw Exc()</code> construct where <code>Exc</code> is a checked exception, it will check that there is a capability of type <code>CanThrow[Exc]</code> that can be summoned as a given. It's a compile-time error if that's not the case.</p> 
    <p>How can the capability be produced? There are several possibilities:</p> 
    <p>Most often, the capability is produced by having a using clause <code>(using CanThrow[Exc])</code> in some enclosing scope. This roughly corresponds to a <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.6"><code>throws</code></a> clause in Java. The analogy is even stronger since alongside <a href="https://scala-lang.org/api/3.x/scala/CanThrow.html"><code>CanThrow</code></a> there is also the following type alias defined in the <a href="https://scala-lang.org/api/3.x/scala.html"><code>scala</code></a> package:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>infix type A = Int
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>infix type $throws[R, +E &lt;: Exception] = CanThrow[E] ?=&gt; R
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>That is, <a href="https://scala-lang.org/api/3.x/scala/runtime.html#$throws-0"><code>R $throws E</code></a> is a context function type that takes an implicit <code>CanThrow[E]</code> parameter and that returns a value of type <code>R</code>. What's more, the compiler will translate an infix types with <code>throws</code> as the operator to <code>$throws</code> applications according to the rules</p> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">    </span>            A throws E  --&gt;  A $throws E
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable">    </span>A throws E₁ | ... | Eᵢ  --&gt;  A $throws E₁ ... $throws Eᵢ
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Therefore, a method written like this:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def m(x: T)(using CanThrow[E]): U
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>can alternatively be expressed like this:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def m(x: T): U throws E
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Also the capability to throw multiple types of exceptions can be expressed in a few ways as shown in the examples below:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def m(x: T): U throws E1 | E2
</span><span line-number="2" class=""><span class="tooltip-container"></span>def m(x: T): U throws E1 throws E2
</span><span line-number="3" class=""><span class="tooltip-container"></span>def m(x: T)(using CanThrow[E1], CanThrow[E2]): U
</span><span line-number="4" class=""><span class="tooltip-container"></span>def m(x: T)(using CanThrow[E1])(using CanThrow[E2]): U
</span><span line-number="5" class=""><span class="tooltip-container"></span>def m(x: T)(using CanThrow[E1]): U throws E2
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p><strong>Note 1:</strong> A signature like</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def m(x: T)(using CanThrow[E1 | E2]): U
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>would also allow throwing <code>E1</code> or <code>E2</code> inside the method's body but might cause problems when someone tried to call this method from another method declaring its <code>CanThrow</code> capabilities like in the earlier examples. This is because <code>CanThrow</code> has a contravariant type parameter so <code>CanThrow[E1 | E2]</code> is a subtype of both <code>CanThrow[E1]</code> and <code>CanThrow[E2]</code>. Hence the presence of a given instance of <code>CanThrow[E1 | E2]</code> in scope satisfies the requirement for <code>CanThrow[E1]</code> and <code>CanThrow[E2]</code> but given instances of <code>CanThrow[E1]</code> and <code>CanThrow[E2]</code> cannot be combined to provide and instance of <code>CanThrow[E1 | E2]</code>.</p> 
    <p><strong>Note 2:</strong> One should keep in mind that <code>|</code> binds its left and right arguments more tightly than <code>throws</code> so <code>A | B throws E1 | E2</code> means <code>(A | B) throws (Ex1 | Ex2)</code>, not <code>A | (B throws E1) | E2</code>.</p> 
    <p>The <code>CanThrow</code>/<code>throws</code> combo essentially propagates the <code>CanThrow</code> requirement outwards. But where are these capabilities created in the first place? That's in the <code>try</code> expression. Given a <code>try</code> like this:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>try
</span><span line-number="2" class=""><span class="tooltip-container"></span>  body
</span><span line-number="3" class=""><span class="tooltip-container"></span>catch
</span><span line-number="4" class=""><span class="tooltip-container"></span>  case ex1: Ex1 =&gt; handler1
</span><span line-number="5" class=""><span class="tooltip-container"></span>  ...
</span><span line-number="6" class=""><span class="tooltip-container"></span>  case exN: ExN =&gt; handlerN
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>the compiler generates an accumulated capability of type <code>CanThrow[Ex1 | ... | Ex2]</code> that is available as a given in the scope of <code>body</code>. It does this by augmenting the <code>try</code> roughly as follows:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>try
</span><span line-number="2" class=""><span class="tooltip-container"></span>  erased given CanThrow[Ex1 | ... | ExN] = compiletime.erasedValue
</span><span line-number="3" class=""><span class="tooltip-container"></span>  body
</span><span line-number="4" class=""><span class="tooltip-container"></span>catch ...
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Note that the right-hand side of the synthesized given is <code>compiletime.erasedValue</code>. This is OK since this given is erased; it will not be executed at runtime.</p> 
    <p><strong>Note 1:</strong> The <a href="https://scala-lang.org/api/3.x/scala/runtime/stdLibPatches/language$$experimental$$saferExceptions$.html"><code>saferExceptions</code></a> feature is designed to work only with checked exceptions. An exception type is <em>checked</em> if it is a subtype of <code>Exception</code> but not of <code>RuntimeException</code>. The signature of <code>CanThrow</code> still admits <code>RuntimeException</code>s since <code>RuntimeException</code> is a proper subtype of its bound, <code>Exception</code>. But no capabilities will be generated for <code>RuntimeException</code>s. Furthermore, <code>throws</code> clauses also may not refer to <code>RuntimeException</code>s.</p> 
    <p><strong>Note 2:</strong> To keep things simple, the compiler will currently only generate capabilities for catch clauses of the form</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case ex: Ex =&gt;
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>where <code>ex</code> is an arbitrary variable name (<code>_</code> is also allowed), and <code>Ex</code> is an arbitrary checked exception type. Constructor patterns such as <code>Ex(...)</code> or patterns with guards are not allowed. The compiler will issue an error if one of these is used to catch a checked exception and <code>saferExceptions</code> is enabled.</p> 
   </section> 
   <section id="example-14"> 
    <h2 class="h500"><a href="#example-14" class="anchor"></a>Example</h2> 
    <p>That's it. Let's see it in action in an example. First, add an import</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import language.experimental.saferExceptions
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>to enable exception checking. Now, define an exception <code>LimitExceeded</code> and a function <code>f</code> like this:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val limit = 10e9
</span><span line-number="2" class=""><span class="tooltip-container"></span>class LimitExceeded extends Exception
</span><span line-number="3" class=""><span class="tooltip-container"></span>def f(x: Double): Double =
</span><span line-number="4" class=""><span class="tooltip-container"></span>  if x &lt; limit then x * x else throw LimitExceeded()
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>You'll get this error message:</p> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>  if x &lt; limit then x * x else throw LimitExceeded()
</span><span line-number="2" class=""><span class="tooltip-container"></span>                               ^^^^^^^^^^^^^^^^^^^^^
</span><span line-number="3" class=""><span class="tooltip-container"></span>The capability to throw exception LimitExceeded is missing.
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>The capability can be provided by one of the following:</p> 
    <ul> 
     <li>Adding a using clause <code>(using CanThrow[LimitExceeded])</code> to the definition of the enclosing method</li> 
     <li>Adding <code>throws LimitExceeded</code> clause after the result type of the enclosing method</li> 
     <li>Wrapping this piece of code with a <code>try</code> block that catches <code>LimitExceeded</code></li> 
    </ul> 
    <p>The following import might fix the problem:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import unsafeExceptions.canThrowAny
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>As the error message implies, you have to declare that <code>f</code> needs the capability to throw a <code>LimitExceeded</code> exception. The most concise way to do so is to add a <code>throws</code> clause:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def f(x: Double): Double throws LimitExceeded =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  if x &lt; limit then x * x else throw LimitExceeded()
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Now put a call to <code>f</code> in a <code>try</code> that catches <code>LimitExceeded</code>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>@main def test(xs: Double*) =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  try println(xs.map(f).sum)
</span><span line-number="3" class=""><span class="tooltip-container"></span>  catch case ex: LimitExceeded =&gt; println("too large")
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Run the program with some inputs:</p> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>&gt; scala test 1 2 3
</span><span line-number="2" class=""><span class="tooltip-container"></span>14.0
</span><span line-number="3" class=""><span class="tooltip-container"></span>&gt; scala test
</span><span line-number="4" class=""><span class="tooltip-container"></span>0.0
</span><span line-number="5" class=""><span class="tooltip-container"></span>&gt; scala test 1 2 3 100000000000
</span><span line-number="6" class=""><span class="tooltip-container"></span>too large
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Everything typechecks and works as expected. But wait - we have called <code>map</code> without any ceremony! How did that work? Here's how the compiler expands the <code>test</code> function:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// compiler-generated code
</span><span line-number="2" class=""><span class="tooltip-container"></span>@main def test(xs: Double*) =
</span><span line-number="3" class=""><span class="tooltip-container"></span>  try
</span><span line-number="4" class=""><span class="tooltip-container"></span>    erased given ctl: CanThrow[LimitExceeded] = compiletime.erasedValue
</span><span line-number="5" class=""><span class="tooltip-container"></span>    println(xs.map(x =&gt; f(x)(using ctl)).sum)
</span><span line-number="6" class=""><span class="tooltip-container"></span>  catch case ex: LimitExceeded =&gt; println("too large")
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>The <code>CanThrow[LimitExceeded]</code> capability is passed in a synthesized <code>using</code> clause to <code>f</code>, since <code>f</code> requires it. Then the resulting closure is passed to <code>map</code>. The signature of <code>map</code> does not have to account for effects. It takes a closure as always, but that closure may refer to capabilities in its free variables. This means that <code>map</code> is already effect polymorphic even though we did not change its signature at all. So the takeaway is that the effects as capabilities model naturally provides for effect polymorphism whereas this is something that other approaches struggle with.</p> 
   </section> 
   <section id="gradual-typing-via-imports-1"> 
    <h2 class="h500"><a href="#gradual-typing-via-imports-1" class="anchor"></a>Gradual Typing Via Imports</h2> 
    <p>Another advantage is that the model allows a gradual migration from current unchecked exceptions to safer exceptions. Imagine for a moment that <a href="https://scala-lang.org/api/3.x/scala/runtime/stdLibPatches/language$$experimental$$saferExceptions$.html"><code>experimental.saferExceptions</code></a> is turned on everywhere. There would be lots of code that breaks since functions have not yet been properly annotated with <code>throws</code>. But it's easy to create an escape hatch that lets us ignore the breakages for a while: simply add the import</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.unsafeExceptions.canThrowAny
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>This will provide the <a href="https://scala-lang.org/api/3.x/scala/CanThrow.html"><code>CanThrow</code></a> capability for any exception, and thereby allow all throws and all other calls, no matter what the current state of <code>throws</code> declarations is. Here's the definition of <a href="https://scala-lang.org/api/3.x/scala/unsafeExceptions$.html#canThrowAny-0"><code>canThrowAny</code></a>:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>package scala
</span><span line-number="2" class=""><span class="tooltip-container"></span>object unsafeExceptions:
</span><span line-number="3" class=""><span class="tooltip-container"></span>  given canThrowAny: CanThrow[Exception] = ???
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Of course, defining a global capability like this amounts to cheating. But the cheating is useful for gradual typing. The import could be used to migrate existing code, or to enable more fluid explorations of code without regard for complete exception safety. At the end of these migrations or explorations the import should be removed.</p> 
   </section> 
   <section id="scope-of-the-extension-1"> 
    <h2 class="h500"><a href="#scope-of-the-extension-1" class="anchor"></a>Scope Of the Extension</h2> 
    <p>To summarize, the extension for safer exception checking consists of the following elements:</p> 
    <ul> 
     <li>It adds to the standard library the class <code>scala.CanThrow</code>, the type <code>scala.$throws</code>, and the <a href="https://scala-lang.org/api/3.x/scala/unsafeExceptions$.html"><code>scala.unsafeExceptions</code></a> object, as they were described above.</li> 
     <li>It adds some desugaring rules ro rewrite <code>throws</code> types to cascaded <code>$throws</code> types.</li> 
     <li>It augments the type checking of <code>throw</code> by <em>demanding</em> a <code>CanThrow</code> capability or the thrown exception.</li> 
     <li>It augments the type checking of <code>try</code> by <em>providing</em> <code>CanThrow</code> capabilities for every caught exception.</li> 
    </ul> 
    <p>That's all. It's quite remarkable that one can do exception checking in this way without any special additions to the type system. We just need regular givens and context functions. Any runtime overhead is eliminated using <code>erased</code>.</p> 
   </section> 
   <section id="caveats-3"> 
    <h2 class="h500"><a href="#caveats-3" class="anchor"></a>Caveats</h2> 
    <p>Our capability model allows to declare and check the thrown exceptions of first-order code. But as it stands, it does not give us enough mechanism to enforce the <em>absence</em> of capabilities for arguments to higher-order functions. Consider a variant <code>pureMap</code> of <code>map</code> that should enforce that its argument does not throw exceptions or have any other effects (maybe because wants to reorder computations transparently). Right now we cannot enforce that since the function argument to <code>pureMap</code> can capture arbitrary capabilities in its free variables without them showing up in its type. One possible way to address this would be to introduce a pure function type (maybe written <code>A -&gt; B</code>). Pure functions are not allowed to close over capabilities. Then <code>pureMap</code> could be written like this:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def pureMap(f: A -&gt; B): List[B]
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Another area where the lack of purity requirements shows up is when capabilities escape from bounded scopes. Consider the following function</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def escaped(xs: Double*): () =&gt; Int =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  try () =&gt; xs.map(f).sum
</span><span line-number="3" class=""><span class="tooltip-container"></span>  catch case ex: LimitExceeded =&gt; -1
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>With the system presented here, this function typechecks, with expansion</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// compiler-generated code
</span><span line-number="2" class=""><span class="tooltip-container"></span>def escaped(xs: Double*): () =&gt; Int =
</span><span line-number="3" class=""><span class="tooltip-container"></span>  try
</span><span line-number="4" class=""><span class="tooltip-container"></span>    given ctl: CanThrow[LimitExceeded] = ???
</span><span line-number="5" class=""><span class="tooltip-container"></span>    () =&gt; xs.map(x =&gt; f(x)(using ctl)).sum
</span><span line-number="6" class=""><span class="tooltip-container"></span>  catch case ex: LimitExceeded =&gt; -1
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>But if you try to call <code>escaped</code> like this</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val g = escaped(1, 2, 1000000000)
</span><span line-number="2" class=""><span class="tooltip-container"></span>g()
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>the result will be a <code>LimitExceeded</code> exception thrown at the second line where <code>g</code> is called. What's missing is that <code>try</code> should enforce that the capabilities it generates do not escape as free variables in the result of its body. It makes sense to describe such scoped effects as <em>ephemeral capabilities</em> - they have lifetimes that cannot be extended to delayed code in a lambda.</p> 
   </section> 
   <section id="outlook-1"> 
    <h2 class="h500"><a href="#outlook-1" class="anchor"></a>Outlook</h2> 
    <p>We are working on a new class of type system that supports ephemeral capabilities by tracking the free variables of values. Once that research matures, it will hopefully be possible to augment the Scala language so that we can enforce the missing properties.</p> 
    <p>And it would have many other applications besides: Exceptions are a special case of <em>algebraic effects</em>, which has been a very active research area over the last 20 years and is finding its way into programming languages (e.g. <a href="https://koka-lang.github.io/koka/doc/book.html#why-handlers">Koka</a>, <a href="https://www.eff-lang.org/learn/">Eff</a>, <a href="https://discuss.ocaml.org/t/multicore-ocaml-september-2021-effect-handlers-will-be-in-ocaml-5-0/8554">Multicore OCaml</a>, <a href="https://www.unisonweb.org/docs/language-reference/#abilities-and-ability-handlers">Unison</a>). In fact, algebraic effects have been characterized as being equivalent to exceptions with an additional <em>resume</em> operation. The techniques developed here for exceptions can probably be generalized to other classes of algebraic effects.</p> 
    <p>But even without these additional mechanisms, exception checking is already useful as it is. It gives a clear path forward to make code that uses exceptions safer, better documented, and easier to refactor. The only loophole arises for scoped capabilities - here we have to verify manually that these capabilities do not escape. Specifically, a <code>try</code> always has to be placed in the same computation stage as the throws that it enables.</p> 
    <p>Put another way: If the status quo is 0% static checking since 100% is too painful, then an alternative that gives you 95% static checking with great ergonomics looks like a win. And we might still get to 100% in the future.</p> 
    <p>For more info, see also our <a href="https://infoscience.epfl.ch/record/290885">paper at the ACM Scala Symposium 2021</a>.</p> 
   </section> 
  </main> 
  <div class="divider"></div> 
  <nav class="arrow-navigation" aria-label="Page navigation"> 
   <div> <span class="body-small">Previous</span> <a rel="prev" href="index.html" aria-keyshortcuts="Left" class="body-medium"> <span class="body-medium">Experimental</span> </a> 
   </div> 
   <div> <span class="body-small">Next</span> <a rel="next" href="erased-defs.html" aria-keyshortcuts="Right" class="body-medium"> <span class="body-medium">Erased Definitions</span> </a> 
   </div> 
  </nav> 
 </div> 
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#why-exceptions-1">Why Exceptions?</a></li><li><a href="#why-not-exceptions-1">Why Not Exceptions?</a></li><li><a href="#the-problem-with-javas-checked-exceptions-1">The Problem With Java&apos;s Checked Exceptions</a></li><li><a href="#monadic-effects-1">Monadic Effects</a></li><li><a href="#from-effects-to-capabilities-1">From Effects To Capabilities</a></li><li><a href="#the-canthrow-capability-1">The CanThrow Capability</a></li><li><a href="#example-14">Example</a></li><li><a href="#gradual-typing-via-imports-1">Gradual Typing Via Imports</a></li><li><a href="#scope-of-the-extension-1">Scope Of the Extension</a></li><li><a href="#caveats-3">Caveats</a></li><li><a href="#outlook-1">Outlook</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://gitter.im/scala/scala"><button class="icon-button gitter"></button></a><div class="text">Copyright (c) 2002-2023, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2023, LAMP/EPFL</div></div></div></div></body></html>