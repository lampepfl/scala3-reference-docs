<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Type Class Derivation</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><link rel="stylesheet" href="../css/bootstrap.min.css"></link><link rel="stylesheet" href="../css/dottydoc.css"></link><link rel="stylesheet" href="../css/color-brewer.css"></link><script type="text/javascript" src="../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../js/bootstrap.min.js" defer="true"></script><link rel="stylesheet" href="../css/content-contributors.css"></link><script type="text/javascript" src="../js/contributors.js" defer="true"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/scalastyle.css"></link><link rel="stylesheet" href="../styles/colors.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/diagram.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/ux.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.min.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><script>var pathToRoot = "../";</script><script>var githubContributorsUrl = "https://api.github.com/repos/lampepfl/dotty";</script><script>var githubContributorsFilename = "docs/_docs/reference/contextual/derivation.md";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"><span><img src="../project-logo/logo.svg"></img></span><span><div class="projectName">Scala 3 Reference</div></span><div id="version"><div class="versions-dropdown"><div onclick="dropdownHandler()" id="dropdown-button" class="dropdownbtn dropdownbtnactive"><div class="projectVersion">3.2.0</div><div id="dropdown-content" class="dropdown-content"><input type="text" placeholder="Search..." id="dropdown-input" onkeyup="filterFunction()"></input></div></div></div></div><div class="socials"><a href="https://github.com/lampepfl/dotty"><span class="social-icon" data-icon-path="github-icon-white.png"></span></a><a href="https://discord.com/invite/scala"><span class="social-icon" data-icon-path="discord-icon-white.png"></span></a><a href="https://twitter.com/scala_lang"><span class="social-icon" data-icon-path="twitter-icon-white.png"></span></a></div></div><div id="paneSearch"></div><nav id="sideMenu2"><div class="ni expanded"><span class="nh expanded"><span class="ar"></span><a href="../index.html"><span>Scala 3 Reference</span></a></span><div class="ni"><span class="nh "><span class="ar"></span><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni "><span class="nh "><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni "><span class="nh "><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni "><span class="nh "><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni "><span class="nh "><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni "><span class="nh "><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni expanded"><span class="nh expanded"><span class="ar"></span><a href="index.html"><span>Contextual Abstractions</span></a></span><div class="ni "><span class="nh "><a href="givens.html"><span>Given Instances</span></a></span></div><div class="ni "><span class="nh "><a href="using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni "><span class="nh "><a href="context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni "><span class="nh "><a href="given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni "><span class="nh "><a href="extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni "><span class="nh "><a href="right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni "><span class="nh "><a href="type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni expanded"><span class="nh selected"><a href="derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni "><span class="nh "><a href="derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni "><span class="nh "><a href="multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni "><span class="nh "><a href="context-functions.html"><span>Context Functions</span></a></span></div><div class="ni "><span class="nh "><a href="conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni "><span class="nh "><a href="by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni "><span class="nh "><a href="relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni "><span class="nh "><a href="../metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/staging.html"><span>Runtime Multi-Stage Programming</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni "><span class="nh "><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni "><span class="nh "><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/type-checking.html"><span>Changes in Type Checking</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni "><span class="nh "><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../experimental/index.html"><span>Experimental</span></a></span><div class="ni "><span class="nh "><a href="../experimental/canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/cc.html"><span>Capture Checking</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/tupled-function.html"><span>Tupled Function</span></a></span></div></div><div class="ni "><span class="nh "><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni "><span class="nh "><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni "><span class="nh "><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni "><span class="nh "><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni "><span class="nh "><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></div></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="scaladoc-searchBar"></div><main id="main-content"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Contextual Abstractions</a>/<a href="derivation.html">Type Class Derivation</a></div><div id="content"><html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <div class="container"> 
    <div id="site-header"> 
     <div class="wrap"> 
      <nav class="navigation" role="menu"> 
       <ul class="navigation-menu"> 
        <li class="navigation-menu-item"> <a href="https://docs.scala-lang.org/" class="active">Learn</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/download/">Install</a> </li> 
        <li class="navigation-menu-item"> <a href="https://scastie.scala-lang.org">Playground</a> </li> 
        <li class="navigation-menu-item"> <a href="https://index.scala-lang.org">Find A Library</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/community/">Community</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/blog/">Blog</a> </li> 
       </ul> 
      </nav> 
     </div> 
    </div> 
    <main> 
     <header> 
      <h1>Type Class Derivation</h1> 
      <div class="byline"> <a href="https://github.com/lampepfl/dotty/edit/language-reference-stable/docs/_docs/reference/contextual/derivation.md"> <i class="far fa-edit"></i> Edit this page on GitHub </a> 
      </div> 
     </header> 
     <p>Type class derivation is a way to automatically generate given instances for type classes which satisfy some simple conditions. A type class in this sense is any trait or class with a single type parameter determining the type being operated on, and the special case <code>CanEqual</code>. Common examples are <code>Eq</code>, <code>Ordering</code>, or <code>Show</code>. For example, given the following <code>Tree</code> algebraic data type (ADT):</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>enum Tree[T] derives Eq, Ordering, Show:
</span><span id="1" class=""><span class="tooltip-container"></span>  case Branch(left: Tree[T], right: Tree[T])
</span><span id="2" class=""><span class="tooltip-container"></span>  case Leaf(elem: T)
</span></code></pre>
     </div> 
     <p>The <code>derives</code> clause generates the following given instances for the <code>Eq</code>, <code>Ordering</code> and <code>Show</code> type classes in the companion object of <code>Tree</code>:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given [T: Eq]       : Eq[Tree[T]]       = Eq.derived
</span><span id="1" class=""><span class="tooltip-container"></span>given [T: Ordering] : Ordering[Tree[T]] = Ordering.derived
</span><span id="2" class=""><span class="tooltip-container"></span>given [T: Show]     : Show[Tree[T]]     = Show.derived
</span></code></pre>
     </div> 
     <p>We say that <code>Tree</code> is the <em>deriving type</em> and that the <code>Eq</code>, <code>Ordering</code> and <code>Show</code> instances are <em>derived instances</em>.</p> 
     <p><strong>Note:</strong> <code>derived</code> can be used manually, this is useful when you do not have control over the definition. For example we can implement <code>Ordering</code> for <code>Option</code>s like so:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given [T: Ordering]: Ordering[Option[T]] = Ordering.derived
</span></code></pre>
     </div> 
     <p>It is discouraged to directly refer to the <code>derived</code> member if you can use a <code>derives</code> clause instead.</p> 
     <section id="exact-mechanism"> 
      <h2><a href="#exact-mechanism" class="anchor"></a>Exact mechanism</h2> 
      <p>In the following, when type arguments are enumerated and the first index evaluates to a larger value than the last, then there are actually no arguments, for example: <code>A[T_2, ..., T_1]</code> means <code>A</code>.</p> 
      <p>For a class/trait/object/enum <code>DerivingType[T_1, ..., T_N] derives TC</code>, a derived instance is created in <code>DerivingType</code>'s companion object (or <code>DerivingType</code> itself if it is an object).</p> 
      <p>The general "shape" of the derived instance is as follows:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given [...](using ...): TC[ ... DerivingType[...] ... ] = TC.derived
</span></code></pre>
      </div> 
      <p><code>TC.derived</code> should be an expression that conforms to the expected type on the left, potentially elaborated using term and/or type inference.</p> 
      <p><strong>Note:</strong> <code>TC.derived</code> is a normal access, therefore if there are multiple definitions of <code>TC.derived</code>, overloading resolution applies.</p> 
      <p>What the derived instance precisely looks like depends on the specifics of <code>DerivingType</code> and <code>TC</code>, we first examine <code>TC</code>:</p> 
     </section>
     <section id="tc-takes-1-parameter-f"> 
      <h3><a href="#tc-takes-1-parameter-f" class="anchor"></a><code>TC</code> takes 1 parameter <code>F</code></h3> 
      <p>Therefore <code>TC</code> is defined as <code>TC[F[A_1, ..., A_K]]</code> (<code>TC[F]</code> if <code>K == 0</code>) for some <code>F</code>. There are two further cases depending on the kinds of arguments:</p> 
     </section>
     <section id="f-and-all-arguments-of-derivingtype-have-kind-"> 
      <h4><a href="#f-and-all-arguments-of-derivingtype-have-kind-" class="anchor"></a><code>F</code> and all arguments of <code>DerivingType</code> have kind <code>*</code></h4> 
      <p><strong>Note:</strong> <code>K == 0</code> in this case.</p> 
      <p>The generated instance is then:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given [T_1: TC, ..., T_N: TC]: TC[DerivingType[T_1, ..., T_N]] = TC.derived
</span></code></pre>
      </div> 
      <p>This is the most common case, and is the one that was highlighted in the introduction.</p> 
      <p><strong>Note:</strong> The <code>[T_i: TC, ...]</code> introduces a <code>(using TC[T_i], ...)</code>, more information in <a href="context-bounds.html">Context Bounds</a>. This allows the <code>derived</code> member to access these evidences.</p> 
      <p><strong>Note:</strong> If <code>N == 0</code> the above means:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given TC[DerivingType] = TC.derived
</span></code></pre>
      </div> 
      <p>For example, the class</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>case class Point(x: Int, y: Int) derives Ordering
</span></code></pre>
      </div> 
      <p>generates the instance</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>object Point:
</span><span id="1" class=""><span class="tooltip-container"></span>  ...
</span><span id="2" class=""><span class="tooltip-container"></span>  given Ordering[Point] = Ordering.derived
</span></code></pre>
      </div>
     </section>
     <section id="f-and-derivingtype-have-parameters-of-matching-kind-on-the-right"> 
      <h4><a href="#f-and-derivingtype-have-parameters-of-matching-kind-on-the-right" class="anchor"></a><code>F</code> and <code>DerivingType</code> have parameters of matching kind on the right</h4> 
      <p>This section covers cases where you can pair arguments of <code>F</code> and <code>DerivingType</code> starting from the right such that they have the same kinds pairwise, and all arguments of <code>F</code> or <code>DerivingType</code> (or both) are used up. <code>F</code> must also have at least one parameter.</p> 
      <p>The general shape will then be:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given [...]: TC[ [...] =&gt;&gt; DerivingType[...] ] = TC.derived
</span></code></pre>
      </div> 
      <p>Where of course <code>TC</code> and <code>DerivingType</code> are applied to types of the correct kind.</p> 
      <p>To make this work, we split it into 3 cases:</p> 
      <p>If <code>F</code> and <code>DerivingType</code> take the same number of arguments (<code>N == K</code>):</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given TC[DerivingType] = TC.derived
</span><span id="1" class=""><span class="tooltip-container"></span>// simplified form of:
</span><span id="2" class=""><span class="tooltip-container"></span>given TC[ [A_1, ..., A_K] =&gt; DerivingType[A_1, ..., A_K] ] = TC.derived
</span></code></pre>
      </div> 
      <p>If <code>DerivingType</code> takes less arguments than <code>F</code> (<code>N &lt; K</code>), we use only the rightmost parameters from the type lambda:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given TC[ [A_1, ..., A_K] =&gt;&gt; DerivingType[A_(K-N+1), ..., A_K] ] = TC.derived
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>// if DerivingType takes no arguments (N == 0), the above simplifies to:
</span><span id="3" class=""><span class="tooltip-container"></span>given TC[ [A_1, ..., A_K] =&gt;&gt; DerivingType ] = TC.derived
</span></code></pre>
      </div> 
      <p>If <code>F</code> takes less arguments than <code>DerivingType</code> (<code>K &lt; N</code>), we fill in the remaining leftmost slots with type parameters of the given:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given [T_1, ... T_(N-K)]: TC[[A_1, ..., A_K] =&gt;&gt; DerivingType[T_1, ... T_(N-K), A_1, ..., A_K]] = TC.derived
</span></code></pre>
      </div>
     </section>
     <section id="tc-is-the-canequal-type-class"> 
      <h3><a href="#tc-is-the-canequal-type-class" class="anchor"></a><code>TC</code> is the <code>CanEqual</code> type class</h3> 
      <p>We have therefore: <code>DerivingType[T_1, ..., T_N] derives CanEqual</code>.</p> 
      <p>Let <code>U_1</code>, ..., <code>U_M</code> be the parameters of <code>DerivingType</code> of kind <code>*</code>. (These are a subset of the <code>T_i</code>s)</p> 
      <p>The generated instance is then:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given [T_1L, T_1R, ..., T_NL, T_NR]                            // every parameter of DerivingType twice
</span><span id="1" class=""><span class="tooltip-container"></span>      (using CanEqual[U_1L, U_1R], ..., CanEqual[U_ML, U_MR]): // only parameters of DerivingType with kind *
</span><span id="2" class=""><span class="tooltip-container"></span>        CanEqual[DerivingType[T_1L, ..., T_NL], DerivingType[T_1R, ..., T_NR]] = // again, every parameter
</span><span id="3" class=""><span class="tooltip-container"></span>          CanEqual.derived
</span></code></pre>
      </div> 
      <p>The bounds of <code>T_i</code>s are handled correctly, for example: <code>T_2 &lt;: T_1</code> becomes <code>T_2L &lt;: T_1L</code>.</p> 
      <p>For example, the class</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>class MyClass[A, G[_]](a: A, b: G[B]) derives CanEqual
</span></code></pre>
      </div> 
      <p>generates the following given instance:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>object MyClass:
</span><span id="1" class=""><span class="tooltip-container"></span>  ...
</span><span id="2" class=""><span class="tooltip-container"></span>  given [A_L, A_R, G_L[_], G_R[_]](using CanEqual[A_L, A_R]): CanEqual[MyClass[A_L, G_L], MyClass[A_R, G_R]] = CanEqual.derived
</span></code></pre>
      </div>
     </section>
     <section id="tc-is-not-valid-for-automatic-derivation"> 
      <h3><a href="#tc-is-not-valid-for-automatic-derivation" class="anchor"></a><code>TC</code> is not valid for automatic derivation</h3> 
      <p>Throw an error.</p> 
      <p>The exact error depends on which of the above conditions failed. As an example, if <code>TC</code> takes more than 1 parameter and is not <code>CanEqual</code>, the error is <code>DerivingType cannot be unified with the type argument of TC</code>.</p> 
      <p>All data types can have a <code>derives</code> clause. The rest of this document focuses primarily on data types which also have a given instance of the <code>Mirror</code> type class available.</p> 
     </section>
     <section id="mirror"> 
      <h2><a href="#mirror" class="anchor"></a><code>Mirror</code></h2> 
      <p><code>scala.deriving.Mirror</code> type class instances provide information at the type level about the components and labelling of the type. They also provide minimal term level infrastructure to allow higher level libraries to provide comprehensive derivation support.</p> 
      <p>Instances of the <code>Mirror</code> type class are generated automatically by the compiler unconditionally for:</p> 
      <ul> 
       <li>enums and enum cases,</li> 
       <li>case objects.</li> 
      </ul> 
      <p>Instances for <code>Mirror</code> are also generated conditionally for:</p> 
      <ul> 
       <li>case classes where the constructor is visible at the callsite (always true if the companion is not a case object)</li> 
       <li>sealed classes and sealed traits where: 
        <ul> 
         <li>there exists at least one child case,</li> 
         <li>each child case is reachable from the parent's definition,</li> 
         <li>if the sealed trait/class has no companion, then each child case is reachable from the callsite through the prefix of the type being mirrored,</li> 
         <li>and where the compiler can generate a <code>Mirror</code> type class instance for each child case.</li> 
        </ul> </li> 
      </ul> 
      <p>The <code>scala.deriving.Mirror</code> type class definition is as follows:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>sealed trait Mirror:
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>  /** the type being mirrored */
</span><span id="3" class=""><span class="tooltip-container"></span>  type MirroredType
</span><span id="4" class=""><span class="tooltip-container"></span>
</span><span id="5" class=""><span class="tooltip-container"></span>  /** the type of the elements of the mirrored type */
</span><span id="6" class=""><span class="tooltip-container"></span>  type MirroredElemTypes
</span><span id="7" class=""><span class="tooltip-container"></span>
</span><span id="8" class=""><span class="tooltip-container"></span>  /** The mirrored *-type */
</span><span id="9" class=""><span class="tooltip-container"></span>  type MirroredMonoType
</span><span id="10" class=""><span class="tooltip-container"></span>
</span><span id="11" class=""><span class="tooltip-container"></span>  /** The name of the type */
</span><span id="12" class=""><span class="tooltip-container"></span>  type MirroredLabel &lt;: String
</span><span id="13" class=""><span class="tooltip-container"></span>
</span><span id="14" class=""><span class="tooltip-container"></span>  /** The names of the elements of the type */
</span><span id="15" class=""><span class="tooltip-container"></span>  type MirroredElemLabels &lt;: Tuple
</span><span id="16" class=""><span class="tooltip-container"></span>
</span><span id="17" class=""><span class="tooltip-container"></span>object Mirror:
</span><span id="18" class=""><span class="tooltip-container"></span>
</span><span id="19" class=""><span class="tooltip-container"></span>  /** The Mirror for a product type */
</span><span id="20" class=""><span class="tooltip-container"></span>  trait Product extends Mirror:
</span><span id="21" class=""><span class="tooltip-container"></span>
</span><span id="22" class=""><span class="tooltip-container"></span>    /** Create a new instance of type `T` with elements
</span><span id="23" class=""><span class="tooltip-container"></span>     *  taken from product `p`.
</span><span id="24" class=""><span class="tooltip-container"></span>     */
</span><span id="25" class=""><span class="tooltip-container"></span>    def fromProduct(p: scala.Product): MirroredMonoType
</span><span id="26" class=""><span class="tooltip-container"></span>
</span><span id="27" class=""><span class="tooltip-container"></span>  trait Sum extends Mirror:
</span><span id="28" class=""><span class="tooltip-container"></span>
</span><span id="29" class=""><span class="tooltip-container"></span>    /** The ordinal number of the case class of `x`.
</span><span id="30" class=""><span class="tooltip-container"></span>     *  For enums, `ordinal(x) == x.ordinal`
</span><span id="31" class=""><span class="tooltip-container"></span>     */
</span><span id="32" class=""><span class="tooltip-container"></span>    def ordinal(x: MirroredMonoType): Int
</span><span id="33" class=""><span class="tooltip-container"></span>
</span><span id="34" class=""><span class="tooltip-container"></span>end Mirror
</span></code></pre>
      </div> 
      <p>Product types (i.e. case classes and objects, and enum cases) have mirrors which are subtypes of <code>Mirror.Product</code>. Sum types (i.e. sealed class or traits with product children, and enums) have mirrors which are subtypes of <code>Mirror.Sum</code>.</p> 
      <p>For the <code>Tree</code> ADT from above the following <code>Mirror</code> instances will be automatically provided by the compiler,</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>// Mirror for Tree
</span><span id="1" class=""><span class="tooltip-container"></span>new Mirror.Sum:
</span><span id="2" class=""><span class="tooltip-container"></span>  type MirroredType = Tree
</span><span id="3" class=""><span class="tooltip-container"></span>  type MirroredElemTypes[T] = (Branch[T], Leaf[T])
</span><span id="4" class=""><span class="tooltip-container"></span>  type MirroredMonoType = Tree[_]
</span><span id="5" class=""><span class="tooltip-container"></span>  type MirroredLabel = "Tree"
</span><span id="6" class=""><span class="tooltip-container"></span>  type MirroredElemLabels = ("Branch", "Leaf")
</span><span id="7" class=""><span class="tooltip-container"></span>
</span><span id="8" class=""><span class="tooltip-container"></span>  def ordinal(x: MirroredMonoType): Int = x match
</span><span id="9" class=""><span class="tooltip-container"></span>    case _: Branch[_] =&gt; 0
</span><span id="10" class=""><span class="tooltip-container"></span>    case _: Leaf[_] =&gt; 1
</span><span id="11" class=""><span class="tooltip-container"></span>
</span><span id="12" class=""><span class="tooltip-container"></span>// Mirror for Branch
</span><span id="13" class=""><span class="tooltip-container"></span>new Mirror.Product:
</span><span id="14" class=""><span class="tooltip-container"></span>  type MirroredType = Branch
</span><span id="15" class=""><span class="tooltip-container"></span>  type MirroredElemTypes[T] = (Tree[T], Tree[T])
</span><span id="16" class=""><span class="tooltip-container"></span>  type MirroredMonoType = Branch[_]
</span><span id="17" class=""><span class="tooltip-container"></span>  type MirroredLabel = "Branch"
</span><span id="18" class=""><span class="tooltip-container"></span>  type MirroredElemLabels = ("left", "right")
</span><span id="19" class=""><span class="tooltip-container"></span>
</span><span id="20" class=""><span class="tooltip-container"></span>  def fromProduct(p: Product): MirroredMonoType =
</span><span id="21" class=""><span class="tooltip-container"></span>    new Branch(...)
</span><span id="22" class=""><span class="tooltip-container"></span>
</span><span id="23" class=""><span class="tooltip-container"></span>// Mirror for Leaf
</span><span id="24" class=""><span class="tooltip-container"></span>new Mirror.Product:
</span><span id="25" class=""><span class="tooltip-container"></span>  type MirroredType = Leaf
</span><span id="26" class=""><span class="tooltip-container"></span>  type MirroredElemTypes[T] = Tuple1[T]
</span><span id="27" class=""><span class="tooltip-container"></span>  type MirroredMonoType = Leaf[_]
</span><span id="28" class=""><span class="tooltip-container"></span>  type MirroredLabel = "Leaf"
</span><span id="29" class=""><span class="tooltip-container"></span>  type MirroredElemLabels = Tuple1["elem"]
</span><span id="30" class=""><span class="tooltip-container"></span>
</span><span id="31" class=""><span class="tooltip-container"></span>  def fromProduct(p: Product): MirroredMonoType =
</span><span id="32" class=""><span class="tooltip-container"></span>    new Leaf(...)
</span></code></pre>
      </div> 
      <p>If a Mirror cannot be generated automatically for a given type, an error will appear explaining why it is neither a supported sum type nor a product type. For example, if <code>A</code> is a trait that is not sealed,</p> 
      <div class="snippet"> 
       <pre><code>No given instance of type deriving.Mirror.Of[A] was found for parameter x of method summon in object Predef. Failed to synthesize an instance of type deriving.Mirror.Of[A]:
     * trait A is not a generic product because it is not a case class
     * trait A is not a generic sum because it is not a sealed trait
</code></pre> 
      </div> 
      <p>Note the following properties of <code>Mirror</code> types,</p> 
      <ul> 
       <li>Properties are encoded using types rather than terms. This means that they have no runtime footprint unless used and also that they are a compile time feature for use with Scala 3's metaprogramming facilities.</li> 
       <li>There is no restriction against the mirrored type being a local or inner class.</li> 
       <li>The kinds of <code>MirroredType</code> and <code>MirroredElemTypes</code> match the kind of the data type the mirror is an instance for. This allows <code>Mirror</code>s to support ADTs of all kinds.</li> 
       <li>There is no distinct representation type for sums or products (ie. there is no <code>HList</code> or <code>Coproduct</code> type as in Scala 2 versions of Shapeless). Instead the collection of child types of a data type is represented by an ordinary, possibly parameterized, tuple type. Scala 3's metaprogramming facilities can be used to work with these tuple types as-is, and higher level libraries can be built on top of them.</li> 
       <li>For both product and sum types, the elements of <code>MirroredElemTypes</code> are arranged in definition order (i.e. <code>Branch[T]</code> precedes <code>Leaf[T]</code> in <code>MirroredElemTypes</code> for <code>Tree</code> because <code>Branch</code> is defined before <code>Leaf</code> in the source file). This means that <code>Mirror.Sum</code> differs in this respect from Shapeless's generic representation for ADTs in Scala 2, where the constructors are ordered alphabetically by name.</li> 
       <li>The methods <code>ordinal</code> and <code>fromProduct</code> are defined in terms of <code>MirroredMonoType</code> which is the type of kind-<code>*</code> which is obtained from <code>MirroredType</code> by wildcarding its type parameters.</li> 
      </ul> 
     </section>
     <section id="implementing-derived-with-mirror"> 
      <h3><a href="#implementing-derived-with-mirror" class="anchor"></a>Implementing <code>derived</code> with <code>Mirror</code></h3> 
      <p>As seen before, the signature and implementation of a <code>derived</code> method for a type class <code>TC[_]</code> are arbitrary, but we expect it to typically be of the following form:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>inline def derived[T](using Mirror.Of[T]): TC[T] = ...
</span></code></pre>
      </div> 
      <p>That is, the <code>derived</code> method takes a context parameter of (some subtype of) type <code>Mirror</code> which defines the shape of the deriving type <code>T</code>, and computes the type class implementation according to that shape. This is all that the provider of an ADT with a <code>derives</code> clause has to know about the derivation of a type class instance.</p> 
      <p>Note that <code>derived</code> methods may have context <code>Mirror</code> parameters indirectly (e.g. by having a context argument which in turn has a context <code>Mirror</code> parameter, or not at all (e.g. they might use some completely different user-provided mechanism, for instance using Scala 3 macros or runtime reflection). We expect that (direct or indirect) <code>Mirror</code> based implementations will be the most common and that is what this document emphasises.</p> 
      <p>Type class authors will most likely use higher level derivation or generic programming libraries to implement <code>derived</code> methods. An example of how a <code>derived</code> method might be implemented using <em>only</em> the low level facilities described above and Scala 3's general metaprogramming features is provided below. It is not anticipated that type class authors would normally implement a <code>derived</code> method in this way, however this walkthrough can be taken as a guide for authors of the higher level derivation libraries that we expect typical type class authors will use (for a fully worked out example of such a library, see <a href="https://github.com/milessabin/shapeless/tree/shapeless-3">Shapeless 3</a>).</p> 
     </section>
     <section id="how-to-write-a-type-class-derived-method-using-low-level-mechanisms"> 
      <h4><a href="#how-to-write-a-type-class-derived-method-using-low-level-mechanisms" class="anchor"></a>How to write a type class <code>derived</code> method using low level mechanisms</h4> 
      <p>The low-level method we will use to implement a type class <code>derived</code> method in this example exploits three new type-level constructs in Scala 3: inline methods, inline matches, and implicit searches via <code>summonInline</code> or <code>summonFrom</code>. Given this definition of the <code>Eq</code> type class,</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>trait Eq[T]:
</span><span id="1" class=""><span class="tooltip-container"></span>  def eqv(x: T, y: T): Boolean
</span></code></pre>
      </div> 
      <p>we need to implement a method <code>Eq.derived</code> on the companion object of <code>Eq</code> that produces a given instance for <code>Eq[T]</code> given a <code>Mirror[T]</code>. Here is a possible implementation,</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>import scala.deriving.Mirror
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>inline given derived[T](using m: Mirror.Of[T]): Eq[T] =
</span><span id="3" class=""><span class="tooltip-container"></span>  val elemInstances = summonAll[m.MirroredElemTypes]           // (1)
</span><span id="4" class=""><span class="tooltip-container"></span>  inline m match                                               // (2)
</span><span id="5" class=""><span class="tooltip-container"></span>    case s: Mirror.SumOf[T]     =&gt; eqSum(s, elemInstances)
</span><span id="6" class=""><span class="tooltip-container"></span>    case p: Mirror.ProductOf[T] =&gt; eqProduct(p, elemInstances)
</span></code></pre>
      </div> 
      <p>Note that <code>derived</code> is defined as an <code>inline</code> given. This means that the method will be expanded at call sites (for instance the compiler generated instance definitions in the companion objects of ADTs which have a <code>derived Eq</code> clause), and also that it can be used recursively if necessary, to compute instances for children.</p> 
      <p>The body of this method (1) first materializes the <code>Eq</code> instances for all the child types of type the instance is being derived for. This is either all the branches of a sum type or all the fields of a product type. The implementation of <code>summonAll</code> is <code>inline</code> and uses Scala 3's <code>summonInline</code> construct to collect the instances as a <code>List</code>,</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>inline def summonAll[T &lt;: Tuple]: List[Eq[_]] =
</span><span id="1" class=""><span class="tooltip-container"></span>  inline erasedValue[T] match
</span><span id="2" class=""><span class="tooltip-container"></span>    case _: EmptyTuple =&gt; Nil
</span><span id="3" class=""><span class="tooltip-container"></span>    case _: (t *: ts) =&gt; summonInline[Eq[t]] :: summonAll[ts]
</span></code></pre>
      </div> 
      <p>with the instances for children in hand the <code>derived</code> method uses an <code>inline match</code> to dispatch to methods which can construct instances for either sums or products (2). Note that because <code>derived</code> is <code>inline</code> the match will be resolved at compile-time and only the left-hand side of the matching case will be inlined into the generated code with types refined as revealed by the match.</p> 
      <p>In the sum case, <code>eqSum</code>, we use the runtime <code>ordinal</code> values of the arguments to <code>eqv</code> to first check if the two values are of the same subtype of the ADT (3) and then, if they are, to further test for equality based on the <code>Eq</code> instance for the appropriate ADT subtype using the auxiliary method <code>check</code> (4).</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>import scala.deriving.Mirror
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>def eqSum[T](s: Mirror.SumOf[T], elems: List[Eq[_]]): Eq[T] =
</span><span id="3" class=""><span class="tooltip-container"></span>  new Eq[T]:
</span><span id="4" class=""><span class="tooltip-container"></span>    def eqv(x: T, y: T): Boolean =
</span><span id="5" class=""><span class="tooltip-container"></span>      val ordx = s.ordinal(x)                            // (3)
</span><span id="6" class=""><span class="tooltip-container"></span>      (s.ordinal(y) == ordx) &amp;&amp; check(elems(ordx))(x, y) // (4)
</span></code></pre>
      </div> 
      <p>In the product case, <code>eqProduct</code> we test the runtime values of the arguments to <code>eqv</code> for equality as products based on the <code>Eq</code> instances for the fields of the data type (5),</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>import scala.deriving.Mirror
</span><span id="1" class=""><span class="tooltip-container"></span>
</span><span id="2" class=""><span class="tooltip-container"></span>def eqProduct[T](p: Mirror.ProductOf[T], elems: List[Eq[_]]): Eq[T] =
</span><span id="3" class=""><span class="tooltip-container"></span>  new Eq[T]:
</span><span id="4" class=""><span class="tooltip-container"></span>    def eqv(x: T, y: T): Boolean =
</span><span id="5" class=""><span class="tooltip-container"></span>      iterator(x).zip(iterator(y)).zip(elems.iterator).forall {  // (5)
</span><span id="6" class=""><span class="tooltip-container"></span>        case ((x, y), elem) =&gt; check(elem)(x, y)
</span><span id="7" class=""><span class="tooltip-container"></span>      }
</span></code></pre>
      </div> 
      <p>Pulling this all together we have the following complete implementation,</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>import scala.deriving.*
</span><span id="1" class=""><span class="tooltip-container"></span>import scala.compiletime.{erasedValue, summonInline}
</span><span id="2" class=""><span class="tooltip-container"></span>
</span><span id="3" class=""><span class="tooltip-container"></span>inline def summonAll[T &lt;: Tuple]: List[Eq[_]] =
</span><span id="4" class=""><span class="tooltip-container"></span>  inline erasedValue[T] match
</span><span id="5" class=""><span class="tooltip-container"></span>    case _: EmptyTuple =&gt; Nil
</span><span id="6" class=""><span class="tooltip-container"></span>    case _: (t *: ts) =&gt; summonInline[Eq[t]] :: summonAll[ts]
</span><span id="7" class=""><span class="tooltip-container"></span>
</span><span id="8" class=""><span class="tooltip-container"></span>trait Eq[T]:
</span><span id="9" class=""><span class="tooltip-container"></span>  def eqv(x: T, y: T): Boolean
</span><span id="10" class=""><span class="tooltip-container"></span>
</span><span id="11" class=""><span class="tooltip-container"></span>object Eq:
</span><span id="12" class=""><span class="tooltip-container"></span>  given Eq[Int] with
</span><span id="13" class=""><span class="tooltip-container"></span>    def eqv(x: Int, y: Int) = x == y
</span><span id="14" class=""><span class="tooltip-container"></span>
</span><span id="15" class=""><span class="tooltip-container"></span>  def check(elem: Eq[_])(x: Any, y: Any): Boolean =
</span><span id="16" class=""><span class="tooltip-container"></span>    elem.asInstanceOf[Eq[Any]].eqv(x, y)
</span><span id="17" class=""><span class="tooltip-container"></span>
</span><span id="18" class=""><span class="tooltip-container"></span>  def iterator[T](p: T) = p.asInstanceOf[Product].productIterator
</span><span id="19" class=""><span class="tooltip-container"></span>
</span><span id="20" class=""><span class="tooltip-container"></span>  def eqSum[T](s: Mirror.SumOf[T], elems: =&gt; List[Eq[_]]): Eq[T] =
</span><span id="21" class=""><span class="tooltip-container"></span>    new Eq[T]:
</span><span id="22" class=""><span class="tooltip-container"></span>      def eqv(x: T, y: T): Boolean =
</span><span id="23" class=""><span class="tooltip-container"></span>        val ordx = s.ordinal(x)
</span><span id="24" class=""><span class="tooltip-container"></span>        (s.ordinal(y) == ordx) &amp;&amp; check(elems(ordx))(x, y)
</span><span id="25" class=""><span class="tooltip-container"></span>
</span><span id="26" class=""><span class="tooltip-container"></span>  def eqProduct[T](p: Mirror.ProductOf[T], elems: =&gt; List[Eq[_]]): Eq[T] =
</span><span id="27" class=""><span class="tooltip-container"></span>    new Eq[T]:
</span><span id="28" class=""><span class="tooltip-container"></span>      def eqv(x: T, y: T): Boolean =
</span><span id="29" class=""><span class="tooltip-container"></span>        iterator(x).zip(iterator(y)).zip(elems.iterator).forall {
</span><span id="30" class=""><span class="tooltip-container"></span>          case ((x, y), elem) =&gt; check(elem)(x, y)
</span><span id="31" class=""><span class="tooltip-container"></span>        }
</span><span id="32" class=""><span class="tooltip-container"></span>
</span><span id="33" class=""><span class="tooltip-container"></span>  inline given derived[T](using m: Mirror.Of[T]): Eq[T] =
</span><span id="34" class=""><span class="tooltip-container"></span>    lazy val elemInstances = summonAll[m.MirroredElemTypes]
</span><span id="35" class=""><span class="tooltip-container"></span>    inline m match
</span><span id="36" class=""><span class="tooltip-container"></span>      case s: Mirror.SumOf[T]     =&gt; eqSum(s, elemInstances)
</span><span id="37" class=""><span class="tooltip-container"></span>      case p: Mirror.ProductOf[T] =&gt; eqProduct(p, elemInstances)
</span><span id="38" class=""><span class="tooltip-container"></span>end Eq
</span></code></pre>
      </div> 
      <p>we can test this relative to a simple ADT like so,</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>enum Opt[+T] derives Eq:
</span><span id="1" class=""><span class="tooltip-container"></span>  case Sm(t: T)
</span><span id="2" class=""><span class="tooltip-container"></span>  case Nn
</span><span id="3" class=""><span class="tooltip-container"></span>
</span><span id="4" class=""><span class="tooltip-container"></span>@main def test(): Unit =
</span><span id="5" class=""><span class="tooltip-container"></span>  import Opt.*
</span><span id="6" class=""><span class="tooltip-container"></span>  val eqoi = summon[Eq[Opt[Int]]]
</span><span id="7" class=""><span class="tooltip-container"></span>  assert(eqoi.eqv(Sm(23), Sm(23)))
</span><span id="8" class=""><span class="tooltip-container"></span>  assert(!eqoi.eqv(Sm(23), Sm(13)))
</span><span id="9" class=""><span class="tooltip-container"></span>  assert(!eqoi.eqv(Sm(23), Nn))
</span></code></pre>
      </div> 
      <p>In this case the code that is generated by the inline expansion for the derived <code>Eq</code> instance for <code>Opt</code> looks like the following, after a little polishing,</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given derived$Eq[T](using eqT: Eq[T]): Eq[Opt[T]] =
</span><span id="1" class=""><span class="tooltip-container"></span>  eqSum(
</span><span id="2" class=""><span class="tooltip-container"></span>    summon[Mirror[Opt[T]]],
</span><span id="3" class=""><span class="tooltip-container"></span>    List(
</span><span id="4" class=""><span class="tooltip-container"></span>      eqProduct(summon[Mirror[Sm[T]]], List(summon[Eq[T]])),
</span><span id="5" class=""><span class="tooltip-container"></span>      eqProduct(summon[Mirror[Nn.type]], Nil)
</span><span id="6" class=""><span class="tooltip-container"></span>    )
</span><span id="7" class=""><span class="tooltip-container"></span>  )
</span></code></pre>
      </div> 
      <p>Alternative approaches can be taken to the way that <code>derived</code> methods can be defined. For example, more aggressively inlined variants using Scala 3 macros, whilst being more involved for type class authors to write than the example above, can produce code for type classes like <code>Eq</code> which eliminate all the abstraction artefacts (eg. the <code>Lists</code> of child instances in the above) and generate code which is indistinguishable from what a programmer might write by hand. As a third example, using a higher level library such as Shapeless the type class author could define an equivalent <code>derived</code> method as,</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>given eqSum[A](using inst: =&gt; K0.CoproductInstances[Eq, A]): Eq[A] with
</span><span id="1" class=""><span class="tooltip-container"></span>  def eqv(x: A, y: A): Boolean = inst.fold2(x, y)(false)(
</span><span id="2" class=""><span class="tooltip-container"></span>    [t] =&gt; (eqt: Eq[t], t0: t, t1: t) =&gt; eqt.eqv(t0, t1)
</span><span id="3" class=""><span class="tooltip-container"></span>  )
</span><span id="4" class=""><span class="tooltip-container"></span>
</span><span id="5" class=""><span class="tooltip-container"></span>given eqProduct[A](using inst: K0.ProductInstances[Eq, A]): Eq[A] with
</span><span id="6" class=""><span class="tooltip-container"></span>  def eqv(x: A, y: A): Boolean = inst.foldLeft2(x, y)(true: Boolean)(
</span><span id="7" class=""><span class="tooltip-container"></span>    [t] =&gt; (acc: Boolean, eqt: Eq[t], t0: t, t1: t) =&gt;
</span><span id="8" class=""><span class="tooltip-container"></span>      Complete(!eqt.eqv(t0, t1))(false)(true)
</span><span id="9" class=""><span class="tooltip-container"></span>  )
</span><span id="10" class=""><span class="tooltip-container"></span>
</span><span id="11" class=""><span class="tooltip-container"></span>inline def derived[A](using gen: K0.Generic[A]): Eq[A] =
</span><span id="12" class=""><span class="tooltip-container"></span>  gen.derive(eqProduct, eqSum)
</span></code></pre>
      </div> 
      <p>The framework described here enables all three of these approaches without mandating any of them.</p> 
      <p>For a brief discussion on how to use macros to write a type class <code>derived</code> method please read more at <a href="derivation-macro.html">How to write a type class <code>derived</code> method using macros</a>.</p> 
     </section>
     <section id="syntax"> 
      <h3><a href="#syntax" class="anchor"></a>Syntax</h3> 
      <div class="snippet"> 
       <pre><code>Template          ::=  InheritClauses [TemplateBody]
EnumDef           ::=  id ClassConstr InheritClauses EnumBody
InheritClauses    ::=  [‘extends’ ConstrApps] [‘derives’ QualId {‘,’ QualId}]
ConstrApps        ::=  ConstrApp {‘with’ ConstrApp}
                    |  ConstrApp {‘,’ ConstrApp}
</code></pre> 
      </div> 
      <p><strong>Note:</strong> To align <code>extends</code> clauses and <code>derives</code> clauses, Scala 3 also allows multiple extended types to be separated by commas. So the following is now legal:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>class A extends B, C { ... }
</span></code></pre>
      </div> 
      <p>It is equivalent to the old form</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>class A extends B with C { ... }
</span></code></pre>
      </div>
     </section>
     <section id="discussion"> 
      <h3><a href="#discussion" class="anchor"></a>Discussion</h3> 
      <p>This type class derivation framework is intentionally very small and low-level. There are essentially two pieces of infrastructure in compiler-generated <code>Mirror</code> instances,</p> 
      <ul> 
       <li>type members encoding properties of the mirrored types.</li> 
       <li>a minimal value level mechanism for working generically with terms of the mirrored types.</li> 
      </ul> 
      <p>The <code>Mirror</code> infrastructure can be seen as an extension of the existing <code>Product</code> infrastructure for case classes: typically <code>Mirror</code> types will be implemented by the ADTs companion object, hence the type members and the <code>ordinal</code> or <code>fromProduct</code> methods will be members of that object. The primary motivation for this design decision, and the decision to encode properties via types rather than terms was to keep the bytecode and runtime footprint of the feature small enough to make it possible to provide <code>Mirror</code> instances <em>unconditionally</em>.</p> 
      <p>Whilst <code>Mirrors</code> encode properties precisely via type members, the value level <code>ordinal</code> and <code>fromProduct</code> are somewhat weakly typed (because they are defined in terms of <code>MirroredMonoType</code>) just like the members of <code>Product</code>. This means that code for generic type classes has to ensure that type exploration and value selection proceed in lockstep and it has to assert this conformance in some places using casts. If generic type classes are correctly written these casts will never fail.</p> 
      <p>As mentioned, however, the compiler-provided mechanism is intentionally very low level and it is anticipated that higher level type class derivation and generic programming libraries will build on this and Scala 3's other metaprogramming facilities to hide these low-level details from type class authors and general users. Type class derivation in the style of both Shapeless and Magnolia are possible (a prototype of Shapeless 3, which combines aspects of both Shapeless 2 and Magnolia has been developed alongside this language feature) as is a more aggressively inlined style, supported by Scala 3's new quote/splice macro and inlining facilities.</p> 
     </section> 
    </main> 
    <nav class="arrows-wrapper" aria-label="Page navigation"> <a rel="prev" href="type-classes.html" class="arrows previous" aria-keyshortcuts="Left"> <span>Implementing Type classes</span> <i class="fa fa-angle-left"></i> </a> <a rel="next" href="derivation-macro.html" class="arrows next" aria-keyshortcuts="Right"> <span>How to write a type class `derived` method using macros</span> <i class="fa fa-angle-right"></i> </a> 
    </nav> 
    <div class="content-contributors hidden"> <span><b>Contributors to this page</b></span> 
     <div id="documentation-contributors" class="contributors-container"></div> 
    </div> 
   </div> 
  </div>
 </body>
</html></div></main><footer><div id="generated-by"><span class="footer-text">Generated by</span><a href="https://github.com/lampepfl/dotty/tree/main/scaladoc"><img src="../images/scaladoc_logo.svg" alt="scaladoc" class="scaladoc_logo"></img><img src="../images/scaladoc_logo_dark.svg" alt="scaladoc" class="scaladoc_logo_dark"></img></a></div><span id="footer-text">Copyright (c) 2002-2022, LAMP/EPFL</span><div class="socials"><span class="footer-text">Social links</span><a href="https://github.com/lampepfl/dotty"><span class="social-icon" data-icon-path="github-icon-black.png"></span></a><a href="https://discord.com/invite/scala"><span class="social-icon" data-icon-path="discord-icon-black.png"></span></a><a href="https://twitter.com/scala_lang"><span class="social-icon" data-icon-path="twitter-icon-black.png"></span></a></div><div class="mode"><span class="footer-text">Mode</span><label id="theme-toggle" class="switch"><input type="checkbox"></input><span class="slider"></span></label></div><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span><span class="footer-text">Back to top</span></a></span></footer></div><div id="toc"><span class="toc-title">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><ul><li><a href="#exact-mechanism">Exact mechanism</a><ul><li><a href="#tc-takes-1-parameter-f">TC takes 1 parameter F</a><ul><li><a href="#f-and-all-arguments-of-derivingtype-have-kind-">F and all arguments of DerivingType have kind *</a></li><li><a href="#f-and-derivingtype-have-parameters-of-matching-kind-on-the-right">F and DerivingType have parameters of matching kind on the right</a></li></ul></li><li><a href="#tc-is-the-canequal-type-class">TC is the CanEqual type class</a></li><li><a href="#tc-is-not-valid-for-automatic-derivation">TC is not valid for automatic derivation</a></li></ul></li><li><a href="#mirror">Mirror</a><ul><li><a href="#implementing-derived-with-mirror">Implementing derived with Mirror</a><ul><li><a href="#how-to-write-a-type-class-derived-method-using-low-level-mechanisms">How to write a type class derived method using low level mechanisms</a></li></ul></li><li><a href="#syntax">Syntax</a></li><li><a href="#discussion">Discussion</a></li></ul></li></ul></li></ul></nav></div></div></body></html>