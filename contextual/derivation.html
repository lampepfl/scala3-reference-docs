<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/lampepfl/dotty" data-githubContributorsFilename="docs/_docs/reference/contextual/derivation.md" data-pathToRoot="../"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Type Class Derivation</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><link rel="dns-prefetch" href="//fonts.googleapis.com"> 
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
<link rel="stylesheet" href="/css/dottydoc.css"></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.3.1</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../index.html">Docs</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni n1 "><span class="nh de"><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni n1 "><span class="nh de"><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>Contextual Abstractions</span></a></span><div class="ni n1 "><span class="nh de"><a href="givens.html"><span>Given Instances</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n1 expanded"><span class="nh h100 selected de"><a href="#"><span>Type Class Derivation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/staging.html"><span>Run-Time Multi-Stage Programming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits and Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../experimental/index.html"><span>Experimental</span></a></span><div class="ni n1 "><span class="nh de"><a href="../experimental/canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/cc.html"><span>Capture Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/tupled-function.html"><span>Tupled Function</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2024, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2024, LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Contextual Abstractions</a>/<a href="derivation.html">Type Class Derivation</a></div><div id="content" class="body-medium"><div><div id="content-wrapper"> 
 <div class="site-container"> 
  <div id="site-header"></div> 
  <main> 
   <header> <a class="text-button with-link body-small" href="https://github.com/lampepfl/dotty/edit/language-reference-stable/docs/_docs/reference/contextual/derivation.md">Edit this page on GitHub</a> 
    <h1 class="h600">Type Class Derivation</h1> 
   </header> 
   <p class="body-large first-p">Type class derivation is a way to automatically generate given instances for type classes which satisfy some simple conditions. A type class in this sense is any trait or class with a single type parameter determining the type being operated on, and the special case <code>CanEqual</code>. Common examples are <code>Eq</code>, <code>Ordering</code>, or <code>Show</code>. For example, given the following <code>Tree</code> algebraic data type (ADT):</p> 
   <div class="snippet mono-small-block" scala-snippet=""> 
    <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>enum Tree[T] derives Eq, Ordering, Show:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case Branch(left: Tree[T], right: Tree[T])
</span><span line-number="3" class=""><span class="tooltip-container"></span>  case Leaf(elem: T)
</span></code></pre> 
    <div class="buttons"></div> 
   </div> 
   <p>The <code>derives</code> clause generates the following given instances for the <code>Eq</code>, <code>Ordering</code> and <code>Show</code> type classes in the companion object of <code>Tree</code>:</p> 
   <div class="snippet mono-small-block" scala-snippet=""> 
    <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given [T: Eq]       : Eq[Tree[T]]       = Eq.derived
</span><span line-number="2" class=""><span class="tooltip-container"></span>given [T: Ordering] : Ordering[Tree[T]] = Ordering.derived
</span><span line-number="3" class=""><span class="tooltip-container"></span>given [T: Show]     : Show[Tree[T]]     = Show.derived
</span></code></pre> 
    <div class="buttons"></div> 
   </div> 
   <p>We say that <code>Tree</code> is the <em>deriving type</em> and that the <code>Eq</code>, <code>Ordering</code> and <code>Show</code> instances are <em>derived instances</em>.</p> 
   <p><strong>Note:</strong> <code>derived</code> can be used manually, this is useful when you do not have control over the definition. For example we can implement <code>Ordering</code> for <code>Option</code>s like so:</p> 
   <div class="snippet mono-small-block" scala-snippet=""> 
    <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given [T: Ordering]: Ordering[Option[T]] = Ordering.derived
</span></code></pre> 
    <div class="buttons"></div> 
   </div> 
   <p>It is discouraged to directly refer to the <code>derived</code> member if you can use a <code>derives</code> clause instead.</p> 
   <p>All data types can have a <code>derives</code> clause. This document focuses primarily on data types which also have a given instance of the <code>Mirror</code> type class available.</p> 
   <section id="exact-mechanism-1"> 
    <h2 class="h500"><a href="#exact-mechanism-1" class="anchor"></a>Exact mechanism</h2> 
    <p>In the following, when type arguments are enumerated and the first index evaluates to a larger value than the last, then there are actually no arguments, for example: <code>A[T_2, ..., T_1]</code> means <code>A</code>.</p> 
    <p>For a class/trait/object/enum <code>DerivingType[T_1, ..., T_N] derives TC</code>, a derived instance is created in <code>DerivingType</code>'s companion object (or <code>DerivingType</code> itself if it is an object).</p> 
    <p>The general "shape" of the derived instance is as follows:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given [...](using ...): TC[ ... DerivingType[...] ... ] = TC.derived
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p><code>TC.derived</code> should be an expression that conforms to the expected type on the left, potentially elaborated using term and/or type inference.</p> 
    <p><strong>Note:</strong> <code>TC.derived</code> is a normal access, therefore if there are multiple definitions of <code>TC.derived</code>, overloading resolution applies.</p> 
    <p>What the derived instance precisely looks like depends on the specifics of <code>DerivingType</code> and <code>TC</code>, we first examine <code>TC</code>:</p> 
   </section> 
   <section id="tc-takes-1-parameter-f-1"> 
    <h3 class="h400"><a href="#tc-takes-1-parameter-f-1" class="anchor"></a><code>TC</code> takes 1 parameter <code>F</code></h3> 
    <p>Therefore <code>TC</code> is defined as <code>TC[F[A_1, ..., A_K]]</code> (<code>TC[F]</code> if <code>K == 0</code>) for some <code>F</code>. There are two further cases depending on the kinds of arguments:</p> 
   </section> 
   <section id="f-and-all-arguments-of-derivingtype-have-kind--1"> 
    <h4 class="h300"><a href="#f-and-all-arguments-of-derivingtype-have-kind--1" class="anchor"></a><code>F</code> and all arguments of <code>DerivingType</code> have kind <code>*</code></h4> 
    <p><strong>Note:</strong> <code>K == 0</code> in this case.</p> 
    <p>The generated instance is then:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given [T_1: TC, ..., T_N: TC]: TC[DerivingType[T_1, ..., T_N]] = TC.derived
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>This is the most common case, and is the one that was highlighted in the introduction.</p> 
    <p><strong>Note:</strong> The <code>[T_i: TC, ...]</code> introduces a <code>(using TC[T_i], ...)</code>, more information in <a href="context-bounds.html">Context Bounds</a>. This allows the <code>derived</code> member to access these evidences.</p> 
    <p><strong>Note:</strong> If <code>N == 0</code> the above means:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given TC[DerivingType] = TC.derived
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>For example, the class</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Point(x: Int, y: Int) derives Ordering
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>generates the instance</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>object Point:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>  given Ordering[Point] = Ordering.derived
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="f-and-derivingtype-have-parameters-of-matching-kind-on-the-right-1"> 
    <h4 class="h300"><a href="#f-and-derivingtype-have-parameters-of-matching-kind-on-the-right-1" class="anchor"></a><code>F</code> and <code>DerivingType</code> have parameters of matching kind on the right</h4> 
    <p>This section covers cases where you can pair arguments of <code>F</code> and <code>DerivingType</code> starting from the right such that they have the same kinds pairwise, and all arguments of <code>F</code> or <code>DerivingType</code> (or both) are used up. <code>F</code> must also have at least one parameter.</p> 
    <p>The general shape will then be:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given [...]: TC[ [...] =&gt;&gt; DerivingType[...] ] = TC.derived
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Where of course <code>TC</code> and <code>DerivingType</code> are applied to types of the correct kind.</p> 
    <p>To make this work, we split it into 3 cases:</p> 
    <p>If <code>F</code> and <code>DerivingType</code> take the same number of arguments (<code>N == K</code>):</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given TC[DerivingType] = TC.derived
</span><span line-number="2" class=""><span class="tooltip-container"></span>// simplified form of:
</span><span line-number="3" class=""><span class="tooltip-container"></span>given TC[ [A_1, ..., A_K] =&gt;&gt; DerivingType[A_1, ..., A_K] ] = TC.derived
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>If <code>DerivingType</code> takes fewer arguments than <code>F</code> (<code>N &lt; K</code>), we use only the rightmost parameters from the type lambda:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given TC[ [A_1, ..., A_K] =&gt;&gt; DerivingType[A_(K-N+1), ..., A_K] ] = TC.derived
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>// if DerivingType takes no arguments (N == 0), the above simplifies to:
</span><span line-number="4" class=""><span class="tooltip-container"></span>given TC[ [A_1, ..., A_K] =&gt;&gt; DerivingType ] = TC.derived
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>If <code>F</code> takes fewer arguments than <code>DerivingType</code> (<code>K &lt; N</code>), we fill in the remaining leftmost slots with type parameters of the given:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given [T_1, ... T_(N-K)]: TC[[A_1, ..., A_K] =&gt;&gt; DerivingType[T_1, ... T_(N-K), A_1, ..., A_K]] = TC.derived
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="tc-is-the-canequal-type-class-1"> 
    <h3 class="h400"><a href="#tc-is-the-canequal-type-class-1" class="anchor"></a><code>TC</code> is the <code>CanEqual</code> type class</h3> 
    <p>We have therefore: <code>DerivingType[T_1, ..., T_N] derives CanEqual</code>.</p> 
    <p>Let <code>U_1</code>, ..., <code>U_M</code> be the parameters of <code>DerivingType</code> of kind <code>*</code>. (These are a subset of the <code>T_i</code>s)</p> 
    <p>The generated instance is then:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given [T_1L, T_1R, ..., T_NL, T_NR]                            // every parameter of DerivingType twice
</span><span line-number="2" class=""><span class="tooltip-container"></span>      (using CanEqual[U_1L, U_1R], ..., CanEqual[U_ML, U_MR]): // only parameters of DerivingType with kind *
</span><span line-number="3" class=""><span class="tooltip-container"></span>        CanEqual[DerivingType[T_1L, ..., T_NL], DerivingType[T_1R, ..., T_NR]] = // again, every parameter
</span><span line-number="4" class=""><span class="tooltip-container"></span>          CanEqual.derived
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>The bounds of <code>T_i</code>s are handled correctly, for example: <code>T_2 &lt;: T_1</code> becomes <code>T_2L &lt;: T_1L</code>.</p> 
    <p>For example, the class</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class MyClass[A, G[_]](a: A, b: G[B]) derives CanEqual
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>generates the following given instance:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>object MyClass:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>  given [A_L, A_R, G_L[_], G_R[_]](using CanEqual[A_L, A_R]): CanEqual[MyClass[A_L, G_L], MyClass[A_R, G_R]] = CanEqual.derived
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="tc-is-not-valid-for-automatic-derivation-1"> 
    <h3 class="h400"><a href="#tc-is-not-valid-for-automatic-derivation-1" class="anchor"></a><code>TC</code> is not valid for automatic derivation</h3> 
    <p>Throw an error.</p> 
    <p>The exact error depends on which of the above conditions failed. As an example, if <code>TC</code> takes more than 1 parameter and is not <code>CanEqual</code>, the error is <code>DerivingType cannot be unified with the type argument of TC</code>.</p> 
    <p>All data types can have a <code>derives</code> clause. The rest of this document focuses primarily on data types which also have a given instance of the <code>Mirror</code> type class available.</p> 
   </section> 
   <section id="mirror-1"> 
    <h2 class="h500"><a href="#mirror-1" class="anchor"></a><code>Mirror</code></h2> 
    <p><code>scala.deriving.Mirror</code> type class instances provide information at the type level about the components and labelling of the type. They also provide minimal term-level infrastructure to allow higher-level libraries to provide comprehensive derivation support.</p> 
    <p>Instances of the <code>Mirror</code> type class are generated automatically by the compiler unconditionally for:</p> 
    <ul> 
     <li>enums and enum cases,</li> 
     <li>case objects.</li> 
    </ul> 
    <p>Instances for <code>Mirror</code> are also generated conditionally for:</p> 
    <ul> 
     <li>case classes where the constructor is visible at the callsite (always true if the companion is not a case object)</li> 
     <li>sealed classes and sealed traits where: 
      <ul> 
       <li>there exists at least one child case,</li> 
       <li>each child case is reachable from the parent's definition,</li> 
       <li>if the sealed trait/class has no companion, then each child case is reachable from the callsite through the prefix of the type being mirrored,</li> 
       <li>and where the compiler can generate a <code>Mirror</code> type class instance for each child case.</li> 
      </ul> </li> 
    </ul> 
    <p>The <code>scala.deriving.Mirror</code> type class definition is as follows:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>sealed trait Mirror:
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  /** the type being mirrored */
</span><span line-number="4" class=""><span class="tooltip-container"></span>  type MirroredType
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  /** the type of the elements of the mirrored type */
</span><span line-number="7" class=""><span class="tooltip-container"></span>  type MirroredElemTypes
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>  /** The mirrored *-type */
</span><span line-number="10" class=""><span class="tooltip-container"></span>  type MirroredMonoType
</span><span line-number="11" class=""><span class="tooltip-container"></span>
</span><span line-number="12" class=""><span class="tooltip-container"></span>  /** The name of the type */
</span><span line-number="13" class=""><span class="tooltip-container"></span>  type MirroredLabel &lt;: String
</span><span line-number="14" class=""><span class="tooltip-container"></span>
</span><span line-number="15" class=""><span class="tooltip-container"></span>  /** The names of the elements of the type */
</span><span line-number="16" class=""><span class="tooltip-container"></span>  type MirroredElemLabels &lt;: Tuple
</span><span line-number="17" class=""><span class="tooltip-container"></span>
</span><span line-number="18" class=""><span class="tooltip-container"></span>object Mirror:
</span><span line-number="19" class=""><span class="tooltip-container"></span>
</span><span line-number="20" class=""><span class="tooltip-container"></span>  /** The Mirror for a product type */
</span><span line-number="21" class=""><span class="tooltip-container"></span>  trait Product extends Mirror:
</span><span line-number="22" class=""><span class="tooltip-container"></span>
</span><span line-number="23" class=""><span class="tooltip-container"></span>    /** Create a new instance of type `T` with elements
</span><span line-number="24" class=""><span class="tooltip-container"></span>     *  taken from product `p`.
</span><span line-number="25" class=""><span class="tooltip-container"></span>     */
</span><span line-number="26" class=""><span class="tooltip-container"></span>    def fromProduct(p: scala.Product): MirroredMonoType
</span><span line-number="27" class=""><span class="tooltip-container"></span>
</span><span line-number="28" class=""><span class="tooltip-container"></span>  trait Sum extends Mirror:
</span><span line-number="29" class=""><span class="tooltip-container"></span>
</span><span line-number="30" class=""><span class="tooltip-container"></span>    /** The ordinal number of the case class of `x`.
</span><span line-number="31" class=""><span class="tooltip-container"></span>     *  For enums, `ordinal(x) == x.ordinal`
</span><span line-number="32" class=""><span class="tooltip-container"></span>     */
</span><span line-number="33" class=""><span class="tooltip-container"></span>    def ordinal(x: MirroredMonoType): Int
</span><span line-number="34" class=""><span class="tooltip-container"></span>
</span><span line-number="35" class=""><span class="tooltip-container"></span>end Mirror
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Product types (i.e. case classes and objects, and enum cases) have mirrors which are subtypes of <code>Mirror.Product</code>. Sum types (i.e. sealed class or traits with product children, and enums) have mirrors which are subtypes of <code>Mirror.Sum</code>.</p> 
    <p>For the <code>Tree</code> ADT from above the following <code>Mirror</code> instances will be automatically provided by the compiler,</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// Mirror for Tree
</span><span line-number="2" class=""><span class="tooltip-container"></span>new Mirror.Sum:
</span><span line-number="3" class=""><span class="tooltip-container"></span>  type MirroredType = Tree
</span><span line-number="4" class=""><span class="tooltip-container"></span>  type MirroredElemTypes[T] = (Branch[T], Leaf[T])
</span><span line-number="5" class=""><span class="tooltip-container"></span>  type MirroredMonoType = Tree[_]
</span><span line-number="6" class=""><span class="tooltip-container"></span>  type MirroredLabel = "Tree"
</span><span line-number="7" class=""><span class="tooltip-container"></span>  type MirroredElemLabels = ("Branch", "Leaf")
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>  def ordinal(x: MirroredMonoType): Int = x match
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case _: Branch[_] =&gt; 0
</span><span line-number="11" class=""><span class="tooltip-container"></span>    case _: Leaf[_] =&gt; 1
</span><span line-number="12" class=""><span class="tooltip-container"></span>
</span><span line-number="13" class=""><span class="tooltip-container"></span>// Mirror for Branch
</span><span line-number="14" class=""><span class="tooltip-container"></span>new Mirror.Product:
</span><span line-number="15" class=""><span class="tooltip-container"></span>  type MirroredType = Branch
</span><span line-number="16" class=""><span class="tooltip-container"></span>  type MirroredElemTypes[T] = (Tree[T], Tree[T])
</span><span line-number="17" class=""><span class="tooltip-container"></span>  type MirroredMonoType = Branch[_]
</span><span line-number="18" class=""><span class="tooltip-container"></span>  type MirroredLabel = "Branch"
</span><span line-number="19" class=""><span class="tooltip-container"></span>  type MirroredElemLabels = ("left", "right")
</span><span line-number="20" class=""><span class="tooltip-container"></span>
</span><span line-number="21" class=""><span class="tooltip-container"></span>  def fromProduct(p: Product): MirroredMonoType =
</span><span line-number="22" class=""><span class="tooltip-container"></span>    new Branch(...)
</span><span line-number="23" class=""><span class="tooltip-container"></span>
</span><span line-number="24" class=""><span class="tooltip-container"></span>// Mirror for Leaf
</span><span line-number="25" class=""><span class="tooltip-container"></span>new Mirror.Product:
</span><span line-number="26" class=""><span class="tooltip-container"></span>  type MirroredType = Leaf
</span><span line-number="27" class=""><span class="tooltip-container"></span>  type MirroredElemTypes[T] = Tuple1[T]
</span><span line-number="28" class=""><span class="tooltip-container"></span>  type MirroredMonoType = Leaf[_]
</span><span line-number="29" class=""><span class="tooltip-container"></span>  type MirroredLabel = "Leaf"
</span><span line-number="30" class=""><span class="tooltip-container"></span>  type MirroredElemLabels = Tuple1["elem"]
</span><span line-number="31" class=""><span class="tooltip-container"></span>
</span><span line-number="32" class=""><span class="tooltip-container"></span>  def fromProduct(p: Product): MirroredMonoType =
</span><span line-number="33" class=""><span class="tooltip-container"></span>    new Leaf(...)
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>If a Mirror cannot be generated automatically for a given type, an error will appear explaining why it is neither a supported sum type nor a product type. For example, if <code>A</code> is a trait that is not sealed,</p> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>No given instance of type deriving.Mirror.Of[A] was found for parameter x of method summon in object Predef. Failed to synthesize an instance of type deriving.Mirror.Of[A]:
</span><span line-number="2" class=""><span class="tooltip-container"></span>     * trait A is not a generic product because it is not a case class
</span><span line-number="3" class=""><span class="tooltip-container"></span>     * trait A is not a generic sum because it is not a sealed trait
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Note the following properties of <code>Mirror</code> types,</p> 
    <ul> 
     <li>Properties are encoded using types rather than terms. This means that they have no runtime footprint unless used and also that they are a compile-time feature for use with Scala 3's metaprogramming facilities.</li> 
     <li>There is no restriction against the mirrored type being a local or inner class.</li> 
     <li>The kinds of <code>MirroredType</code> and <code>MirroredElemTypes</code> match the kind of the data type the mirror is an instance for. This allows <code>Mirror</code>s to support ADTs of all kinds.</li> 
     <li>There is no distinct representation type for sums or products (ie. there is no <code>HList</code> or <code>Coproduct</code> type as in Scala 2 versions of Shapeless). Instead the collection of child types of a data type is represented by an ordinary, possibly parameterized, tuple type. Scala 3's metaprogramming facilities can be used to work with these tuple types as-is, and higher-level libraries can be built on top of them.</li> 
     <li>For both product and sum types, the elements of <code>MirroredElemTypes</code> are arranged in definition order (i.e. <code>Branch[T]</code> precedes <code>Leaf[T]</code> in <code>MirroredElemTypes</code> for <code>Tree</code> because <code>Branch</code> is defined before <code>Leaf</code> in the source file). This means that <code>Mirror.Sum</code> differs in this respect from Shapeless's generic representation for ADTs in Scala 2, where the constructors are ordered alphabetically by name.</li> 
     <li>The methods <code>ordinal</code> and <code>fromProduct</code> are defined in terms of <code>MirroredMonoType</code> which is the type of kind-<code>*</code> which is obtained from <code>MirroredType</code> by wildcarding its type parameters.</li> 
    </ul> 
   </section> 
   <section id="implementing-derived-with-mirror-1"> 
    <h2 class="h500"><a href="#implementing-derived-with-mirror-1" class="anchor"></a>Implementing <code>derived</code> with <code>Mirror</code></h2> 
    <p>As seen before, the signature and implementation of a <code>derived</code> method for a type class <code>TC[_]</code> are arbitrary, but we expect it to typically be of the following form:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.deriving.Mirror
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>inline def derived[T](using Mirror.Of[T]): TC[T] = ...
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>That is, the <code>derived</code> method takes a context parameter of (some subtype of) type <code>Mirror</code> which defines the shape of the deriving type <code>T</code>, and computes the type class implementation according to that shape. This is all that the provider of an ADT with a <code>derives</code> clause has to know about the derivation of a type class instance.</p> 
    <p>Note that <code>derived</code> methods may have context <code>Mirror</code> parameters indirectly (e.g. by having a context argument which in turn has a context <code>Mirror</code> parameter, or not at all (e.g. they might use some completely different user-provided mechanism, for instance using Scala 3 macros or runtime reflection). We expect that (direct or indirect) <code>Mirror</code> based implementations will be the most common and that is what this document emphasises.</p> 
    <p>Type class authors will most likely use higher-level derivation or generic programming libraries to implement <code>derived</code> methods. An example of how a <code>derived</code> method might be implemented using <em>only</em> the low-level facilities described above and Scala 3's general metaprogramming features is provided below. It is not anticipated that type class authors would normally implement a <code>derived</code> method in this way, however this walkthrough can be taken as a guide for authors of the higher-level derivation libraries that we expect typical type class authors will use (for a fully worked out example of such a library, see <a href="https://github.com/milessabin/shapeless/tree/shapeless-3">Shapeless 3</a>).</p> 
   </section> 
   <section id="how-to-write-a-type-class-derived-method-using-low-level-mechanisms-1"> 
    <h2 class="h500"><a href="#how-to-write-a-type-class-derived-method-using-low-level-mechanisms-1" class="anchor"></a>How to write a type class <code>derived</code> method using low-level mechanisms</h2> 
    <p>The low-level technique we will use to implement a type class <code>derived</code> method in this example exploits three new type-level constructs in Scala 3: inline methods, inline matches, and implicit searches via <code>summonInline</code> or <code>summonFrom</code>. Given this definition of the <code>Eq</code> type class,</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait Eq[T]:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def eqv(x: T, y: T): Boolean
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>we need to implement a method <code>Eq.derived</code> on the companion object of <code>Eq</code> that produces a given instance for <code>Eq[T]</code> given a <code>Mirror[T]</code>. Here is a possible implementation,</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.deriving.Mirror
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>inline def derived[T](using m: Mirror.Of[T]): Eq[T] =
</span><span line-number="4" class=""><span class="tooltip-container"></span>  lazy val elemInstances = summonInstances[T, m.MirroredElemTypes] // (1)
</span><span line-number="5" class=""><span class="tooltip-container"></span>  inline m match                                                   // (2)
</span><span line-number="6" class=""><span class="tooltip-container"></span>    case s: Mirror.SumOf[T]     =&gt; eqSum(s, elemInstances)
</span><span line-number="7" class=""><span class="tooltip-container"></span>    case p: Mirror.ProductOf[T] =&gt; eqProduct(p, elemInstances)
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Note that <code>derived</code> is defined as an <code>inline def</code>. This means that the method will be inlined at all call sites (for instance the compiler-generated instance definitions in the companion objects of ADTs which have a <code>deriving Eq</code> clause).</p> 
    <blockquote> 
     <p>Inlining of complex code is potentially expensive if overused (meaning slower compile times) so we should be careful to limit how many times <code>derived</code> is called for the same type. For example, when computing an instance for a sum type, it may be necessary to call <code>derived</code> recursively to compute an instance for each one of its child cases. That child case may in turn be a product type, that declares a field referring back to the parent sum type. To compute the instance for this field, we should not call <code>derived</code> recursively, but instead summon from the context. Typically, the found given instance will be the root given instance that initially called <code>derived</code>.</p> 
    </blockquote> 
    <p>The body of <code>derived</code> (1) first materializes the <code>Eq</code> instances for all the child types of type the instance is being derived for. This is either all the branches of a sum type or all the fields of a product type. The implementation of <code>summonInstances</code> is <code>inline</code> and uses Scala 3's <code>summonInline</code> construct to collect the instances as a <code>List</code>,</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>inline def summonInstances[T, Elems &lt;: Tuple]: List[Eq[?]] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  inline erasedValue[Elems] match
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case _: (elem *: elems) =&gt; deriveOrSummon[T, elem] :: summonInstances[T, elems]
</span><span line-number="4" class=""><span class="tooltip-container"></span>    case _: EmptyTuple =&gt; Nil
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>inline def deriveOrSummon[T, Elem]: Eq[Elem] =
</span><span line-number="7" class=""><span class="tooltip-container"></span>  inline erasedValue[Elem] match
</span><span line-number="8" class=""><span class="tooltip-container"></span>    case _: T =&gt; deriveRec[T, Elem]
</span><span line-number="9" class=""><span class="tooltip-container"></span>    case _    =&gt; summonInline[Eq[Elem]]
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>inline def deriveRec[T, Elem]: Eq[Elem] =
</span><span line-number="12" class=""><span class="tooltip-container"></span>  inline erasedValue[T] match
</span><span line-number="13" class=""><span class="tooltip-container"></span>    case _: Elem =&gt; error("infinite recursive derivation")
</span><span line-number="14" class=""><span class="tooltip-container"></span>    case _       =&gt; Eq.derived[Elem](using summonInline[Mirror.Of[Elem]]) // recursive derivation
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>with the instances for children in hand the <code>derived</code> method uses an <code>inline match</code> to dispatch to methods which can construct instances for either sums or products (2). Note that because <code>derived</code> is <code>inline</code> the match will be resolved at compile-time and only the right-hand side of the matching case will be inlined into the generated code with types refined as revealed by the match.</p> 
    <p>In the sum case, <code>eqSum</code>, we use the runtime <code>ordinal</code> values of the arguments to <code>eqv</code> to first check if the two values are of the same subtype of the ADT (3) and then, if they are, to further test for equality based on the <code>Eq</code> instance for the appropriate ADT subtype using the auxiliary method <code>check</code> (4).</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.deriving.Mirror
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>def eqSum[T](s: Mirror.SumOf[T], elems: =&gt; List[Eq[?]]): Eq[T] =
</span><span line-number="4" class=""><span class="tooltip-container"></span>  new Eq[T]:
</span><span line-number="5" class=""><span class="tooltip-container"></span>    def eqv(x: T, y: T): Boolean =
</span><span line-number="6" class=""><span class="tooltip-container"></span>      val ordx = s.ordinal(x)                            // (3)
</span><span line-number="7" class=""><span class="tooltip-container"></span>      (s.ordinal(y) == ordx) &amp;&amp; check(x, y, elems(ordx)) // (4)
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>In the product case, <code>eqProduct</code>, we test the runtime values of the arguments to <code>eqv</code> for equality as products based on the <code>Eq</code> instances for the fields of the data type (5),</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.deriving.Mirror
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>def eqProduct[T](p: Mirror.ProductOf[T], elems: =&gt; List[Eq[?]]): Eq[T] =
</span><span line-number="4" class=""><span class="tooltip-container"></span>  new Eq[T]:
</span><span line-number="5" class=""><span class="tooltip-container"></span>    def eqv(x: T, y: T): Boolean =
</span><span line-number="6" class=""><span class="tooltip-container"></span>      iterable(x).lazyZip(iterable(y)).lazyZip(elems).forall(check)
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>Both <code>eqSum</code> and <code>eqProduct</code> have a by-name parameter <code>elems</code>, because the argument passed is the reference to the lazy <code>elemInstances</code> value.</p> 
    <p>Pulling this all together we have the following complete implementation,</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>import scala.deriving.*
</span><span line-number="2" class=""><span class="tooltip-container"></span>import scala.compiletime.{error, erasedValue, summonInline}
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>inline def summonInstances[T, Elems &lt;: Tuple]: List[Eq[?]] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>  inline erasedValue[Elems] match
</span><span line-number="6" class=""><span class="tooltip-container"></span>    case _: (elem *: elems) =&gt; deriveOrSummon[T, elem] :: summonInstances[T, elems]
</span><span line-number="7" class=""><span class="tooltip-container"></span>    case _: EmptyTuple =&gt; Nil
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>inline def deriveOrSummon[T, Elem]: Eq[Elem] =
</span><span line-number="10" class=""><span class="tooltip-container"></span>  inline erasedValue[Elem] match
</span><span line-number="11" class=""><span class="tooltip-container"></span>    case _: T =&gt; deriveRec[T, Elem]
</span><span line-number="12" class=""><span class="tooltip-container"></span>    case _    =&gt; summonInline[Eq[Elem]]
</span><span line-number="13" class=""><span class="tooltip-container"></span>
</span><span line-number="14" class=""><span class="tooltip-container"></span>inline def deriveRec[T, Elem]: Eq[Elem] =
</span><span line-number="15" class=""><span class="tooltip-container"></span>  inline erasedValue[T] match
</span><span line-number="16" class=""><span class="tooltip-container"></span>    case _: Elem =&gt; error("infinite recursive derivation")
</span><span line-number="17" class=""><span class="tooltip-container"></span>    case _       =&gt; Eq.derived[Elem](using summonInline[Mirror.Of[Elem]]) // recursive derivation
</span><span line-number="18" class=""><span class="tooltip-container"></span>
</span><span line-number="19" class=""><span class="tooltip-container"></span>trait Eq[T]:
</span><span line-number="20" class=""><span class="tooltip-container"></span>  def eqv(x: T, y: T): Boolean
</span><span line-number="21" class=""><span class="tooltip-container"></span>
</span><span line-number="22" class=""><span class="tooltip-container"></span>object Eq:
</span><span line-number="23" class=""><span class="tooltip-container"></span>  given Eq[Int] with
</span><span line-number="24" class=""><span class="tooltip-container"></span>    def eqv(x: Int, y: Int) = x == y
</span><span line-number="25" class=""><span class="tooltip-container"></span>
</span><span line-number="26" class=""><span class="tooltip-container"></span>  def check(x: Any, y: Any, elem: Eq[?]): Boolean =
</span><span line-number="27" class=""><span class="tooltip-container"></span>    elem.asInstanceOf[Eq[Any]].eqv(x, y)
</span><span line-number="28" class=""><span class="tooltip-container"></span>
</span><span line-number="29" class=""><span class="tooltip-container"></span>  def iterable[T](p: T): Iterable[Any] = new AbstractIterable[Any]:
</span><span line-number="30" class=""><span class="tooltip-container"></span>    def iterator: Iterator[Any] = p.asInstanceOf[Product].productIterator
</span><span line-number="31" class=""><span class="tooltip-container"></span>
</span><span line-number="32" class=""><span class="tooltip-container"></span>  def eqSum[T](s: Mirror.SumOf[T], elems: =&gt; List[Eq[?]]): Eq[T] =
</span><span line-number="33" class=""><span class="tooltip-container"></span>    new Eq[T]:
</span><span line-number="34" class=""><span class="tooltip-container"></span>      def eqv(x: T, y: T): Boolean =
</span><span line-number="35" class=""><span class="tooltip-container"></span>        val ordx = s.ordinal(x)
</span><span line-number="36" class=""><span class="tooltip-container"></span>        (s.ordinal(y) == ordx) &amp;&amp; check(x, y, elems(ordx))
</span><span line-number="37" class=""><span class="tooltip-container"></span>
</span><span line-number="38" class=""><span class="tooltip-container"></span>  def eqProduct[T](p: Mirror.ProductOf[T], elems: =&gt; List[Eq[?]]): Eq[T] =
</span><span line-number="39" class=""><span class="tooltip-container"></span>    new Eq[T]:
</span><span line-number="40" class=""><span class="tooltip-container"></span>      def eqv(x: T, y: T): Boolean =
</span><span line-number="41" class=""><span class="tooltip-container"></span>        iterable(x).lazyZip(iterable(y)).lazyZip(elems).forall(check)
</span><span line-number="42" class=""><span class="tooltip-container"></span>
</span><span line-number="43" class=""><span class="tooltip-container"></span>  inline def derived[T](using m: Mirror.Of[T]): Eq[T] =
</span><span line-number="44" class=""><span class="tooltip-container"></span>    lazy val elemInstances = summonInstances[T, m.MirroredElemTypes]
</span><span line-number="45" class=""><span class="tooltip-container"></span>    inline m match
</span><span line-number="46" class=""><span class="tooltip-container"></span>      case s: Mirror.SumOf[T]     =&gt; eqSum(s, elemInstances)
</span><span line-number="47" class=""><span class="tooltip-container"></span>      case p: Mirror.ProductOf[T] =&gt; eqProduct(p, elemInstances)
</span><span line-number="48" class=""><span class="tooltip-container"></span>end Eq
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>we can test this relative to a simple ADT like so,</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>enum Lst[+T] derives Eq:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case Cns(t: T, ts: Lst[T])
</span><span line-number="3" class=""><span class="tooltip-container"></span>  case Nl
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>extension [T](t: T) def ::(ts: Lst[T]): Lst[T] = Lst.Cns(t, ts)
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>@main def test(): Unit =
</span><span line-number="8" class=""><span class="tooltip-container"></span>  import Lst.*
</span><span line-number="9" class=""><span class="tooltip-container"></span>  val eqoi = summon[Eq[Lst[Int]]]
</span><span line-number="10" class=""><span class="tooltip-container"></span>  assert(eqoi.eqv(23 :: 47 :: Nl, 23 :: 47 :: Nl))
</span><span line-number="11" class=""><span class="tooltip-container"></span>  assert(!eqoi.eqv(23 :: Nl, 7 :: Nl))
</span><span line-number="12" class=""><span class="tooltip-container"></span>  assert(!eqoi.eqv(23 :: Nl, Nl))
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>In this case the code that is generated by the inline expansion for the derived <code>Eq</code> instance for <code>Lst</code> looks like the following, after a little polishing,</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given derived$Eq[T](using eqT: Eq[T]): Eq[Lst[T]] =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  eqSum(summon[Mirror.Of[Lst[T]]], {/* cached lazily */
</span><span line-number="3" class=""><span class="tooltip-container"></span>    List(
</span><span line-number="4" class=""><span class="tooltip-container"></span>      eqProduct(summon[Mirror.Of[Cns[T]]], {/* cached lazily */
</span><span line-number="5" class=""><span class="tooltip-container"></span>        List(summon[Eq[T]], summon[Eq[Lst[T]]])
</span><span line-number="6" class=""><span class="tooltip-container"></span>      }),
</span><span line-number="7" class=""><span class="tooltip-container"></span>      eqProduct(summon[Mirror.Of[Nl.type]], {/* cached lazily */
</span><span line-number="8" class=""><span class="tooltip-container"></span>        Nil
</span><span line-number="9" class=""><span class="tooltip-container"></span>      })
</span><span line-number="10" class=""><span class="tooltip-container"></span>    )
</span><span line-number="11" class=""><span class="tooltip-container"></span>  })
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>The <code>lazy</code> modifier on <code>elemInstances</code> is necessary for preventing infinite recursion in the derived instance for recursive types such as <code>Lst</code>.</p> 
    <p>Alternative approaches can be taken to the way that <code>derived</code> methods can be defined. For example, more aggressively inlined variants using Scala 3 macros, whilst being more involved for type class authors to write than the example above, can produce code for type classes like <code>Eq</code> which eliminate all the abstraction artefacts (eg. the <code>Lists</code> of child instances in the above) and generate code which is indistinguishable from what a programmer might write by hand. As a third example, using a higher-level library such as Shapeless, the type class author could define an equivalent <code>derived</code> method as,</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>given eqSum[A](using inst: =&gt; K0.CoproductInstances[Eq, A]): Eq[A] with
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def eqv(x: A, y: A): Boolean = inst.fold2(x, y)(false)(
</span><span line-number="3" class=""><span class="tooltip-container"></span>    [t] =&gt; (eqt: Eq[t], t0: t, t1: t) =&gt; eqt.eqv(t0, t1)
</span><span line-number="4" class=""><span class="tooltip-container"></span>  )
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>given eqProduct[A](using inst: =&gt; K0.ProductInstances[Eq, A]): Eq[A] with
</span><span line-number="7" class=""><span class="tooltip-container"></span>  def eqv(x: A, y: A): Boolean = inst.foldLeft2(x, y)(true: Boolean)(
</span><span line-number="8" class=""><span class="tooltip-container"></span>    [t] =&gt; (acc: Boolean, eqt: Eq[t], t0: t, t1: t) =&gt;
</span><span line-number="9" class=""><span class="tooltip-container"></span>      Complete(!eqt.eqv(t0, t1))(false)(true)
</span><span line-number="10" class=""><span class="tooltip-container"></span>  )
</span><span line-number="11" class=""><span class="tooltip-container"></span>
</span><span line-number="12" class=""><span class="tooltip-container"></span>inline def derived[A](using gen: K0.Generic[A]): Eq[A] =
</span><span line-number="13" class=""><span class="tooltip-container"></span>  gen.derive(eqProduct, eqSum)
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>The framework described here enables all three of these approaches without mandating any of them.</p> 
    <p>For a brief discussion on how to use macros to write a type class <code>derived</code> method, please read more at <a href="derivation-macro.html">How to write a type class <code>derived</code> method using macros</a>.</p> 
   </section> 
   <section id="syntax-29"> 
    <h2 class="h500"><a href="#syntax-29" class="anchor"></a>Syntax</h2> 
    <div class="snippet mono-small-block"> 
     <pre><code class="language-ebnf"><span line-number="1" class=""><span class="tooltip-container"></span>Template          ::=  InheritClauses [TemplateBody]
</span><span line-number="2" class=""><span class="tooltip-container"></span>EnumDef           ::=  id ClassConstr InheritClauses EnumBody
</span><span line-number="3" class=""><span class="tooltip-container"></span>InheritClauses    ::=  [‘extends’ ConstrApps] [‘derives’ QualId {‘,’ QualId}]
</span><span line-number="4" class=""><span class="tooltip-container"></span>ConstrApps        ::=  ConstrApp {‘with’ ConstrApp}
</span><span line-number="5" class=""><span class="tooltip-container"></span>                    |  ConstrApp {‘,’ ConstrApp}
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p><strong>Note:</strong> To align <code>extends</code> clauses and <code>derives</code> clauses, Scala 3 also allows multiple extended types to be separated by commas. So the following is now legal:</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class A extends B, C { ... }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
    <p>It is equivalent to the old form</p> 
    <div class="snippet mono-small-block" scala-snippet=""> 
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class A extends B with C { ... }
</span></code></pre> 
     <div class="buttons"></div> 
    </div> 
   </section> 
   <section id="discussion-1"> 
    <h2 class="h500"><a href="#discussion-1" class="anchor"></a>Discussion</h2> 
    <p>This type class derivation framework is intentionally very small and low-level. There are essentially two pieces of infrastructure in compiler-generated <code>Mirror</code> instances,</p> 
    <ul> 
     <li>type members encoding properties of the mirrored types.</li> 
     <li>a minimal value-level mechanism for working generically with terms of the mirrored types.</li> 
    </ul> 
    <p>The <code>Mirror</code> infrastructure can be seen as an extension of the existing <code>Product</code> infrastructure for case classes: typically, <code>Mirror</code> types will be implemented by the ADTs companion object, hence the type members and the <code>ordinal</code> or <code>fromProduct</code> methods will be members of that object. The primary motivation for this design decision, and the decision to encode properties via types rather than terms was to keep the bytecode and runtime footprint of the feature small enough to make it possible to provide <code>Mirror</code> instances <em>unconditionally</em>.</p> 
    <p>Whilst <code>Mirrors</code> encode properties precisely via type members, the value-level <code>ordinal</code> and <code>fromProduct</code> are somewhat weakly typed (because they are defined in terms of <code>MirroredMonoType</code>) just like the members of <code>Product</code>. This means that code for generic type classes has to ensure that type exploration and value selection proceed in lockstep and it has to assert this conformance in some places using casts. If generic type classes are correctly written these casts will never fail.</p> 
    <p>As mentioned, however, the compiler-provided mechanism is intentionally very low-level and it is anticipated that higher-level type class derivation and generic programming libraries will build on this and Scala 3's other metaprogramming facilities to hide these low-level details from type class authors and general users. Type class derivation in the style of both Shapeless and Magnolia are possible (a prototype of Shapeless 3, which combines aspects of both Shapeless 2 and Magnolia has been developed alongside this language feature) as is a more aggressively inlined style, supported by Scala 3's new quote/splice macro and inlining facilities.</p> 
   </section> 
  </main> 
  <div class="divider"></div> 
  <nav class="arrow-navigation" aria-label="Page navigation"> 
   <div> <span class="body-small">Previous</span> <a rel="prev" href="type-classes.html" aria-keyshortcuts="Left" class="body-medium"> <span class="body-medium">Implementing Type classes</span> </a> 
   </div> 
   <div> <span class="body-small">Next</span> <a rel="next" href="derivation-macro.html" aria-keyshortcuts="Right" class="body-medium"> <span class="body-medium">How to write a type class `derived` method using macros</span> </a> 
   </div> 
  </nav> 
 </div> 
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#exact-mechanism-1">Exact mechanism</a><ul><li><a href="#tc-takes-1-parameter-f-1">TC takes 1 parameter F</a><ul><li><a href="#f-and-all-arguments-of-derivingtype-have-kind--1">F and all arguments of DerivingType have kind *</a></li><li><a href="#f-and-derivingtype-have-parameters-of-matching-kind-on-the-right-1">F and DerivingType have parameters of matching kind on the right</a></li></ul></li><li><a href="#tc-is-the-canequal-type-class-1">TC is the CanEqual type class</a></li><li><a href="#tc-is-not-valid-for-automatic-derivation-1">TC is not valid for automatic derivation</a></li></ul></li><li><a href="#mirror-1">Mirror</a></li><li><a href="#implementing-derived-with-mirror-1">Implementing derived with Mirror</a></li><li><a href="#how-to-write-a-type-class-derived-method-using-low-level-mechanisms-1">How to write a type class derived method using low-level mechanisms</a></li><li><a href="#syntax-29">Syntax</a></li><li><a href="#discussion-1">Discussion</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://gitter.im/scala/scala"><button class="icon-button gitter"></button></a><div class="text">Copyright (c) 2002-2024, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2024, LAMP/EPFL</div></div></div></div></body></html>