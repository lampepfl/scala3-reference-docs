<html><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><title>Match Types</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><link rel="stylesheet" href="../css/bootstrap.min.css"></link><link rel="stylesheet" href="../css/dottydoc.css"></link><link rel="stylesheet" href="../css/color-brewer.css"></link><script type="text/javascript" src="../js/jquery.min.js" defer="true"></script><script type="text/javascript" src="../js/bootstrap.min.js" defer="true"></script><link rel="stylesheet" href="../css/content-contributors.css"></link><script type="text/javascript" src="../js/contributors.js" defer="true"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/scalastyle.css"></link><link rel="stylesheet" href="../styles/colors.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/diagram.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/ux.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.min.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><script>var pathToRoot = "../";</script><script>var githubContributorsUrl = "https://api.github.com/repos/lampepfl/dotty";</script><script>var githubContributorsFilename = "docs/_docs/reference/new-types/match-types.md";</script></head><body><div id="container"><div id="leftColumn"><div id="logo"><span><img src="../project-logo/logo.svg"></img></span><span><div class="projectName">Scala 3 Reference</div></span><div id="version"><div class="versions-dropdown"><div onclick="dropdownHandler()" id="dropdown-button" class="dropdownbtn dropdownbtnactive"><div class="projectVersion">3.1.2</div><div id="dropdown-content" class="dropdown-content"><input type="text" placeholder="Search..." id="dropdown-input" onkeyup="filterFunction()"></input></div></div></div></div><div class="socials"><a href="https://github.com/lampepfl/dotty"><span class="social-icon" data-icon-path="github-icon-white.png"></span></a><a href="https://discord.com/invite/scala"><span class="social-icon" data-icon-path="discord-icon-white.png"></span></a><a href="https://twitter.com/scala_lang"><span class="social-icon" data-icon-path="twitter-icon-white.png"></span></a></div></div><div id="paneSearch"></div><nav id="sideMenu2"><div class="ni expanded"><span class="nh expanded"><span class="ar"></span><a href="../index.html"><span>Scala 3 Reference</span></a></span><div class="ni expanded"><span class="nh expanded"><span class="ar"></span><a href="index.html"><span>New Types</span></a></span><div class="ni "><span class="nh "><a href="intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni "><span class="nh "><a href="union-types.html"><span>Union Types</span></a></span></div><div class="ni "><span class="nh "><a href="type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni expanded"><span class="nh selected"><a href="match-types.html"><span>Match Types</span></a></span></div><div class="ni "><span class="nh "><a href="dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni "><span class="nh "><a href="polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni "><span class="nh "><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni "><span class="nh "><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni "><span class="nh "><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni "><span class="nh "><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni "><span class="nh "><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni "><span class="nh "><a href="../metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/staging.html"><span>Runtime Multi-Stage Programming</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni "><span class="nh "><a href="../metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../other-new-features/index.html"><span>Other New Features</span></a></span><div class="ni "><span class="nh "><a href="../other-new-features/trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/transparent-traits.html"><span>Transparent Traits</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/export.html"><span>Export Clauses</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/open-classes.html"><span>Open Classes</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/indentation.html"><span>Optional Braces</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/type-test.html"><span>TypeTest</span></a></span></div><div class="ni "><span class="nh "><a href="../other-new-features/experimental-defs.html"><span>Experimental Definitions</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni "><span class="nh "><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/type-checking.html"><span>Changes in Type Checking</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni "><span class="nh "><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni "><span class="nh "><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/package-objects.html"><span>Dropped: Package Objects</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni "><span class="nh "><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../experimental/index.html"><span>Experimental</span></a></span><div class="ni "><span class="nh "><a href="../experimental/fewer-braces.html"><span>Fewer Braces</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/cc.html"><span>Capture Checking</span></a></span></div><div class="ni "><span class="nh "><a href="../experimental/tupled-function.html"><span>Tupled Function</span></a></span></div></div><div class="ni "><span class="nh "><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni"><span class="nh "><span class="ar"></span><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni "><span class="nh "><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni "><span class="nh "><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni "><span class="nh "><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni "><span class="nh "><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></div></nav></div><div id="main"><div id="leftToggler"><span class="icon-toggler"></span></div><div id="scaladoc-searchBar"></div><main id="main-content"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">New Types</a>/<a href="match-types.html">Match Types</a></div><div id="content"><html>
 <head>
  <link rel="dns-prefetch" href="//fonts.googleapis.com"> 
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin> 
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css"> 
 </head>
 <body>
  <div id="content-wrapper"> 
   <div class="container"> 
    <div id="site-header"> 
     <div class="wrap"> 
      <nav class="navigation" role="menu"> 
       <ul class="navigation-menu"> 
        <li class="navigation-menu-item"> <a href="https://docs.scala-lang.org/" class="active">Learn</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/download/">Install</a> </li> 
        <li class="navigation-menu-item"> <a href="https://scastie.scala-lang.org">Playground</a> </li> 
        <li class="navigation-menu-item"> <a href="https://index.scala-lang.org">Find A Library</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/community/">Community</a> </li> 
        <li class="navigation-menu-item"> <a href="https://www.scala-lang.org/blog/">Blog</a> </li> 
       </ul> 
      </nav> 
     </div> 
    </div> 
    <main> 
     <header> 
      <h1>Match Types</h1> 
      <div class="byline"> <a href="https://github.com/lampepfl/dotty/edit/language-reference-stable/docs/_docs/reference/new-types/match-types.md"> <i class="far fa-edit"></i> Edit this page on GitHub </a> 
      </div> 
     </header> 
     <p>A match type reduces to one of its right-hand sides, depending on the type of its scrutinee. For example:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>type Elem[X] = X match
</span><span id="1" class=""><span class="tooltip-container"></span>  case String =&gt; Char
</span><span id="2" class=""><span class="tooltip-container"></span>  case Array[t] =&gt; t
</span><span id="3" class=""><span class="tooltip-container"></span>  case Iterable[t] =&gt; t
</span></code></pre>
     </div> 
     <p>This defines a type that reduces as follows:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>Elem[String]       =:=  Char
</span><span id="1" class=""><span class="tooltip-container"></span>Elem[Array[Int]]   =:=  Int
</span><span id="2" class=""><span class="tooltip-container"></span>Elem[List[Float]]  =:=  Float
</span><span id="3" class=""><span class="tooltip-container"></span>Elem[Nil.type]     =:=  Nothing
</span></code></pre>
     </div> 
     <p>Here <code>=:=</code> is understood to mean that left and right-hand sides are mutually subtypes of each other.</p> 
     <p>In general, a match type is of the form</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>S match { P1 =&gt; T1 ... Pn =&gt; Tn }
</span></code></pre>
     </div> 
     <p>where <code>S</code>, <code>T1</code>, ..., <code>Tn</code> are types and <code>P1</code>, ..., <code>Pn</code> are type patterns. Type variables in patterns start with a lower case letter, as usual.</p> 
     <p>Match types can form part of recursive type definitions. Example:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>type LeafElem[X] = X match
</span><span id="1" class=""><span class="tooltip-container"></span>  case String =&gt; Char
</span><span id="2" class=""><span class="tooltip-container"></span>  case Array[t] =&gt; LeafElem[t]
</span><span id="3" class=""><span class="tooltip-container"></span>  case Iterable[t] =&gt; LeafElem[t]
</span><span id="4" class=""><span class="tooltip-container"></span>  case AnyVal =&gt; X
</span></code></pre>
     </div> 
     <p>Recursive match type definitions can also be given an upper bound, like this:</p> 
     <div class="snippet" scala-snippet="">
      <div class="buttons"></div>
      <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>type Concat[Xs &lt;: Tuple, +Ys &lt;: Tuple] &lt;: Tuple = Xs match
</span><span id="1" class=""><span class="tooltip-container"></span>  case EmptyTuple =&gt; Ys
</span><span id="2" class=""><span class="tooltip-container"></span>  case x *: xs =&gt; x *: Concat[xs, Ys]
</span></code></pre>
     </div> 
     <p>In this definition, every instance of <code>Concat[A, B]</code>, whether reducible or not, is known to be a subtype of <code>Tuple</code>. This is necessary to make the recursive invocation <code>x *: Concat[xs, Ys]</code> type check, since <code>*:</code> demands a <code>Tuple</code> as its right operand.</p> 
     <section id="dependent-typing"> 
      <h2><a href="#dependent-typing" class="anchor"></a>Dependent Typing</h2> 
      <p>Match types can be used to define dependently typed methods. For instance, here is the value level counterpart to the <code>LeafElem</code> type defined above (note the use of the match type as the return type):</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>def leafElem[X](x: X): LeafElem[X] = x match
</span><span id="1" class=""><span class="tooltip-container"></span>  case x: String      =&gt; x.charAt(0)
</span><span id="2" class=""><span class="tooltip-container"></span>  case x: Array[t]    =&gt; leafElem(x(0))
</span><span id="3" class=""><span class="tooltip-container"></span>  case x: Iterable[t] =&gt; leafElem(x.head)
</span><span id="4" class=""><span class="tooltip-container"></span>  case x: AnyVal      =&gt; x
</span></code></pre>
      </div> 
      <p>This special mode of typing for match expressions is only used when the following conditions are met:</p> 
      <ol> 
       <li>The match expression patterns do not have guards</li> 
       <li>The match expression scrutinee's type is a subtype of the match type scrutinee's type</li> 
       <li>The match expression and the match type have the same number of cases</li> 
       <li>The match expression patterns are all <a href="https://scala-lang.org/files/archive/spec/2.13/08-pattern-matching.html#typed-patterns">Typed Patterns</a>, and these types are <code>=:=</code> to their corresponding type patterns in the match type</li> 
      </ol> 
     </section>
     <section id="representation-of-match-types"> 
      <h2><a href="#representation-of-match-types" class="anchor"></a>Representation of Match Types</h2> 
      <p>The internal representation of a match type</p> 
      <div class="snippet"> 
       <pre><code>S match { P1 =&gt; T1 ... Pn =&gt; Tn }
</code></pre> 
      </div> 
      <p>is <code>Match(S, C1, ..., Cn) &lt;: B</code> where each case <code>Ci</code> is of the form</p> 
      <div class="snippet"> 
       <pre><code>[Xs] =&gt;&gt; P =&gt; T
</code></pre> 
      </div> 
      <p>Here, <code>[Xs]</code> is a type parameter clause of the variables bound in pattern <code>Pi</code>. If there are no bound type variables in a case, the type parameter clause is omitted and only the function type <code>P =&gt; T</code> is kept. So each case is either a unary function type or a type lambda over a unary function type.</p> 
      <p><code>B</code> is the declared upper bound of the match type, or <code>Any</code> if no such bound is given. We will leave it out in places where it does not matter for the discussion. The scrutinee, bound, and pattern types must all be first-order types.</p> 
     </section>
     <section id="match-type-reduction"> 
      <h2><a href="#match-type-reduction" class="anchor"></a>Match Type Reduction</h2> 
      <p>Match type reduction follows the semantics of match expressions, that is, a match type of the form <code>S match { P1 =&gt; T1 ... Pn =&gt; Tn }</code> reduces to <code>Ti</code> if and only if <code>s: S match { _: P1 =&gt; T1 ... _: Pn =&gt; Tn }</code> evaluates to a value of type <code>Ti</code> for all <code>s: S</code>.</p> 
      <p>The compiler implements the following reduction algorithm:</p> 
      <ul> 
       <li>If the scrutinee type <code>S</code> is an empty set of values (such as <code>Nothing</code> or <code>String &amp; Int</code>), do not reduce.</li> 
       <li>Sequentially consider each pattern <code>Pi</code> 
        <ul> 
         <li>If <code>S &lt;: Pi</code> reduce to <code>Ti</code>.</li> 
         <li>Otherwise, try constructing a proof that <code>S</code> and <code>Pi</code> are disjoint, or, in other words, that no value <code>s</code> of type <code>S</code> is also of type <code>Pi</code>.</li> 
         <li>If such proof is found, proceed to the next case (<code>Pi+1</code>), otherwise, do not reduce.</li> 
        </ul> </li> 
      </ul> 
      <p>Disjointness proofs rely on the following properties of Scala types:</p> 
      <ol> 
       <li>Single inheritance of classes</li> 
       <li>Final classes cannot be extended</li> 
       <li>Constant types with distinct values are nonintersecting</li> 
       <li>Singleton paths to distinct values are nonintersecting, such as <code>object</code> definitions or singleton enum cases.</li> 
      </ol> 
      <p>Type parameters in patterns are minimally instantiated when computing <code>S &lt;: Pi</code>. An instantiation <code>Is</code> is <em>minimal</em> for <code>Xs</code> if all type variables in <code>Xs</code> that appear covariantly and nonvariantly in <code>Is</code> are as small as possible and all type variables in <code>Xs</code> that appear contravariantly in <code>Is</code> are as large as possible. Here, "small" and "large" are understood with respect to <code>&lt;:</code>.</p> 
      <p>For simplicity, we have omitted constraint handling so far. The full formulation of subtyping tests describes them as a function from a constraint and a pair of types to either <em>success</em> and a new constraint or <em>failure</em>. In the context of reduction, the subtyping test <code>S &lt;: [Xs := Is] P</code> is understood to leave the bounds of all variables in the input constraint unchanged, i.e. existing variables in the constraint cannot be instantiated by matching the scrutinee against the patterns.</p> 
     </section>
     <section id="subtyping-rules-for-match-types"> 
      <h2><a href="#subtyping-rules-for-match-types" class="anchor"></a>Subtyping Rules for Match Types</h2> 
      <p>The following rules apply to match types. For simplicity, we omit environments and constraints.</p> 
      <ol> 
       <li> <p>The first rule is a structural comparison between two match types:</p> 
        <div class="snippet"> 
         <pre><code>S match { P1 =&gt; T1 ... Pm =&gt; Tm }  &lt;:  T match { Q1 =&gt; U1 ... Qn =&gt; Un }
</code></pre> 
        </div> <p>if</p> 
        <div class="snippet"> 
         <pre><code>S =:= T,  m &gt;= n,  Pi =:= Qi and Ti &lt;: Ui for i in 1..n
</code></pre> 
        </div> <p>I.e. scrutinees and patterns must be equal and the corresponding bodies must be subtypes. No case re-ordering is allowed, but the subtype can have more cases than the supertype.</p> </li> 
       <li> <p>The second rule states that a match type and its redux are mutual subtypes.</p> 
        <div class="snippet"> 
         <pre><code>S match { P1 =&gt; T1 ... Pn =&gt; Tn }  &lt;:  U
U  &lt;:  S match { P1 =&gt; T1 ... Pn =&gt; Tn }
</code></pre> 
        </div> <p>if</p> <p><code>S match { P1 =&gt; T1 ... Pn =&gt; Tn }</code> reduces to <code>U</code></p> </li> 
       <li> <p>The third rule states that a match type conforms to its upper bound:</p> 
        <div class="snippet"> 
         <pre><code>(S match { P1 =&gt; T1 ... Pn =&gt; Tn } &lt;: B)  &lt;:  B
</code></pre> 
        </div> </li> 
      </ol> 
     </section>
     <section id="termination"> 
      <h2><a href="#termination" class="anchor"></a>Termination</h2> 
      <p>Match type definitions can be recursive, which means that it's possible to run into an infinite loop while reducing match types.</p> 
      <p>Since reduction is linked to subtyping, we already have a cycle detection mechanism in place. As a result, the following will already give a reasonable error message:</p> 
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>type L[X] = X match
</span><span id="1" class=""><span class="tooltip-container"></span>  case Int =&gt; L[X]
</span><span id="2" class=""><span class="tooltip-container"></span>
</span><span id="3" class=""><span class="tooltip-container"></span>def g[X]: L[X] = ???
</span></code></pre>
      </div>
      <div class="snippet" scala-snippet="">
       <div class="buttons"></div>
       <pre><code class="language-scala"><span id="0" class=""><span class="tooltip-container"></span>|  val x: Int = g[Int]
</span><span id="1" class=""><span class="tooltip-container"></span>   |                ^
</span><span id="2" class=""><span class="tooltip-container"></span>   |Recursion limit exceeded.
</span><span id="3" class=""><span class="tooltip-container"></span>   |Maybe there is an illegal cyclic reference?
</span><span id="4" class=""><span class="tooltip-container"></span>   |If that's not the case, you could also try to
</span><span id="5" class=""><span class="tooltip-container"></span>   |increase the stacksize using the -Xss JVM option.
</span><span id="6" class=""><span class="tooltip-container"></span>   |A recurring operation is (inner to outer):
</span><span id="7" class=""><span class="tooltip-container"></span>   |
</span><span id="8" class=""><span class="tooltip-container"></span>   |  subtype LazyRef(Test.L[Int]) &lt;:&lt; Int
</span></code></pre>
      </div> 
      <p>Internally, the Scala compiler detects these cycles by turning selected stack overflows into type errors. If there is a stack overflow during subtyping, the exception will be caught and turned into a compile-time error that indicates a trace of the subtype tests that caused the overflow without showing a full stack trace.</p> 
     </section>
     <section id="match-types-variance"> 
      <h2><a href="#match-types-variance" class="anchor"></a>Match Types Variance</h2> 
      <p>All type positions in a match type (scrutinee, patterns, bodies) are considered invariant.</p> 
     </section>
     <section id="related-work"> 
      <h2><a href="#related-work" class="anchor"></a>Related Work</h2> 
      <p>Match types have similarities with <a href="https://wiki.haskell.org/GHC/Type_families">closed type families</a> in Haskell. Some differences are:</p> 
      <ul> 
       <li>Subtyping instead of type equalities.</li> 
       <li>Match type reduction does not tighten the underlying constraint, whereas type family reduction does unify. This difference in approach mirrors the difference between local type inference in Scala and global type inference in Haskell.</li> 
      </ul> 
      <p>Match types are also similar to Typescript's <a href="https://github.com/Microsoft/TypeScript/pull/21316">conditional types</a>. The main differences here are:</p> 
      <ul> 
       <li>Conditional types only reduce if both the scrutinee and pattern are ground, whereas match types also work for type parameters and abstract types.</li> 
       <li>Match types support direct recursion.</li> 
       <li>Conditional types distribute through union types.</li> 
      </ul> 
     </section> 
    </main> 
    <nav class="arrows-wrapper" aria-label="Page navigation"> <a rel="prev" href="type-lambdas-spec.html" class="arrows previous" aria-keyshortcuts="Left"> <span>Type Lambdas - More Details</span> <i class="fa fa-angle-left"></i> </a> <a rel="next" href="dependent-function-types.html" class="arrows next" aria-keyshortcuts="Right"> <span>Dependent Function Types</span> <i class="fa fa-angle-right"></i> </a> 
    </nav> 
    <div class="content-contributors hidden"> <span><b>Contributors to this page</b></span> 
     <div id="documentation-contributors" class="contributors-container"></div> 
    </div> 
   </div> 
  </div>
 </body>
</html></div></main><footer><div id="generated-by"><span class="footer-text">Generated by</span><a href="https://github.com/lampepfl/dotty/tree/main/scaladoc"><img src="../images/scaladoc_logo.svg" alt="scaladoc" class="scaladoc_logo"></img><img src="../images/scaladoc_logo_dark.svg" alt="scaladoc" class="scaladoc_logo_dark"></img></a></div><span id="footer-text">Copyright (c) 2002-2022, LAMP/EPFL</span><div class="socials"><span class="footer-text">Social links</span><a href="https://github.com/lampepfl/dotty"><span class="social-icon" data-icon-path="github-icon-black.png"></span></a><a href="https://discord.com/invite/scala"><span class="social-icon" data-icon-path="discord-icon-black.png"></span></a><a href="https://twitter.com/scala_lang"><span class="social-icon" data-icon-path="twitter-icon-black.png"></span></a></div><div class="mode"><span class="footer-text">Mode</span><label id="theme-toggle" class="switch"><input type="checkbox"></input><span class="slider"></span></label></div><span class="go-to-top-icon"><a href="#container"><span class="icon-vertical_align_top"></span><span class="footer-text">Back to top</span></a></span></footer></div><div id="toc"><span class="toc-title">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><ul><li><a href="#dependent-typing">Dependent Typing</a></li><li><a href="#representation-of-match-types">Representation of Match Types</a></li><li><a href="#match-type-reduction">Match Type Reduction</a></li><li><a href="#subtyping-rules-for-match-types">Subtyping Rules for Match Types</a></li><li><a href="#termination">Termination</a></li><li><a href="#match-types-variance">Match Types Variance</a></li><li><a href="#related-work">Related Work</a></li></ul></li></ul></nav></div></div></body></html>