<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/scala/scala3" data-githubContributorsFilename="docs/_docs/reference/other-new-features/indentation.md" data-pathToRoot="../" data-rawLocation="other-new-features/indentation" data-dynamicSideMenu="false"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Optional Braces</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="/css/dottydoc.css"></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.7.2</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../index.html">Docs</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni n1 "><span class="nh de"><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni n1 "><span class="nh de"><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/deferred-givens.html"><span>Deferred Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/more-givens.html"><span>Other Forms Of Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/staging.html"><span>Run-Time Multi-Stage Programming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>Other New Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="transparent-traits.html"><span>Transparent Traits and Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="export.html"><span>Export Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="named-tuples.html"><span>Named Tuples</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n1 expanded"><span class="nh h100 selected de"><a href="#"><span>Optional Braces</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="type-test.html"><span>TypeTest</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="experimental-defs.html"><span>Experimental Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="preview-defs.html"><span>Preview Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="binary-literals.html"><span>Binary Integer Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="toplevel-definitions.html"><span>Toplevel Definitions</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../preview/index.html"><span>Preview</span></a></span><div class="ni n1 "><span class="nh de"><a href="../preview/better-fors.html"><span>Better fors</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../experimental/index.html"><span>Experimental</span></a></span><div class="ni n1 "><span class="nh de"><a href="../experimental/canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/into.html"><span>The `into` Type and Modifier</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/cc.html"><span>Capture Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/purefuns.html"><span>Pure Function Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/tupled-function.html"><span>Tupled Function</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/modularity.html"><span>Modularity Improvements</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/typeclasses.html"><span>Better Support for Type Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/runtimeChecked.html"><span>The runtimeChecked method</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/unrolled-defs.html"><span>Automatic Parameter Unrolling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/package-object-values.html"><span>Reference-able Package Objects</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/quoted-patterns-with-polymorphic-functions.html"><span>Quoted Patterns with Polymorphic Functions</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Other New Features</a>/<a href="indentation.html">Optional Braces</a></div><div id="content" class="body-medium"><div><div id="content-wrapper">
 <div class="site-container">
  <div id="site-header"></div>
  <main>
   <header>
    <a class="text-button with-link body-small" href="https://github.com/scala/scala3/edit/language-reference-stable/docs/_docs/reference/other-new-features/indentation.md">Edit this page on GitHub</a>
    <h1 class="h600">Optional Braces</h1>
   </header>
   <p class="body-large first-p">Scala 3 enforces some rules on indentation and allows some occurrences of braces <code>{...}</code> to be optional:</p>
   <ul>
    <li>First, some badly indented programs are flagged with warnings.</li>
    <li>Second, some occurrences of braces <code>{...}</code> are made optional. Generally, the rule is that adding a pair of optional braces will not change the meaning of a well-indented program.</li>
   </ul>
   <p>These changes can be turned off with the compiler flag <code>-no-indent</code>.</p>
   <section id="indentation-rules">
    <h2 class="h500"><a href="#indentation-rules" class="anchor"></a>Indentation Rules</h2>
    <p>The compiler enforces two rules for well-indented programs, flagging violations as warnings.</p>
    <ol>
     <li>
      <p>In a brace-delimited region, no statement is allowed to start to the left of the first statement after the opening brace that starts a new line.</p>
      <p>This rule is helpful for finding missing closing braces. It prevents errors like:</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>if (x &lt; 0) {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  println(1)
</span><span line-number="3" class=""><span class="tooltip-container"></span>  println(2)
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>println("done")  // error: indented too far to the left
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
     <li>
      <p>If significant indentation is turned off (i.e. under Scala 2 mode or under <code>-no-indent</code>) and we are at the start of an indented sub-part of an expression, and the indented part ends in a newline, the next statement must start at an indentation width less than the sub-part. This prevents errors where an opening brace was forgotten, as in</p>
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>if (x &lt; 0)
</span><span line-number="2" class=""><span class="tooltip-container"></span>  println(1)
</span><span line-number="3" class=""><span class="tooltip-container"></span>  println(2)   // error: missing `{`
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
    </ol>
    <p>These rules still leave a lot of leeway how programs should be indented. For instance, they do not impose any restrictions on indentation within expressions, nor do they require that all statements of an indentation block line up exactly.</p>
    <p>The rules are generally helpful in pinpointing the root cause of errors related to missing opening or closing braces. These errors are often quite hard to diagnose, in particular in large programs.</p>
   </section>
   <section id="optional-braces">
    <h2 class="h500"><a href="#optional-braces" class="anchor"></a>Optional Braces</h2>
    <p>The compiler will insert <code>&lt;indent&gt;</code> or <code>&lt;outdent&gt;</code> tokens at certain line breaks. Grammatically, pairs of <code>&lt;indent&gt;</code> and <code>&lt;outdent&gt;</code> tokens have the same effect as pairs of braces <code>{</code> and <code>}</code>.</p>
    <p>The algorithm makes use of a stack <code>IW</code> of previously encountered indentation widths. The stack initially holds a single element with a zero indentation width. The <em>current indentation width</em> is the indentation width of the top of the stack.</p>
    <p>There are two rules:</p>
    <ol>
     <li>
      <p>An <code>&lt;indent&gt;</code> is inserted at a line break, if</p>
      <ul>
       <li>An indentation region can start at the current position in the source, and</li>
       <li>the first token on the next line has an indentation width strictly greater than the current indentation width</li>
      </ul>
      <p>An indentation region can start</p>
      <ul>
       <li>
        <p>after the leading parameters of an <code>extension</code>, or</p></li>
       <li>
        <p>after a <code>with</code> in a given instance, or</p></li>
       <li>
        <p>after a <code>:</code> at the start of a template body (see discussion of <code>&lt;colon&gt;</code> below), or</p></li>
       <li>
        <p>after one of the following tokens:</p>
        <div class="snippet mono-small-block">
         <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>=  =&gt;  ?=&gt;  &lt;-  catch  do  else  finally  for
</span><span line-number="2" class=""><span class="tooltip-container"></span>if  match  return  then  throw  try  while  yield
</span></code></pre>
         <div class="buttons"></div>
        </div></li>
       <li>
        <p>after the closing <code>)</code> of a condition in an old-style <code>if</code> or <code>while</code>.</p></li>
       <li>
        <p>after the closing <code>)</code> or <code>}</code> of the enumerations of an old-style <code>for</code> loop without a <code>do</code>.</p></li>
      </ul>
      <p>If an <code>&lt;indent&gt;</code> is inserted, the indentation width of the token on the next line is pushed onto <code>IW</code>, which makes it the new current indentation width.</p></li>
     <li>
      <p>An <code>&lt;outdent&gt;</code> is inserted at a line break, if</p>
      <ul>
       <li>the first token on the next line has an indentation width strictly less than the current indentation width, and</li>
       <li>the last token on the previous line is not one of the following tokens which indicate that the previous statement continues: 
        <div class="snippet mono-small-block">
         <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>then  else  do  catch  finally  yield  match
</span></code></pre>
         <div class="buttons"></div>
        </div></li>
       <li>if the first token on the next line is a <a href="../changed-features/operators.html">leading infix operator</a>. then its indentation width is less then the current indentation width, and it either matches a previous indentation width or is also less than the enclosing indentation width.</li>
      </ul>
      <p>If an <code>&lt;outdent&gt;</code> is inserted, the top element is popped from <code>IW</code>. If the indentation width of the token on the next line is still less than the new current indentation width, step (2) repeats. Therefore, several <code>&lt;outdent&gt;</code> tokens may be inserted in a row.</p>
      <p>The following two additional rules support parsing of legacy code with ad-hoc layout. They might be withdrawn in future language versions:</p>
      <ul>
       <li>
        <p>An <code>&lt;outdent&gt;</code> is also inserted if the next token following a statement sequence starting with an <code>&lt;indent&gt;</code> closes an indentation region, i.e. is one of <code>then</code>, <code>else</code>, <code>do</code>, <code>catch</code>, <code>finally</code>, <code>yield</code>, <code>}</code>, <code>)</code>, <code>]</code> or <code>case</code>.</p></li>
       <li>
        <p>An <code>&lt;outdent&gt;</code> is finally inserted in front of a comma that follows a statement sequence starting with an <code>&lt;indent&gt;</code> if the indented region is itself enclosed in parentheses.</p></li>
      </ul></li>
    </ol>
    <p>It is generally an error if the indentation width of the token following an <code>&lt;outdent&gt;</code> does not match the indentation of some previous line in the enclosing indentation region. For instance, the following would be rejected.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>if x &lt; 0 then
</span><span line-number="2" class=""><span class="tooltip-container"></span>    -x
</span><span line-number="3" class=""><span class="tooltip-container"></span>  else   // error: `else` does not align correctly
</span><span line-number="4" class=""><span class="tooltip-container"></span>    x
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>However, there is one exception to this rule: If the next line starts with a '<code>.</code>' <em>and</em> the indentation width is different from the indentation widths of the two neighboring regions by more than a single space, the line accepted. For instance, the following is OK:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>xs.map: x =&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>    x + 1
</span><span line-number="3" class=""><span class="tooltip-container"></span>  .filter: x =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>    x &gt; 0
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Here, the line starting with <code>.filter</code> does not have an indentation level matching a previous line, but it is still accepted since it starts with a '<code>.</code>' and differs in at least two spaces from the indentation levels of both the region that is closed and the next outer region.</p>
    <p>Indentation tokens are only inserted in regions where newline statement separators are also inferred: at the top-level, inside braces <code>{...}</code>, but not inside parentheses <code>(...)</code>, patterns or types.</p>
    <p><strong>Note:</strong> The rules for leading infix operators above are there to make sure that</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>one
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable">  </span>+ two.match
</span><span line-number="3" class=""><span class="tooltip-container"></span><span class="hideable">  </span>    case 1 =&gt; b
</span><span line-number="4" class=""><span class="tooltip-container"></span><span class="hideable">  </span>    case 2 =&gt; c
</span><span line-number="5" class=""><span class="tooltip-container"></span><span class="hideable">  </span>+ three
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>is parsed as <code>one + (two.match ...) + three</code>. Also, that</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>if x then
</span><span line-number="2" class=""><span class="tooltip-container"></span>    a
</span><span line-number="3" class=""><span class="tooltip-container"></span>  + b
</span><span line-number="4" class=""><span class="tooltip-container"></span>  + c
</span><span line-number="5" class=""><span class="tooltip-container"></span>else d
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>is parsed as <code>if x then a + b + c else d</code>.</p>
   </section>
   <section id="optional-braces-around-template-bodies">
    <h2 class="h500"><a href="#optional-braces-around-template-bodies" class="anchor"></a>Optional Braces Around Template Bodies</h2>
    <p>The Scala grammar uses the term <em>template body</em> for the definitions of a class, trait, or object that are normally enclosed in braces. The braces around a template body can also be omitted by means of the following rule.</p>
    <p>A template body can alternatively consist of a colon followed by one or more indented statements. To this purpose we introduce a new <code>&lt;colon&gt;</code> token that reads as the standard colon "<code>:</code>" but is generated instead of it where <code>&lt;colon&gt;</code> is legal according to the context free syntax, but only if the previous token is an alphanumeric identifier, a backticked identifier, or one of the tokens <code>this</code>, <code>super</code>, "<code>)</code>", and "<code>]</code>".</p>
    <p>An indentation region can start after a <code>&lt;colon&gt;</code>. A template body may be either enclosed in braces, or it may start with <code>&lt;colon&gt; &lt;indent&gt;</code> and end with <code>&lt;outdent&gt;</code>. Analogous rules apply for enum bodies, type refinements, and local packages containing nested definitions.</p>
    <p>With these new rules, the following constructs are all valid:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait A:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  def f: Int
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>class C(x: Int) extends A:
</span><span line-number="5" class=""><span class="tooltip-container"></span>  def f = x
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>object O:
</span><span line-number="8" class=""><span class="tooltip-container"></span>  def f = 3
</span><span line-number="9" class=""><span class="tooltip-container"></span>
</span><span line-number="10" class=""><span class="tooltip-container"></span>enum Color:
</span><span line-number="11" class=""><span class="tooltip-container"></span>  case Red, Green, Blue
</span><span line-number="12" class=""><span class="tooltip-container"></span>
</span><span line-number="13" class=""><span class="tooltip-container"></span>new A:
</span><span line-number="14" class=""><span class="tooltip-container"></span>  def f = 3
</span><span line-number="15" class=""><span class="tooltip-container"></span>
</span><span line-number="16" class=""><span class="tooltip-container"></span>package p:
</span><span line-number="17" class=""><span class="tooltip-container"></span>  def a = 1
</span><span line-number="18" class=""><span class="tooltip-container"></span>
</span><span line-number="19" class=""><span class="tooltip-container"></span>package q:
</span><span line-number="20" class=""><span class="tooltip-container"></span>  def b = 2
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>In each case, the <code>:</code> at the end of line can be replaced without change of meaning by a pair of braces that enclose the following indented definition(s).</p>
    <p>The syntax changes allowing this are as follows:</p>
    <p>Define for an arbitrary sequence of tokens or non-terminals <code>TS</code>:</p>
    <div class="snippet mono-small-block">
     <pre><code class="language-ebnf"><span line-number="1" class=""><span class="tooltip-container"></span>:&lt;&lt;&lt; TS &gt;&gt;&gt;   ::=   ‘{’ TS ‘}’
</span><span line-number="2" class=""><span class="tooltip-container"></span>                |   &lt;colon&gt; &lt;indent" TS &lt;outdent&gt;
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Then the grammar changes as follows:</p>
    <div class="snippet mono-small-block">
     <pre><code class="language-ebnf"><span line-number="1" class=""><span class="tooltip-container"></span>TemplateBody      ::=  :&lt;&lt;&lt; [SelfType] TemplateStat {semi TemplateStat} &gt;&gt;&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>EnumBody          ::=  :&lt;&lt;&lt; [SelfType] EnumStat {semi EnumStat} &gt;&gt;&gt;
</span><span line-number="3" class=""><span class="tooltip-container"></span>Refinement        ::=  :&lt;&lt;&lt; [RefineDcl] {semi [RefineDcl]} &gt;&gt;&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>Packaging         ::=  ‘package’ QualId :&lt;&lt;&lt; TopStats &gt;&gt;&gt;
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="optional-braces-for-method-arguments">
    <h2 class="h500"><a href="#optional-braces-for-method-arguments" class="anchor"></a>Optional Braces for Method Arguments</h2>
    <p>Starting with Scala 3.3, a <code>&lt;colon&gt;</code> token is also recognized where a function argument would be expected. Examples:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>times(10):
</span><span line-number="2" class=""><span class="tooltip-container"></span>  println("ah")
</span><span line-number="3" class=""><span class="tooltip-container"></span>  println("ha")
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>or</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>credentials `++`:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val file = Path.userHome / ".credentials"
</span><span line-number="3" class=""><span class="tooltip-container"></span>  if file.exists
</span><span line-number="4" class=""><span class="tooltip-container"></span>  then Seq(Credentials(file))
</span><span line-number="5" class=""><span class="tooltip-container"></span>  else Seq()
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>or</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>xs.map:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  x =&gt;
</span><span line-number="3" class=""><span class="tooltip-container"></span>    val y = x - 1
</span><span line-number="4" class=""><span class="tooltip-container"></span>    y * y
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>What's more, a <code>:</code> in these settings can also be followed on the same line by the parameter part and arrow of a lambda. So the last example could be compressed to this:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>xs.map: x =&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val y = x - 1
</span><span line-number="3" class=""><span class="tooltip-container"></span>  y * y
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>and the following would also be legal:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>xs.foldLeft(0): (x, y) =&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>  x + y
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The grammar changes for optional braces around arguments are as follows.</p>
    <div class="snippet mono-small-block">
     <pre><code class="language-ebnf"><span line-number="1" class=""><span class="tooltip-container"></span>SimpleExpr       ::=  ...
</span><span line-number="2" class=""><span class="tooltip-container"></span>                   |  SimpleExpr ColonArgument
</span><span line-number="3" class=""><span class="tooltip-container"></span>InfixExpr        ::=  ...
</span><span line-number="4" class=""><span class="tooltip-container"></span>                   |  InfixExpr id ColonArgument
</span><span line-number="5" class=""><span class="tooltip-container"></span>ColonArgument    ::=  colon [LambdaStart]
</span><span line-number="6" class=""><span class="tooltip-container"></span>                      indent (CaseClauses | Block) outdent
</span><span line-number="7" class=""><span class="tooltip-container"></span>LambdaStart      ::=  FunParams (‘=&gt;’ | ‘?=&gt;’)
</span><span line-number="8" class=""><span class="tooltip-container"></span>                   |  HkTypeParamClause ‘=&gt;’
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="spaces-vs-tabs">
    <h2 class="h500"><a href="#spaces-vs-tabs" class="anchor"></a>Spaces vs Tabs</h2>
    <p>Indentation prefixes can consist of spaces and/or tabs. Indentation widths are the indentation prefixes themselves, ordered by the string prefix relation. So, so for instance "2 tabs, followed by 4 spaces" is strictly less than "2 tabs, followed by 5 spaces", but "2 tabs, followed by 4 spaces" is incomparable to "6 tabs" or to "4 spaces, followed by 2 tabs". It is an error if the indentation width of some line is incomparable with the indentation width of the region that's current at that point. To avoid such errors, it is a good idea not to mix spaces and tabs in the same source file.</p>
   </section>
   <section id="indentation-and-braces">
    <h2 class="h500"><a href="#indentation-and-braces" class="anchor"></a>Indentation and Braces</h2>
    <p>Indentation can be mixed freely with braces <code>{...}</code>, as well as brackets <code>[...]</code> and parentheses <code>(...)</code>. For interpreting indentation inside such regions, the following rules apply.</p>
    <ol>
     <li>
      <p>The assumed indentation width of a multiline region enclosed in braces is the indentation width of the first token that starts a new line after the opening brace.</p></li>
     <li>
      <p>The assumed indentation width of a multiline region inside brackets or parentheses is:</p>
      <ul>
       <li>if the opening bracket or parenthesis is at the end of a line, the indentation width of token following it,</li>
       <li>otherwise, the indentation width of the enclosing region.</li>
      </ul></li>
     <li>
      <p>On encountering a closing brace <code>}</code>, bracket <code>]</code> or parenthesis <code>)</code>, as many <code>&lt;outdent&gt;</code> tokens as necessary are inserted to close all open nested indentation regions.</p></li>
    </ol>
    <p>For instance, consider:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>{
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val x = 4
</span><span line-number="3" class=""><span class="tooltip-container"></span>  f(x: Int, y =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>    x * (
</span><span line-number="5" class=""><span class="tooltip-container"></span>      y + 1
</span><span line-number="6" class=""><span class="tooltip-container"></span>    ) +
</span><span line-number="7" class=""><span class="tooltip-container"></span>    (x +
</span><span line-number="8" class=""><span class="tooltip-container"></span>    x)
</span><span line-number="9" class=""><span class="tooltip-container"></span>  )
</span><span line-number="10" class=""><span class="tooltip-container"></span>}
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <ul>
     <li>Here, the indentation width of the region enclosed by the braces is 2 (i.e. the indentation width of the statement starting with <code>val</code>).</li>
     <li>The indentation width of the region in parentheses that follows <code>f</code> is also 2, since the opening parenthesis is not at the end of a line.</li>
     <li>The indentation width of the region in parentheses around <code>y + 1</code> is 6 (i.e. the indentation width of <code>y + 1</code>).</li>
     <li>Finally, the indentation width of the last region in parentheses starting with <code>(x</code> is 4 (i.e. the indentation width of the indented region following the <code>=&gt;</code>.</li>
    </ul>
   </section>
   <section id="special-treatment-of-case-clauses">
    <h2 class="h500"><a href="#special-treatment-of-case-clauses" class="anchor"></a>Special Treatment of Case Clauses</h2>
    <p>The indentation rules for <code>match</code> expressions and <code>catch</code> clauses are refined as follows:</p>
    <ul>
     <li>An indentation region is opened after a <code>match</code> or <code>catch</code> also if the following <code>case</code> appears at the indentation width that's current for the <code>match</code> itself.</li>
     <li>In that case, the indentation region closes at the first token at that same indentation width that is not a <code>case</code>, or at any token with a smaller indentation width, whichever comes first.</li>
    </ul>
    <p>The rules allow to write <code>match</code> expressions where cases are not indented themselves, as in the example below:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>x match
</span><span line-number="2" class=""><span class="tooltip-container"></span>case 1 =&gt; print("I")
</span><span line-number="3" class=""><span class="tooltip-container"></span>case 2 =&gt; print("II")
</span><span line-number="4" class=""><span class="tooltip-container"></span>case 3 =&gt; print("III")
</span><span line-number="5" class=""><span class="tooltip-container"></span>case 4 =&gt; print("IV")
</span><span line-number="6" class=""><span class="tooltip-container"></span>case 5 =&gt; print("V")
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>println(".")
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="using-indentation-to-signal-statement-continuation">
    <h2 class="h500"><a href="#using-indentation-to-signal-statement-continuation" class="anchor"></a>Using Indentation to Signal Statement Continuation</h2>
    <p>Indentation is used in some situations to decide whether to insert a virtual semicolon between two consecutive lines or to treat them as one statement. Virtual semicolon insertion is suppressed if the second line is indented more relative to the first one, and either the second line starts with "<code>(</code>", "<code>[</code>", or "<code>{</code>" or the first line ends with <code>return</code>. Examples:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>f(x + 1)
</span><span line-number="2" class=""><span class="tooltip-container"></span>  (2, 3)        // equivalent to  `f(x + 1)(2, 3)`
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>g(x + 1)
</span><span line-number="5" class=""><span class="tooltip-container"></span>(2, 3)          // equivalent to  `g(x + 1); (2, 3)`
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>h(x + 1)
</span><span line-number="8" class=""><span class="tooltip-container"></span>  {}            // equivalent to  `h(x + 1){}`
</span><span line-number="9" class=""><span class="tooltip-container"></span>
</span><span line-number="10" class=""><span class="tooltip-container"></span>i(x + 1)
</span><span line-number="11" class=""><span class="tooltip-container"></span>{}              // equivalent to  `i(x + 1); {}`
</span><span line-number="12" class=""><span class="tooltip-container"></span>
</span><span line-number="13" class=""><span class="tooltip-container"></span>if x &lt; 0 then return
</span><span line-number="14" class=""><span class="tooltip-container"></span>  a + b         // equivalent to  `if x &lt; 0 then return a + b`
</span><span line-number="15" class=""><span class="tooltip-container"></span>
</span><span line-number="16" class=""><span class="tooltip-container"></span>if x &lt; 0 then return
</span><span line-number="17" class=""><span class="tooltip-container"></span>println(a + b)  // equivalent to  `if x &lt; 0 then return; println(a + b)`
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>In Scala 2, a line starting with "<code>{</code>" always continues the function call on the preceding line, irrespective of indentation, whereas a virtual semicolon is inserted in all other cases. The Scala-2 behavior is retained under source <code>-no-indent</code> or <code>-source 3.0-migration</code>.</p>
   </section>
   <section id="the-end-marker">
    <h2 class="h500"><a href="#the-end-marker" class="anchor"></a>The End Marker</h2>
    <p>Indentation-based syntax has many advantages over other conventions. But one possible problem is that it makes it hard to discern when a large indentation region ends, since there is no specific token that delineates the end. Braces are not much better since a brace by itself also contains no information about what region is closed.</p>
    <p>To solve this problem, Scala 3 offers an optional <code>end</code> marker. Example:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>def largeMethod(...) =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>  if ... then ...
</span><span line-number="4" class=""><span class="tooltip-container"></span>  else
</span><span line-number="5" class=""><span class="tooltip-container"></span>    ... // a large block
</span><span line-number="6" class=""><span class="tooltip-container"></span>  end if
</span><span line-number="7" class=""><span class="tooltip-container"></span>  ... // more code
</span><span line-number="8" class=""><span class="tooltip-container"></span>end largeMethod
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>An <code>end</code> marker consists of the identifier <code>end</code> and a follow-on specifier token that together constitute all the tokes of a line. Possible specifier tokens are identifiers or one of the following keywords</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>if   while    for    match    try    new    this    val   given
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>End markers are allowed in statement sequences. The specifier token <code>s</code> of an end marker must correspond to the statement that precedes it. This means:</p>
    <ul>
     <li>If the statement defines a member <code>x</code> then <code>s</code> must be the same identifier <code>x</code>.</li>
     <li>If the statement defines a constructor then <code>s</code> must be <code>this</code>.</li>
     <li>If the statement defines an anonymous given, then <code>s</code> must be <code>given</code>.</li>
     <li>If the statement defines an anonymous extension, then <code>s</code> must be <code>extension</code>.</li>
     <li>If the statement defines an anonymous class, then <code>s</code> must be <code>new</code>.</li>
     <li>If the statement is a <code>val</code> definition binding a pattern, then <code>s</code> must be <code>val</code>.</li>
     <li>If the statement is a package clause that refers to package <code>p</code>, then <code>s</code> must be the same identifier <code>p</code>.</li>
     <li>If the statement is an <code>if</code>, <code>while</code>, <code>for</code>, <code>try</code>, or <code>match</code> statement, then <code>s</code> must be that same token.</li>
    </ul>
    <p>For instance, the following end markers are all legal:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>package p1.p2:
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  abstract class C():
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>    def this(x: Int) =
</span><span line-number="6" class=""><span class="tooltip-container"></span>      this()
</span><span line-number="7" class=""><span class="tooltip-container"></span>      if x &gt; 0 then
</span><span line-number="8" class=""><span class="tooltip-container"></span>        val a :: b =
</span><span line-number="9" class=""><span class="tooltip-container"></span>          x :: Nil
</span><span line-number="10" class=""><span class="tooltip-container"></span>        end val
</span><span line-number="11" class=""><span class="tooltip-container"></span>        var y =
</span><span line-number="12" class=""><span class="tooltip-container"></span>          x
</span><span line-number="13" class=""><span class="tooltip-container"></span>        end y
</span><span line-number="14" class=""><span class="tooltip-container"></span>        while y &gt; 0 do
</span><span line-number="15" class=""><span class="tooltip-container"></span>          println(y)
</span><span line-number="16" class=""><span class="tooltip-container"></span>          y -= 1
</span><span line-number="17" class=""><span class="tooltip-container"></span>        end while
</span><span line-number="18" class=""><span class="tooltip-container"></span>        try
</span><span line-number="19" class=""><span class="tooltip-container"></span>          x match
</span><span line-number="20" class=""><span class="tooltip-container"></span>            case 0 =&gt; println("0")
</span><span line-number="21" class=""><span class="tooltip-container"></span>            case _ =&gt;
</span><span line-number="22" class=""><span class="tooltip-container"></span>          end match
</span><span line-number="23" class=""><span class="tooltip-container"></span>        finally
</span><span line-number="24" class=""><span class="tooltip-container"></span>          println("done")
</span><span line-number="25" class=""><span class="tooltip-container"></span>        end try
</span><span line-number="26" class=""><span class="tooltip-container"></span>      end if
</span><span line-number="27" class=""><span class="tooltip-container"></span>    end this
</span><span line-number="28" class=""><span class="tooltip-container"></span>
</span><span line-number="29" class=""><span class="tooltip-container"></span>    def f: String
</span><span line-number="30" class=""><span class="tooltip-container"></span>  end C
</span><span line-number="31" class=""><span class="tooltip-container"></span>
</span><span line-number="32" class=""><span class="tooltip-container"></span>  object C:
</span><span line-number="33" class=""><span class="tooltip-container"></span>    given C =
</span><span line-number="34" class=""><span class="tooltip-container"></span>      new C:
</span><span line-number="35" class=""><span class="tooltip-container"></span>        def f = "!"
</span><span line-number="36" class=""><span class="tooltip-container"></span>        end f
</span><span line-number="37" class=""><span class="tooltip-container"></span>      end new
</span><span line-number="38" class=""><span class="tooltip-container"></span>    end given
</span><span line-number="39" class=""><span class="tooltip-container"></span>  end C
</span><span line-number="40" class=""><span class="tooltip-container"></span>
</span><span line-number="41" class=""><span class="tooltip-container"></span>  extension (x: C)
</span><span line-number="42" class=""><span class="tooltip-container"></span>    def ff: String = x.f ++ x.f
</span><span line-number="43" class=""><span class="tooltip-container"></span>  end extension
</span><span line-number="44" class=""><span class="tooltip-container"></span>
</span><span line-number="45" class=""><span class="tooltip-container"></span>end p2
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="when-to-use-end-markers">
    <h3 class="h400"><a href="#when-to-use-end-markers" class="anchor"></a>When to Use End Markers</h3>
    <p>It is recommended that <code>end</code> markers are used for code where the extent of an indentation region is not immediately apparent "at a glance". People will have different preferences what this means, but one can nevertheless give some guidelines that stem from experience. An end marker makes sense if</p>
    <ul>
     <li>the construct contains blank lines, or</li>
     <li>the construct is long, say 15-20 lines or more,</li>
     <li>the construct ends heavily indented, say 4 indentation levels or more.</li>
    </ul>
    <p>If none of these criteria apply, it's often better to not use an end marker since the code will be just as clear and more concise. If there are several ending regions that satisfy one of the criteria above, we usually need an end marker only for the outermost closed region. So cascades of end markers as in the example above are usually better avoided.</p>
   </section>
   <section id="syntax">
    <h3 class="h400"><a href="#syntax" class="anchor"></a>Syntax</h3>
    <div class="snippet mono-small-block">
     <pre><code class="language-ebnf"><span line-number="1" class=""><span class="tooltip-container"></span>EndMarker         ::=  ‘end’ EndMarkerTag    -- when followed by EOL
</span><span line-number="2" class=""><span class="tooltip-container"></span>EndMarkerTag      ::=  id | ‘if’ | ‘while’ | ‘for’ | ‘match’ | ‘try’
</span><span line-number="3" class=""><span class="tooltip-container"></span>                    |  ‘new’ | ‘this’ | ‘given’ | ‘extension’ | ‘val’
</span><span line-number="4" class=""><span class="tooltip-container"></span>BlockStat         ::=  ... | EndMarker
</span><span line-number="5" class=""><span class="tooltip-container"></span>TemplateStat      ::=  ... | EndMarker
</span><span line-number="6" class=""><span class="tooltip-container"></span>TopStat           ::=  ... | EndMarker
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="example">
    <h2 class="h500"><a href="#example" class="anchor"></a>Example</h2>
    <p>Here is a (somewhat meta-circular) example of code using indentation. It provides a concrete representation of indentation widths as defined above together with efficient operations for constructing and comparing indentation widths.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>enum IndentWidth:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case Run(ch: Char, n: Int)
</span><span line-number="3" class=""><span class="tooltip-container"></span>  case Conc(l: IndentWidth, r: Run)
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>  def &lt;= (that: IndentWidth): Boolean = this match
</span><span line-number="6" class=""><span class="tooltip-container"></span>    case Run(ch1, n1) =&gt;
</span><span line-number="7" class=""><span class="tooltip-container"></span>      that match
</span><span line-number="8" class=""><span class="tooltip-container"></span>        case Run(ch2, n2) =&gt; n1 &lt;= n2 &amp;&amp; (ch1 == ch2 || n1 == 0)
</span><span line-number="9" class=""><span class="tooltip-container"></span>        case Conc(l, r)   =&gt; this &lt;= l
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case Conc(l1, r1) =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>      that match
</span><span line-number="12" class=""><span class="tooltip-container"></span>        case Conc(l2, r2) =&gt; l1 == l2 &amp;&amp; r1 &lt;= r2
</span><span line-number="13" class=""><span class="tooltip-container"></span>        case _            =&gt; false
</span><span line-number="14" class=""><span class="tooltip-container"></span>
</span><span line-number="15" class=""><span class="tooltip-container"></span>  def &lt; (that: IndentWidth): Boolean =
</span><span line-number="16" class=""><span class="tooltip-container"></span>    this &lt;= that &amp;&amp; !(that &lt;= this)
</span><span line-number="17" class=""><span class="tooltip-container"></span>
</span><span line-number="18" class=""><span class="tooltip-container"></span>  override def toString: String =
</span><span line-number="19" class=""><span class="tooltip-container"></span>    this match
</span><span line-number="20" class=""><span class="tooltip-container"></span>      case Run(ch, n) =&gt;
</span><span line-number="21" class=""><span class="tooltip-container"></span>        val kind = ch match
</span><span line-number="22" class=""><span class="tooltip-container"></span>          case ' '  =&gt; "space"
</span><span line-number="23" class=""><span class="tooltip-container"></span>          case '\t' =&gt; "tab"
</span><span line-number="24" class=""><span class="tooltip-container"></span>          case _    =&gt; s"'$ch'-character"
</span><span line-number="25" class=""><span class="tooltip-container"></span>        val suffix = if n == 1 then "" else "s"
</span><span line-number="26" class=""><span class="tooltip-container"></span>        s"$n $kind$suffix"
</span><span line-number="27" class=""><span class="tooltip-container"></span>      case Conc(l, r) =&gt;
</span><span line-number="28" class=""><span class="tooltip-container"></span>        s"$l, $r"
</span><span line-number="29" class=""><span class="tooltip-container"></span>
</span><span line-number="30" class=""><span class="tooltip-container"></span>object IndentWidth:
</span><span line-number="31" class=""><span class="tooltip-container"></span>  private inline val MaxCached = 40
</span><span line-number="32" class=""><span class="tooltip-container"></span>
</span><span line-number="33" class=""><span class="tooltip-container"></span>  private val spaces = IArray.tabulate(MaxCached + 1)(new Run(' ', _))
</span><span line-number="34" class=""><span class="tooltip-container"></span>  private val tabs = IArray.tabulate(MaxCached + 1)(new Run('\t', _))
</span><span line-number="35" class=""><span class="tooltip-container"></span>
</span><span line-number="36" class=""><span class="tooltip-container"></span>  def Run(ch: Char, n: Int): Run =
</span><span line-number="37" class=""><span class="tooltip-container"></span>    if n &lt;= MaxCached &amp;&amp; ch == ' ' then
</span><span line-number="38" class=""><span class="tooltip-container"></span>      spaces(n)
</span><span line-number="39" class=""><span class="tooltip-container"></span>    else if n &lt;= MaxCached &amp;&amp; ch == '\t' then
</span><span line-number="40" class=""><span class="tooltip-container"></span>      tabs(n)
</span><span line-number="41" class=""><span class="tooltip-container"></span>    else
</span><span line-number="42" class=""><span class="tooltip-container"></span>      new Run(ch, n)
</span><span line-number="43" class=""><span class="tooltip-container"></span>  end Run
</span><span line-number="44" class=""><span class="tooltip-container"></span>
</span><span line-number="45" class=""><span class="tooltip-container"></span>  val Zero = Run(' ', 0)
</span><span line-number="46" class=""><span class="tooltip-container"></span>end IndentWidth
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="settings-and-rewrites">
    <h2 class="h500"><a href="#settings-and-rewrites" class="anchor"></a>Settings and Rewrites</h2>
    <p>Significant indentation is enabled by default. It can be turned off by giving any of the options <code>-no-indent</code>, <code>-old-syntax</code> and <code>-source 3.0-migration</code>. If indentation is turned off, it is nevertheless checked that indentation conforms to the logical program structure as defined by braces. If that is not the case, the compiler issues a warning.</p>
    <p>The Scala 3 compiler can rewrite source code to indented code and back. When invoked with options <code>-rewrite -indent</code> it will rewrite braces to indented regions where possible. When invoked with options <code>-rewrite -no-indent</code> it will rewrite in the reverse direction, inserting braces for indentation regions. The <code>-indent</code> option only works on <a href="control-syntax.html">new-style syntax</a>. So to go from old-style syntax to new-style indented code one has to invoke the compiler twice, first with options <code>-rewrite -new-syntax</code>, then again with options <code>-rewrite -indent</code>. To go in the opposite direction, from indented code to old-style syntax, it's <code>-rewrite -no-indent</code>, followed by <code>-rewrite -old-syntax</code>.</p>
   </section>
  </main>
  <div class="divider"></div>
  <nav class="arrow-navigation" aria-label="Page navigation">
   <div>
    <span class="body-small">Previous</span> <a rel="prev" href="control-syntax.html" aria-keyshortcuts="Left" class="body-medium"> <span class="body-medium">New Control Syntax</span> </a>
   </div>
   <div>
    <span class="body-small">Next</span> <a rel="next" href="safe-initialization.html" aria-keyshortcuts="Right" class="body-medium"> <span class="body-medium">Safe Initialization</span> </a>
   </div>
  </nav>
 </div>
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#indentation-rules">Indentation Rules</a></li><li><a href="#optional-braces">Optional Braces</a></li><li><a href="#optional-braces-around-template-bodies">Optional Braces Around Template Bodies</a></li><li><a href="#optional-braces-for-method-arguments">Optional Braces for Method Arguments</a></li><li><a href="#spaces-vs-tabs">Spaces vs Tabs</a></li><li><a href="#indentation-and-braces">Indentation and Braces</a></li><li><a href="#special-treatment-of-case-clauses">Special Treatment of Case Clauses</a></li><li><a href="#using-indentation-to-signal-statement-continuation">Using Indentation to Signal Statement Continuation</a></li><li><a href="#the-end-marker">The End Marker</a><ul><li><a href="#when-to-use-end-markers">When to Use End Markers</a></li><li><a href="#syntax">Syntax</a></li></ul></li><li><a href="#example">Example</a></li><li><a href="#settings-and-rewrites">Settings and Rewrites</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div></div></div></body></html>