<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/scala/scala3" data-githubContributorsFilename="docs/_docs/reference/other-new-features/named-tuples.md" data-pathToRoot="../" data-rawLocation="other-new-features/named-tuples" data-dynamicSideMenu="false"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Named Tuples</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="/css/dottydoc.css"></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../" class="logo-container"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">3.7.1</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><a href="https://docs.scala-lang.org/" class="text-button">Learn</a><a href="https://www.scala-lang.org/download/" class="text-button">Install</a><a href="https://scastie.scala-lang.org" class="text-button">Playground</a><a href="https://index.scala-lang.org" class="text-button">Find A Library</a><a href="https://www.scala-lang.org/community/" class="text-button">Community</a><a href="https://www.scala-lang.org/blog/" class="text-button">Blog</a><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span id="project-logo" class="project-logo"><img src="../project-logo/logo.svg"></img></span><span id="dark-project-logo" class="project-logo"><img src="../project-logo/logo_dark.svg"></img></span><span class="project-name h300">Scala 3 Reference</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><a href="https://docs.scala-lang.org/" class="mobile-menu-item">Learn</a><a href="https://www.scala-lang.org/download/" class="mobile-menu-item">Install</a><a href="https://scastie.scala-lang.org" class="mobile-menu-item">Playground</a><a href="https://index.scala-lang.org" class="mobile-menu-item">Find A Library</a><a href="https://www.scala-lang.org/community/" class="mobile-menu-item">Community</a><a href="https://www.scala-lang.org/blog/" class="mobile-menu-item">Blog</a><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../index.html">Docs</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../new-types/index.html"><span>New Types</span></a></span><div class="ni n1 "><span class="nh de"><a href="../new-types/intersection-types.html"><span>Intersection Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/union-types.html"><span>Union Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/type-lambdas.html"><span>Type Lambdas</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/match-types.html"><span>Match Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/dependent-function-types.html"><span>Dependent Function Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../new-types/polymorphic-function-types.html"><span>Polymorphic Function Types</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../enums/index.html"><span>Enums</span></a></span><div class="ni n1 "><span class="nh de"><a href="../enums/enums.html"><span>Enumerations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/adts.html"><span>Algebraic Data Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../enums/desugarEnums.html"><span>Translation of Enums and ADTs</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../contextual/index.html"><span>Contextual Abstractions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../contextual/givens.html"><span>Given Instances</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/deferred-givens.html"><span>Deferred Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/more-givens.html"><span>Other Forms Of Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/previous-givens.html"><span>Previous Given Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/using-clauses.html"><span>Using Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-bounds.html"><span>Context Bounds</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/given-imports.html"><span>Importing Givens</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/extension-methods.html"><span>Extension Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/right-associative-extension-methods.html"><span>Right-Associative Extension Methods: Details</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/type-classes.html"><span>Implementing Type classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation.html"><span>Type Class Derivation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/derivation-macro.html"><span>How to write a type class `derived` method using macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/multiversal-equality.html"><span>Multiversal Equality</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/context-functions.html"><span>Context Functions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/by-name-context-parameters.html"><span>By-Name Context Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../contextual/relationship-implicits.html"><span>Relationship with Scala 2 Implicits</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../metaprogramming/index.html"><span>Metaprogramming</span></a></span><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/inline.html"><span>Inline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/compiletime-ops.html"><span>Compile-time operations</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/macros.html"><span>Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/staging.html"><span>Run-Time Multi-Stage Programming</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/reflection.html"><span>Reflection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/tasty-inspect.html"><span>TASTy Inspection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../metaprogramming/simple-smp.html"><span>The Meta-theory of Symmetric Metaprogramming</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>Other New Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="trait-parameters.html"><span>Trait Parameters</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="transparent-traits.html"><span>Transparent Traits and Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="creator-applications.html"><span>Universal Apply Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="export.html"><span>Export Clauses</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="opaques.html"><span>Opaque Type Aliases</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="opaques-details.html"><span>Opaque Type Aliases: More Details</span></a></span></div><div class="ni n1 expanded"><span class="nh h100 selected de"><a href="#"><span>Named Tuples</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="open-classes.html"><span>Open Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="parameter-untupling.html"><span>Parameter Untupling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="kind-polymorphism.html"><span>Kind Polymorphism</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="matchable.html"><span>The Matchable Trait</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="threadUnsafe-annotation.html"><span>The @threadUnsafe annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="targetName.html"><span>The @targetName annotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="control-syntax.html"><span>New Control Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="indentation.html"><span>Optional Braces</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="safe-initialization.html"><span>Safe Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="type-test.html"><span>TypeTest</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="experimental-defs.html"><span>Experimental Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="preview-defs.html"><span>Preview Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="binary-literals.html"><span>Binary Integer Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="toplevel-definitions.html"><span>Toplevel Definitions</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../changed-features/index.html"><span>Other Changed Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../changed-features/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/structural-types.html"><span>Programmatic Structural Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/operators.html"><span>Rules for Operators</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/wildcards.html"><span>Wildcard Arguments in Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/imports.html"><span>Imports</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/type-inference.html"><span>Changes in Type Inference</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-resolution.html"><span>Changes in Implicit Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/implicit-conversions.html"><span>Implicit Conversions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/overload-resolution.html"><span>Changes in Overload Resolution</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/match-syntax.html"><span>Match Expressions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/vararg-splices.html"><span>Vararg Splices</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-bindings.html"><span>Pattern Bindings</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/pattern-matching.html"><span>Option-less pattern matching</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/eta-expansion.html"><span>Automatic Eta Expansion</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/compiler-plugins.html"><span>Changes in Compiler Plugins</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/lazy-vals-init.html"><span>Lazy Vals Initialization</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/main-functions.html"><span>Main Methods</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../changed-features/interpolation-escapes.html"><span>Escapes in interpolations</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../dropped-features/index.html"><span>Dropped Features</span></a></span><div class="ni n1 "><span class="nh de"><a href="../dropped-features/delayed-init.html"><span>Dropped: DelayedInit</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/macros.html"><span>Dropped: Scala 2 Macros</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/existential-types.html"><span>Dropped: Existential Types</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/type-projection.html"><span>Dropped: General Type Projection</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/do-while.html"><span>Dropped: Do-While</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/procedure-syntax.html"><span>Dropped: Procedure Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/early-initializers.html"><span>Dropped: Early Initializers</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/class-shadowing.html"><span>Dropped: Class Shadowing</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/limit22.html"><span>Dropped: Limit 22</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/xml.html"><span>Dropped: XML Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/symlits.html"><span>Dropped: Symbol Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/auto-apply.html"><span>Dropped: Auto-Application</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/weak-conformance.html"><span>Dropped: Weak Conformance</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/nonlocal-returns.html"><span>Deprecated: Nonlocal Returns</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/this-qualifier.html"><span>Dropped: private[this] and protected[this]</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../dropped-features/wildcard-init.html"><span>Dropped: Wildcard Initializer</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../preview/index.html"><span>Preview</span></a></span><div class="ni n1 "><span class="nh de"><a href="../preview/better-fors.html"><span>Better fors</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../experimental/index.html"><span>Experimental</span></a></span><div class="ni n1 "><span class="nh de"><a href="../experimental/canthrow.html"><span>CanThrow Capabilities</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/erased-defs.html"><span>Erased Definitions</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/named-typeargs.html"><span>Named Type Arguments</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/numeric-literals.html"><span>Numeric Literals</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/explicit-nulls.html"><span>Explicit Nulls</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/main-annotation.html"><span>MainAnnotation</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/into-modifier.html"><span>The `into` Type Modifier</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/cc.html"><span>Capture Checking</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/purefuns.html"><span>Pure Function Syntax</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/tupled-function.html"><span>Tupled Function</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/modularity.html"><span>Modularity Improvements</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/typeclasses.html"><span>Better Support for Type Classes</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/runtimeChecked.html"><span>The runtimeChecked method</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/unrolled-defs.html"><span>Automatic Parameter Unrolling</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../experimental/package-object-values.html"><span>Reference-able Package Objects</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../syntax.html"><span>Scala 3 Syntax Summary</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../language-versions/index.html"><span>Language Versions</span></a></span><div class="ni n1 "><span class="nh de"><a href="../language-versions/source-compatibility.html"><span>Source Compatibility</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../language-versions/binary-compatibility.html"><span>Binary Compatibility</span></a></span></div></div><div class="ni n0 "><span class="nh de"><a href="../soft-modifier.html"><span>Soft Keywords</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../features-classification.html"><span>A Classification of Proposed Language Features</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">Scala 3 Reference</a>/<a href="index.html">Other New Features</a>/<a href="named-tuples.html">Named Tuples</a></div><div id="content" class="body-medium"><div><div id="content-wrapper">
 <div class="site-container">
  <div id="site-header"></div>
  <main>
   <header>
    <a class="text-button with-link body-small" href="https://github.com/scala/scala3/edit/language-reference-stable/docs/_docs/reference/other-new-features/named-tuples.md">Edit this page on GitHub</a>
    <h1 class="h600">Named Tuples</h1>
   </header>
   <p class="body-large first-p">Starting in Scala 3.7, the elements of a tuple can be named. Example:</p>
   <div class="snippet mono-small-block" scala-snippet="">
    <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>type Person = (name: String, age: Int)
</span><span line-number="2" class=""><span class="tooltip-container"></span>val Bob: Person = (name = "Bob", age = 33)
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>Bob match
</span><span line-number="5" class=""><span class="tooltip-container"></span>  case (name, age) =&gt;
</span><span line-number="6" class=""><span class="tooltip-container"></span>    println(s"$name is $age years old")
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>val persons: List[Person] = ...
</span><span line-number="9" class=""><span class="tooltip-container"></span>val minors = persons.filter: p =&gt;
</span><span line-number="10" class=""><span class="tooltip-container"></span>  p.age &lt; 18
</span></code></pre>
    <div class="buttons"></div>
   </div>
   <p>Named bindings in tuples are similar to function parameters and arguments. We use <code>name: Type</code> for element types and <code>name = value</code> for element values. It is illegal to mix named and unnamed elements in a tuple, or to use the same name for two different elements.</p>
   <p>Fields of named tuples can be selected by their name, as in the line <code>p.age &lt; 18</code> above.</p>
   <section id="conformance-and-convertibility">
    <h3 class="h400"><a href="#conformance-and-convertibility" class="anchor"></a>Conformance and Convertibility</h3>
    <p>The order of names in a named tuple matters. For instance, the type <code>Person</code> above and the type <code>(age: Int, name: String)</code> would be different, incompatible types.</p>
    <p>Values of named tuple types can also be be defined using regular tuples. For instance:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val Laura: Person = ("Laura", 25)
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>def register(person: Person) = ...
</span><span line-number="4" class=""><span class="tooltip-container"></span>register(person = ("Silvain", 16))
</span><span line-number="5" class=""><span class="tooltip-container"></span>register(("Silvain", 16))
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This follows since a regular tuple <code>(T_1, ..., T_n)</code> is treated as a subtype of a named tuple <code>(N_1 = T_1, ..., N_n = T_n)</code> with the same element types.</p>
    <p>In the other direction, one can convert a named tuple to an unnamed tuple with the <code>toTuple</code> method. Example:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val x: (String, Int) = Bob.toTuple // ok
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><code>toTuple</code> is defined as an extension method in the <code>NamedTuple</code> object. It returns the given tuple unchanged and simply "forgets" the names.</p>
    <p>A <code>.toTuple</code> selection is inserted implicitly by the compiler if it encounters a named tuple but the expected type is a regular tuple. So the following works as well:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val x: (String, Int) = Bob  // works, expanded to Bob.toTuple
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The difference between subtyping in one direction and automatic <code>.toTuple</code> conversions in the other is relatively minor. The main difference is that <code>.toTuple</code> conversions don't work inside type constructors. So the following is OK:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>val names = List("Laura", "Silvain")
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable">  </span>val ages = List(25, 16)
</span><span line-number="3" class=""><span class="tooltip-container"></span><span class="hideable">  </span>val persons: List[Person] = names.zip(ages)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>But the following would be illegal.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>val persons: List[Person] = List(Bob, Laura)
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable">  </span>val pairs: List[(String, Int)] = persons // error
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>We would need an explicit <code>_.toTuple</code> selection to express this:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>val pairs: List[(String, Int)] = persons.map(_.toTuple)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Note that conformance rules for named tuples are analogous to the rules for named parameters. One can assign parameters by position to a named parameter list.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>def f(param: Int) = ...
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable">  </span>f(param = 1)   // OK
</span><span line-number="3" class=""><span class="tooltip-container"></span><span class="hideable">  </span>f(2)           // Also OK
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>But one cannot use a name to pass an argument to an unnamed parameter:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">    </span>val f: Int =&gt; T
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable">    </span>f(2)         // OK
</span><span line-number="3" class=""><span class="tooltip-container"></span><span class="hideable">    </span>f(param = 2) // Not OK
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The rules for tuples are analogous. Unnamed tuples conform to named tuple types, but the opposite requires a conversion.</p>
   </section>
   <section id="pattern-matching">
    <h3 class="h400"><a href="#pattern-matching" class="anchor"></a>Pattern Matching</h3>
    <p>When pattern matching on a named tuple, the pattern may be named or unnamed. If the pattern is named it needs to mention only a subset of the tuple names, and these names can come in any order. So the following are all OK:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>Bob match
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case (name, age) =&gt; ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>Bob match
</span><span line-number="5" class=""><span class="tooltip-container"></span>  case (name = x, age = y) =&gt; ...
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>Bob match
</span><span line-number="8" class=""><span class="tooltip-container"></span>  case (age = x) =&gt; ...
</span><span line-number="9" class=""><span class="tooltip-container"></span>
</span><span line-number="10" class=""><span class="tooltip-container"></span>Bob match
</span><span line-number="11" class=""><span class="tooltip-container"></span>  case (age = x, name = y) =&gt; ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="pattern-matching-with-named-fields-in-general">
    <h3 class="h400"><a href="#pattern-matching-with-named-fields-in-general" class="anchor"></a>Pattern Matching with Named Fields in General</h3>
    <p>We allow named patterns not just for named tuples but also for case classes. For instance:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>city match
</span><span line-number="2" class=""><span class="tooltip-container"></span>  case c @ City(name = "London") =&gt; println(c.population)
</span><span line-number="3" class=""><span class="tooltip-container"></span>  case City(name = n, zip = 1026, population = pop) =&gt; println(pop)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Named constructor patterns are analogous to named tuple patterns. In both cases</p>
    <ul>
     <li>every name must match the name some field of the selector,</li>
     <li>names can come in any order,</li>
     <li>not all fields of the selector need to be matched.</li>
    </ul>
    <p>Named patterns are compatible with extensible pattern matching simply because <code>unapply</code> results can be named tuples.</p>
   </section>
   <section id="expansion">
    <h3 class="h400"><a href="#expansion" class="anchor"></a>Expansion</h3>
    <p>Named tuples are in essence just a convenient syntax for regular tuples. In the internal representation, a named tuple type is represented at compile time as a pair of two tuples. One tuple contains the names as literal constant string types, the other contains the element types. The runtime representation of a named tuples consists of just the element values, whereas the names are forgotten. This is achieved by declaring <code>NamedTuple</code> in package <code>scala</code> as an opaque type as follows:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>opaque type NamedTuple[N &lt;: Tuple, +V &lt;: Tuple] &gt;: V = V
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>For instance, the <code>Person</code> type would be represented as the type</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>NamedTuple[("name", "age"), (String, Int)]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><code>NamedTuple</code> is an opaque type alias of its second, value parameter. The first parameter is a string constant type which determines the name of the element. Since the type is just an alias of its value part, names are erased at runtime, and named tuples and regular tuples have the same representation.</p>
    <p>A <code>NamedTuple[N, V]</code> type is publicly known to be a supertype (but not a subtype) of its value paramater <code>V</code>, which means that regular tuples can be assigned to named tuples but not <em>vice versa</em>.</p>
    <p>The <code>NamedTuple</code> object contains a number of extension methods for named tuples that mirror the same functions in <code>Tuple</code>. Examples are <code>apply</code>, <code>head</code>, <code>tail</code>, <code>take</code>, <code>drop</code>, <code>++</code>, <code>map</code>, or <code>zip</code>. Similar to <code>Tuple</code>, the <code>NamedTuple</code> object also contains types such as <code>Elem</code>, <code>Head</code>, <code>Concat</code> that describe the results of these extension methods.</p>
    <p>The translation of named tuples to instances of <code>NamedTuple</code> is fixed by the specification and therefore known to the programmer. This means that:</p>
    <ul>
     <li>All tuple operations also work with named tuples "out of the box".</li>
     <li>Macro libraries can rely on this expansion.</li>
    </ul>
   </section>
   <section id="computed-field-names">
    <h3 class="h400"><a href="#computed-field-names" class="anchor"></a>Computed Field Names</h3>
    <p>The <code>Selectable</code> trait now has a <code>Fields</code> type member that can be instantiated to a named tuple.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait Selectable:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  type Fields &lt;: NamedTuple.AnyNamedTuple
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>If <code>Fields</code> is instantiated in a subclass of <code>Selectable</code> to some named tuple type, then the available fields and their types will be defined by that type. Assume <code>n: T</code> is an element of the <code>Fields</code> type in some class <code>C</code> that implements <code>Selectable</code>, that <code>c: C</code>, and that <code>n</code> is not otherwise legal as a name of a selection on <code>c</code>. Then <code>c.n</code> is a legal selection, which expands to <code>c.selectDynamic("n").asInstanceOf[T]</code>.</p>
    <p>It is the task of the implementation of <code>selectDynamic</code> in <code>C</code> to ensure that its computed result conforms to the predicted type <code>T</code>.</p>
    <p>As an example, assume we have a query type <code>Q[T]</code> defined as follows:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait Q[T] extends Selectable:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  type Fields = NamedTuple.Map[NamedTuple.From[T], Q]
</span><span line-number="3" class=""><span class="tooltip-container"></span>  def selectDynamic(fieldName: String) = ...
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Assume in the user domain:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class City(zipCode: Int, name: String, population: Int)
</span><span line-number="2" class=""><span class="tooltip-container"></span>val city: Q[City]
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>Then</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>city.zipCode
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>has type <code>Q[Int]</code> and it expands to</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>city.selectDynamic("zipCode").asInstanceOf[Q[Int]]
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="the-namedtuplefrom-type">
    <h3 class="h400"><a href="#the-namedtuplefrom-type" class="anchor"></a>The NamedTuple.From Type</h3>
    <p>The <code>NamedTuple</code> object contains a type definition</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>type From[T] &lt;: AnyNamedTuple
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p><code>From</code> is treated specially by the compiler. When <code>NamedTuple.From</code> is applied to an argument type that is an instance of a case class, the type expands to the named tuple consisting of all the fields of that case class. Here, <em>fields</em> means: elements of the first parameter section. For instance, assuming</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class City(zip: Int, name: String, population: Int)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>then <code>NamedTuple.From[City]</code> is the named tuple</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>(zip: Int, name: String, population: Int)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>The same works for enum cases expanding to case classes, abstract types with case classes as upper bound, alias types expanding to case classes and singleton types with case classes as underlying type (in terms of the implementation, the <code>classSymbol</code> of a type must be a case class).</p>
    <p><code>From</code> is also defined on named tuples. If <code>NT</code> is a named tuple type, then <code>From[NT] = NT</code>.</p>
   </section>
   <section id="operations-on-named-tuples">
    <h3 class="h400"><a href="#operations-on-named-tuples" class="anchor"></a>Operations on Named Tuples</h3>
    <p>The operations on named tuples are defined in object <a href="https://www.scala-lang.org/api/3.x/scala/NamedTuple$.html">scala.NamedTuple</a>.</p>
   </section>
   <section id="restrictions">
    <h3 class="h400"><a href="#restrictions" class="anchor"></a>Restrictions</h3>
    <p>The following restrictions apply to named tuples and named pattern arguments:</p>
    <ol>
     <li>Either all elements of a tuple or constructor pattern are named or none are named. It is illegal to mix named and unnamed elements in a tuple. For instance, the following is in error: 
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val illFormed1 = ("Bob", age = 33)  // error
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
     <li>Each element name in a named tuple or constructor pattern must be unique. For instance, the following is in error: 
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val illFormed2 = (name = "", age = 0, name = true)  // error
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
     <li>Named tuples and case classes can be matched with either named or regular patterns. But regular tuples and other selector types can only be matched with regular tuple patterns. For instance, the following is in error: 
      <div class="snippet mono-small-block" scala-snippet="">
       <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>(tuple: Tuple) match
</span><span line-number="2" class=""><span class="tooltip-container"></span>    case (age = x) =&gt; // error
</span></code></pre>
       <div class="buttons"></div>
      </div></li>
    </ol>
   </section>
   <section id="syntax-changes">
    <h2 class="h500"><a href="#syntax-changes" class="anchor"></a>Syntax Changes</h2>
    <p>The syntax of Scala is extended as follows to support named tuples and named constructor arguments:</p>
    <div class="snippet mono-small-block">
     <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>SimpleType        ::=  ...
</span><span line-number="2" class=""><span class="tooltip-container"></span>                    |  ‘(’ NameAndType {‘,’ NameAndType} ‘)’
</span><span line-number="3" class=""><span class="tooltip-container"></span>NameAndType       ::=  id ':' Type
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>SimpleExpr        ::=  ...
</span><span line-number="6" class=""><span class="tooltip-container"></span>                    |  '(' NamedExprInParens {‘,’ NamedExprInParens} ')'
</span><span line-number="7" class=""><span class="tooltip-container"></span>NamedExprInParens ::=  id '=' ExprInParens
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>Patterns          ::=  Pattern {‘,’ Pattern}
</span><span line-number="10" class=""><span class="tooltip-container"></span>                    |  NamedPattern {‘,’ NamedPattern}
</span><span line-number="11" class=""><span class="tooltip-container"></span>NamedPattern      ::=  id '=' Pattern
</span></code></pre>
     <div class="buttons"></div>
    </div>
   </section>
   <section id="source-incompatibilities">
    <h3 class="h400"><a href="#source-incompatibilities" class="anchor"></a>Source Incompatibilities</h3>
    <p>There are some source incompatibilities involving named tuples of length one. First, what was previously classified as an assignment could now be interpreted as a named tuple. Example:</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>var age: Int
</span><span line-number="2" class=""><span class="tooltip-container"></span>(age = 1)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>This was an assignment in parentheses before, and is a named tuple of arity one now. It is however not idiomatic Scala code, since assignments are not usually enclosed in parentheses.</p>
    <p>Second, what was a named argument to an infix operator can now be interpreted as a named tuple.</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class C:
</span><span line-number="2" class=""><span class="tooltip-container"></span>  infix def f(age: Int)
</span><span line-number="3" class=""><span class="tooltip-container"></span>val c: C
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>then</p>
    <div class="snippet mono-small-block" scala-snippet="">
     <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>c f (age = 1)
</span></code></pre>
     <div class="buttons"></div>
    </div>
    <p>will now construct a tuple as second operand instead of passing a named parameter.</p>
   </section>
  </main>
  <div class="divider"></div>
  <nav class="arrow-navigation" aria-label="Page navigation">
   <div>
    <span class="body-small">Previous</span> <a rel="prev" href="opaques-details.html" aria-keyshortcuts="Left" class="body-medium"> <span class="body-medium">Opaque Type Aliases: More Details</span> </a>
   </div>
   <div>
    <span class="body-small">Next</span> <a rel="next" href="open-classes.html" aria-keyshortcuts="Right" class="body-medium"> <span class="body-medium">Open Classes</span> </a>
   </div>
  </nav>
 </div>
</div></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><ul><li><a href="#conformance-and-convertibility">Conformance and Convertibility</a></li><li><a href="#pattern-matching">Pattern Matching</a></li><li><a href="#pattern-matching-with-named-fields-in-general">Pattern Matching with Named Fields in General</a></li><li><a href="#expansion">Expansion</a></li><li><a href="#computed-field-names">Computed Field Names</a></li><li><a href="#the-namedtuplefrom-type">The NamedTuple.From Type</a></li><li><a href="#operations-on-named-tuples">Operations on Named Tuples</a></li><li><a href="#restrictions">Restrictions</a></li></ul></li><li><a href="#syntax-changes">Syntax Changes</a><ul><li><a href="#source-incompatibilities">Source Incompatibilities</a></li></ul></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/scala/scala3"><button class="icon-button gh"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><div class="text">Copyright (c) 2002-2025, LAMP/EPFL</div></div><div class="text-mobile">Copyright (c) 2002-2025, LAMP/EPFL</div></div></div></div></body></html>